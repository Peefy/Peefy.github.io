"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[27986],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>d});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},m=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),c=p(n),h=i,d=c["".concat(s,".").concat(h)]||c[h]||u[h]||r;return n?a.createElement(d,l(l({ref:t},m),{},{components:n})):a.createElement(d,l({ref:t},m))}));function d(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,l=new Array(r);l[0]=h;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[c]="string"==typeof e?e:i,l[1]=o;for(var p=2;p<r;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},67445:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>u,frontMatter:()=>r,metadata:()=>o,toc:()=>p});var a=n(87462),i=(n(67294),n(3905));const r={title:"Schema",linkTitle:"Schema",type:"docs",weight:2,description:"Schema"},l=void 0,o={unversionedId:"reference/lang/spec/schema",id:"version-0.5.0/reference/lang/spec/schema",title:"Schema",description:"Schema",source:"@site/i18n/zh-CN/docusaurus-plugin-content-docs/version-0.5.0/reference/lang/spec/schema.md",sourceDirName:"reference/lang/spec",slug:"/reference/lang/spec/schema",permalink:"/zh-CN/docs/0.5.0/reference/lang/spec/schema",draft:!1,editUrl:"https://github.com/kcl-lang/kcl-lang.io/tree/main/versioned_docs/version-0.5.0/reference/lang/spec/schema.md",tags:[],version:"0.5.0",lastUpdatedBy:"Peefy",lastUpdatedAt:1684753665,formattedLastUpdatedAt:"2023\u5e745\u670822\u65e5",frontMatter:{title:"Schema",linkTitle:"Schema",type:"docs",weight:2,description:"Schema"},sidebar:"reference",previous:{title:"Modules",permalink:"/zh-CN/docs/0.5.0/reference/lang/spec/modules"},next:{title:"Statements",permalink:"/zh-CN/docs/0.5.0/reference/lang/spec/statements"}},s={},p=[{value:"Syntax",id:"syntax",level:2},{value:"Schema Definition",id:"schema-definition",level:3},{value:"Optional Attribute",id:"optional-attribute",level:4},{value:"Configuration Definition",id:"configuration-definition",level:3},{value:"Attribute Identify",id:"attribute-identify",level:4},{value:"List",id:"list",level:5},{value:"Attribute Operator",id:"attribute-operator",level:4},{value:"Union",id:"union",level:4},{value:"Override",id:"override",level:4},{value:"Insert",id:"insert",level:4},{value:"Index Signature",id:"index-signature",level:4},{value:"Schema Context",id:"schema-context",level:3},{value:"Arguments",id:"arguments",level:4},{value:"Check Block",id:"check-block",level:3},{value:"Specifying Types",id:"specifying-types",level:3},{value:"Immutability",id:"immutability",level:3},{value:"Assign by Value",id:"assign-by-value",level:4},{value:"Union Operator",id:"union-operator",level:3},{value:"Other Operators",id:"other-operators",level:3},{value:"Deprecated",id:"deprecated",level:3},{value:"Composition",id:"composition",level:3},{value:"Inheritance",id:"inheritance",level:3},{value:"Mixin",id:"mixin",level:3},{value:"Protocol",id:"protocol",level:3},{value:"Schema Context Evaluation",id:"schema-context-evaluation",level:3},{value:"Members",id:"members",level:3},{value:"Irrelevant Order Calculation",id:"irrelevant-order-calculation",level:3}],m={toc:p},c="wrapper";function u(e){let{components:t,...n}=e;return(0,i.kt)(c,(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"syntax"},"Syntax"),(0,i.kt)("h3",{id:"schema-definition"},"Schema Definition"),(0,i.kt)("p",null,"A schema is a language element to define a type of configuration data."),(0,i.kt)("p",null,"To define a schema, the syntax is the following:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bnf"},'schema_stmt: [decorators] "schema" ["relaxed"] identifier ["[" [arguments] "]"] ["(" operand_name ")"] ":" NEWLINE [schema_body]\nschema_body: _INDENT (string NEWLINE)* [mixin_stmt] (schema_attribute_stmt | schema_index_signature | statement)* [check_block] _DEDENT\n')),(0,i.kt)("p",null,"Attributes could be defined in a schema, the syntax is the following:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bnf"},'schema_attribute_stmt: [decorators] identifier ["?"] ":" type [(ASSIGN | augassign) test] NEWLINE\n')),(0,i.kt)("p",null,"Index signature could be defined in a schema, the syntax is the following:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bnf"},"schema_index_signature: LEFT_BRACKETS [NAME COLON] [ELLIPSIS] basic_type RIGHT_BRACKETS COLON type [ASSIGN test] NEWLINE\n")),(0,i.kt)("p",null,"Once defined, an attribute must have a valid type:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bnf"},'type: type_element ("|" type_element)*\ntype_element: schema_type | basic_type | list_type | dict_type\nschema_type: operand_name\nbasic_type: "str" | "int" | "float" | "bool"\nlist_type: "[" (type)? "]" \ndict_type: "{" (type)? COLON (type)? "}"\n')),(0,i.kt)("p",null,"The followings are some basic examples:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"# A person has a first name, a last name and an age.\nschema person:\n    firstName: str\n    lastName: str\n    # fullName is generated by firstName and lastName\n    fullName: str = firstName + ' ' + lastName\n    # The default value of age is 0\n    age: int = 0\n\n# An employee IS a person, and has some additional information.\nschema employee(person):\n    bankCard: int\n    nationality: str\n\n# A company has a name and many employees.\nschema company:\n    name: str\n    employees: [employee]\n")),(0,i.kt)("p",null,"More complex schema definitions will be elaborated after other concepts are\nintroduced."),(0,i.kt)("h4",{id:"optional-attribute"},"Optional Attribute"),(0,i.kt)("p",null,"Each attribute ",(0,i.kt)("strong",{parentName:"p"},"must")," be assigned with a not-None value as a schema instance unless it is modified by a question mark as an optional attribute."),(0,i.kt)("p",null,"Examples:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bnf"},"schema employee(person):\n    bankCard?: int # bankCard is an optional attribute \n    nationality?: str # # nationality is an optional attribute \n")),(0,i.kt)("p",null,"When there is an inheritance relationship:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"If the attribute is optional in the base schema, it could be optional or required in the sub-schema."),(0,i.kt)("li",{parentName:"ul"},"If the attribute is required in the base schema, it must be required in the sub-schema.")),(0,i.kt)("h3",{id:"configuration-definition"},"Configuration Definition"),(0,i.kt)("p",null,"A configuration is structured data stored in a dict-like structure. In KCL, we have introduced\nthe configuration definition syntax as a variant of dict definition syntax."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bnf"},'schema_expr: operand_name ("(" [arguments] ")")? dict_expr\n')),(0,i.kt)("p",null,"As can be seen, apart from having an identifier as schema type, a configuration definition\nis just an ordinary dict definition, and each key in the dict matches an attribute in the schema."),(0,i.kt)("p",null,"To simplify configuration, schema attribute key is much easier to define as:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"schema attribute key can be unquoted. When the attribute key has the same name as a variable, it must be quoted as a normal dict to avoid naming conflict."),(0,i.kt)("li",{parentName:"ul"},"schema attribute key can be defined nested through ",(0,i.kt)("inlineCode",{parentName:"li"},"select expression"),", such as ",(0,i.kt)("inlineCode",{parentName:"li"},"a.b.c"),".")),(0,i.kt)("p",null,"The comma at the end of each line can be omitted."),(0,i.kt)("p",null,"For example, we can define a ",(0,i.kt)("inlineCode",{parentName:"p"},"person")," named ",(0,i.kt)("inlineCode",{parentName:"p"},"John Doe")," using the following statement:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"johnDoe = person {\n    # In the result, 'lastName' appears later than 'firstName', according the schema\n    lastName = 'Doe'\n    firstName = 'John'\n    # If we don't specify the 'age', the default value 0 is used.\n    # 'age': 20\n}\n")),(0,i.kt)("p",null,"The result is a ",(0,i.kt)("strong",{parentName:"p"},"dict"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"{\n    'firstName': 'John'\n    'lastName': 'Doe'\n    'age': 0\n}\n")),(0,i.kt)("p",null,"Compared to the ordinary dict definition, a configuration definition has the following features:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Each attribute defined in the schema (or one of the schemas) could be configured, and config data has higher priority than the default value."),(0,i.kt)("li",{parentName:"ul"},"When an attribute defined in the schema (or one of the schemas) is not configured in the configuration definition statement, and it has a default value, the default value is used."),(0,i.kt)("li",{parentName:"ul"},"Unless the schema (or one of the schemas) is a ",(0,i.kt)("strong",{parentName:"li"},"relaxed schema"),", no more attributes can be defined."),(0,i.kt)("li",{parentName:"ul"},"The quotation marks of dict key can be omitted."),(0,i.kt)("li",{parentName:"ul"},"The comma at the end of each line can be omitted."),(0,i.kt)("li",{parentName:"ul"},"Cases of ",(0,i.kt)("strong",{parentName:"li"},"inheritance")," will be discussed separately.")),(0,i.kt)("p",null,"For attributes of list, dict and schema types, the config data is added by ",(0,i.kt)("strong",{parentName:"p"},"union")," instead of reassignment. For instance:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'schema Name:\n    firstName: str\n    lastName: str\n\nschema Person:\n    name: Name = {\n        firstNam = "John"\n        lastName = "default"\n    }\n\nJohnDoe = Person {\n    name.lastName = "Doe"\n}\n')),(0,i.kt)("p",null,"The result is a ",(0,i.kt)("strong",{parentName:"p"},"dict"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"{\n    'firstName': 'John'\n    'lastName': 'Doe'\n}\n")),(0,i.kt)("h4",{id:"attribute-identify"},"Attribute Identify"),(0,i.kt)("p",null,"Each key identifier in the configuration expr identifies an element or a range of elements in a schema. The key identifier may consist of multiple attribute identifiers, and each attribute may be a basic type value, a list, a dict or schema. For example, the key identifier 'a.b.c' identifies the element 'c' in the 'A' schema:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"\nschema C:\n    c: int\n\nschema B:\n    b: C\n\nschema A:\n    a: B\n\nA {\n    a.b.c: 5\n}\n")),(0,i.kt)("p",null,"To make the key identifier usage rules as clear as possible, we define the way of identifying with complex data types as follows."),(0,i.kt)("h5",{id:"list"},"List"),(0,i.kt)("p",null,"Suppose we have a list attribute a."),(0,i.kt)("p",null,"Identify an element in a:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"a[0]   # the first element\na[3]   # the 4th element\na[-1]  # the last element\na[-2]  # the penultimate element\n")),(0,i.kt)("p",null,"Identify a range of elements in the list:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"a[2:5]  # a slice of the third, 4th, and 5th elements\na[:5]   # a slice of the first to 5th elements\n")),(0,i.kt)("h4",{id:"attribute-operator"},"Attribute Operator"),(0,i.kt)("p",null,"Once we identified the element(s), we can declare operation on it. It follows the pattern of ",(0,i.kt)("inlineCode",{parentName:"p"},"identifier op E"),"."),(0,i.kt)("h4",{id:"union"},"Union"),(0,i.kt)("p",null,"Pattern: ",(0,i.kt)("inlineCode",{parentName:"p"},"identifier : E")),(0,i.kt)("p",null,"The value of the expression ",(0,i.kt)("inlineCode",{parentName:"p"},"E")," will be unioned into the element value."),(0,i.kt)("p",null,"Examples:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"a = A {\n    # union {d:4} into the element b.c, suppose c is a schema with an int type attribute d.\n    b.c : {\n        d : 4 \n    }\n}\n")),(0,i.kt)("p",null,"See 'union' in ",(0,i.kt)("inlineCode",{parentName:"p"},"expressions")," spec for more details."),(0,i.kt)("h4",{id:"override"},"Override"),(0,i.kt)("p",null,"Pattern: ",(0,i.kt)("inlineCode",{parentName:"p"},"identifier = E")),(0,i.kt)("p",null,"The value of the expression ",(0,i.kt)("inlineCode",{parentName:"p"},"E")," will override the element value."),(0,i.kt)("p",null,"Examples:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"a = A {\n    # override {c:4} to the element b, suppose b is a schema with an int type attribute c.\n    b = {\n        c: 4 \n    }\n}\n")),(0,i.kt)("p",null,"Unlike union, the override operation will reassign the element with a brand new value.\nFor basic type value, ",(0,i.kt)("inlineCode",{parentName:"p"},"union")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"override")," have equivalent effects."),(0,i.kt)("p",null,"Note:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},'Especially, we can "delete" its content by overriding the element to ',(0,i.kt)("inlineCode",{parentName:"li"},"Undefined"),", such as ",(0,i.kt)("inlineCode",{parentName:"li"},"{ a = Undefined }"),".")),(0,i.kt)("h4",{id:"insert"},"Insert"),(0,i.kt)("p",null,"Pattern: ",(0,i.kt)("inlineCode",{parentName:"p"},"identifier += E"),"\nInsert only works for list type ",(0,i.kt)("inlineCode",{parentName:"p"},"identifier"),"."),(0,i.kt)("p",null,"List ",(0,i.kt)("inlineCode",{parentName:"p"},"E")," will be inserted just after the specified index of the list ",(0,i.kt)("inlineCode",{parentName:"p"},"identifier"),", and the following elements after the index will be automatically shifted."),(0,i.kt)("p",null,"Examples:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"a = A {\n    # insert {c:4} to the end position(just after index=1), suppose b is a list of schema with an int type attribute c.\n    b += {\n        c: 4 \n    }\n}\n")),(0,i.kt)("p",null,"If no index is specified, the last index will be used."),(0,i.kt)("p",null,"The type of 'E' must be compatible with the type of list. See ",(0,i.kt)("inlineCode",{parentName:"p"},"types")," for more details."),(0,i.kt)("h4",{id:"index-signature"},"Index Signature"),(0,i.kt)("p",null,"Index signatures can be defined in the KCL schema, and it means that the key-value constraints of the index signature can be used to construct a dict with the schema type, or additional checks can be added to the relaxed schema attributes to enhance the KCL type and semantic checks."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Use the form ",(0,i.kt)("inlineCode",{parentName:"li"},"[{attr_alias}: {key_type}]: {value_type}")," to define an index signature in the schema, and ",(0,i.kt)("inlineCode",{parentName:"li"},"{attr_alias}")," can be omitted.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'schema Map:\n    """\n    Map is a relaxed schema with a key of str type and a value of str type\n    """\n    [str]: str  # `{attr_alias}` can be omitted.\n\ndata = Map {\n    key1 = "value1"\n    key2 = "value2"\n}\n')),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Mandatory all attributes of the schema key and value types")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"schema Person:\n    name: str\n    age: int  # error, conflicts with the index signature definition `[str]: str`\n    [str]: str  # The values of all attributes of the schema can only be strings\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Mandatory all attribute key and value types are defined in the schema, which is equivalent to restricting all attribute types except the relaxed attributes.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"schema Person:\n    name: str\n    age: int\n    [...str]: str  # Except for the `name` and `age` attributes, the key type of all other attributes of the schema must be `str`, and the value type must also be `str`.\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Define the index signature attribute alias and use it with the check block.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'schema Data:\n    [dataName: str]: str\n    check:\n        dataName in ["Alice", "Bob", "John"]\n\ndata = Data {\n    Alice = "10"\n    Bob = "12"\n    Jonn = "8"  # error Jonn not in ["Alice", "Bob", "John"]\n}\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'import regex\n\nschema DataMap:\n    [attr: str]: str\n    check:\n        regex.match(attr, r\'^[-._a-zA-Z0-9]+$\')\n\ndata = DataMap {\n    key1 = "value1"\n    "foo.bar" = "value2"  # check error\n}\n')),(0,i.kt)("h3",{id:"schema-context"},"Schema Context"),(0,i.kt)("p",null,"The schema definition space can be regarded as a separate function context."),(0,i.kt)("p",null,"Init statement could be defined inside the schema, the syntax is the following:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bnf"},"statement: small_stmt NEWLINE | if_stmt\n")),(0,i.kt)("p",null,"The following is an example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'schema Person:\n    firstName: str = "John"\n    lastName: str\n    # fullName is generated by firstName and lastName in a separate init statement\n    fullName: str = firstName + \' \' + lastName\n\nJohnDoe = Person {\n    lastName = "Doe"\n}\n')),(0,i.kt)("p",null,"The result is a ",(0,i.kt)("strong",{parentName:"p"},"dict"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"{\n    'firstName': 'John'\n    'lastName': 'Doe'\n    'fullName': 'John Doe'\n}\n")),(0,i.kt)("p",null,"If statement, expr statement and assert statement are supported as a schema init\nstatement. See more in statement spec."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The attributes must be defined first, including inherited ones, and then used in the init statement."),(0,i.kt)("li",{parentName:"ul"},"Statements in the schema context will be executed sequentially."),(0,i.kt)("li",{parentName:"ul"},"The value of attributes referenced in the init statement will be evaluated at runtime.\nSee the ",(0,i.kt)("strong",{parentName:"li"},"Configuration Definition")," section for the assignment rules of non-referenced attributes. For example, ",(0,i.kt)("inlineCode",{parentName:"li"},'"fullName"')," in Person is generated by ",(0,i.kt)("inlineCode",{parentName:"li"},'"firstName"')," and ",(0,i.kt)("inlineCode",{parentName:"li"},'"lastName"')," evaluated at runtime, in which firstName is 'John', and lastName is \"Doe\".")),(0,i.kt)("p",null,"The immutability of attributes in the schema context follows the same rules as the immutability of global variables:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'schema Person:\n    age: int = 1  # Immutable attribute\n    _name: str = "Alice"  # Mutable attribute\n\n    age = 10  # Error\n    _name = "Bob"  # Ok\n')),(0,i.kt)("h4",{id:"arguments"},"Arguments"),(0,i.kt)("p",null,"Schema context can also have arguments. The following is an example."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'schema Person[separator]:\n    firstName: str = "John"\n    lastName: str\n    fullName: str = firstName + separator + lastName\n\nJohnDoe = Person(\'_\') {\n    lastName = "Doe"\n}\n')),(0,i.kt)("p",null,"The example is similar to the previous one, except that the separator character used in\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},'"fullName"')," member is passed in as an argument. The way to perform a schema generation\nwhen the schema has an initialization function with arguments is demonstrated in the code."),(0,i.kt)("h3",{id:"check-block"},"Check Block"),(0,i.kt)("p",null,"Optionally, a check block can be added to a schema definition to allow\nadditional checking to be performed."),(0,i.kt)("p",null,"The syntax is the following:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bnf"},'check_block: "check" ":" NEWLINE _INDENT check_expr+ _DEDENT\ncheck_expr: test (IF test)? [":" primary_expr] NEWLINE\n')),(0,i.kt)("p",null,"In terms of grammatical definition, a check block consists of a list of conditional expressions. The following is an example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"schema employee(person):\n    bankCard: int\n    gender: str\n\n    check:\n        len(str(bankCard)) == 16\n        gender in ['male', 'female'], \"The gender {} is unsupported\".format(gender)\n")),(0,i.kt)("p",null,"The ability of KCL check expressions covers the abilities that can be defined by OpenAPI spec and is aligned with the ability of logical expressions. We consider further aligning the syntax with ",(0,i.kt)("inlineCode",{parentName:"p"},"CEL")," spec.\nWhether to support ",(0,i.kt)("inlineCode",{parentName:"p"},"lambda expressions")," is still under discussion."),(0,i.kt)("p",null,"Summary:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A check block consists of one or more logical ",(0,i.kt)("strong",{parentName:"li"},"expressions"),"."),(0,i.kt)("li",{parentName:"ul"},"When defining a configuration, the expressions in the check block are evaluated\nin any order. If any of the expression is ",(0,i.kt)("inlineCode",{parentName:"li"},"False"),", an error is reported."),(0,i.kt)("li",{parentName:"ul"},"A custom error message can be provided after an expression.")),(0,i.kt)("h3",{id:"specifying-types"},"Specifying Types"),(0,i.kt)("p",null,"Optionally, the type of any member of a schema can be specified. As previous examples have shown."),(0,i.kt)("p",null,"A member can be of a basic type, such as a string (",(0,i.kt)("inlineCode",{parentName:"p"},"str"),"), a floating-point number (",(0,i.kt)("inlineCode",{parentName:"p"},"float"),"), a fixed-point number (",(0,i.kt)("inlineCode",{parentName:"p"},"int"),") or a boolean number (",(0,i.kt)("inlineCode",{parentName:"p"},"bool"),")."),(0,i.kt)("p",null,"A member can also be of a dictionary generated from another schema. In such a case, the name of the other schema is used as the type name."),(0,i.kt)("p",null,"A member can also be a list or an ordinary dict:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A list with unspecified type of elements is ",(0,i.kt)("inlineCode",{parentName:"li"},"[]"),"."),(0,i.kt)("li",{parentName:"ul"},"A list with elements of type ",(0,i.kt)("inlineCode",{parentName:"li"},"t")," is ",(0,i.kt)("inlineCode",{parentName:"li"},"[t]"),". Here ",(0,i.kt)("inlineCode",{parentName:"li"},"t")," is another type."),(0,i.kt)("li",{parentName:"ul"},"A dict with keys of type ",(0,i.kt)("inlineCode",{parentName:"li"},"kt")," and values of type ",(0,i.kt)("inlineCode",{parentName:"li"},"vt")," is ",(0,i.kt)("inlineCode",{parentName:"li"},"{kt:vt}"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"kt"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"vt")," or both of them can be missing, like a list with unspecified type of elements.")),(0,i.kt)("p",null,"The followings are some more examples:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A list of lists of strings: ",(0,i.kt)("inlineCode",{parentName:"li"},"[[str]]"),"."),(0,i.kt)("li",{parentName:"ul"},"A dict of keys with the type string and unspecified value types: ",(0,i.kt)("inlineCode",{parentName:"li"},"{str:}"),".")),(0,i.kt)("p",null,"A member can be a ",(0,i.kt)("strong",{parentName:"p"},"union type")," defined by ",(0,i.kt)("inlineCode",{parentName:"p"},"|"),", such as ",(0,i.kt)("inlineCode",{parentName:"p"},"a | b"),", which means the type of the member could be a or b."),(0,i.kt)("p",null,"A union type can include types of ",(0,i.kt)("inlineCode",{parentName:"p"},"int"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"str"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"float"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"bool"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"list")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"dict")," and support type nesting e.g. ",(0,i.kt)("inlineCode",{parentName:"p"},"{str:str|int}")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"[[int|str]|str|float]"),", etc."),(0,i.kt)("p",null,"Examples:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"schema x:\n    p: int | str # p could be defined as a int or string\n")),(0,i.kt)("h3",{id:"immutability"},"Immutability"),(0,i.kt)("p",null,"KCL pursues strict immutability of schema attributes. It's generally followed the rules:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"For the attributes of the basic type, such as string, int and float, it's allowed to be reassigned\nthrough the init statement in ",(0,i.kt)("strong",{parentName:"li"},"schema context")," or by the ",(0,i.kt)("strong",{parentName:"li"},"configuration definition"),"."),(0,i.kt)("li",{parentName:"ul"},"For the attributes of list, dict and schema type, it's allowed to be reassigned only by the init statement in ",(0,i.kt)("strong",{parentName:"li"},"schema context"),". The content of it is allowed to be operated in ",(0,i.kt)("strong",{parentName:"li"},"schema context")," or by the ",(0,i.kt)("strong",{parentName:"li"},"configuration definition"),"."),(0,i.kt)("li",{parentName:"ul"},"Any other attempt to reassign or modify schema attribute will report an error.")),(0,i.kt)("h4",{id:"assign-by-value"},"Assign by Value"),(0,i.kt)("p",null,"When using a schema variable to assign the value to another variable, we can only get a deep copy of its value, not a pointer or reference. That is, modifying the assigned value will not change the assigned schema variable."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"schema Person:\n    name: str\n\nperson = {\n    name = \"Alice\"\n}\npersonCopy = person  # 'personCopy' is a deep copy of 'person' and modifying 'personCopy' will not affect 'person'\n")),(0,i.kt)("h3",{id:"union-operator"},"Union Operator"),(0,i.kt)("p",null,"For list, dict and schema, we can union delta to existing data. For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'schema Name:\n    firstName: str\n    lastName: str\n\nschema Person:\n    name: Name = {\n        firstName = "John"\n    }\n    \n    # union a schema and a dict\n    name: Name {\n        lastName = "Doe"\n    }\n\nperson = Person {}\n')),(0,i.kt)("p",null,"The result is a ",(0,i.kt)("strong",{parentName:"p"},"dict"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"{\n    'person': {\n        'name': {\n            'firstName': 'Jhon',\n            'lastName': 'Doe'\n        }\n    }\n}\n")),(0,i.kt)("h3",{id:"other-operators"},"Other Operators"),(0,i.kt)("p",null,"Except for ",(0,i.kt)("inlineCode",{parentName:"p"},"assignment")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"union assignment"),", it's not support other operators on schema type data.\nReport an error if trying to use other operators on schema type data."),(0,i.kt)("h3",{id:"deprecated"},"Deprecated"),(0,i.kt)("p",null,"The schema attribute can be marked as deprecated once it's considered invalid."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'schema Person:\n    @deprecated(version="1.1.0", reason="use fullName instead", strict=True)\n    name: str\n    ... # Omitted contents\n\nperson = Person {\n    # report an error on configing a deprecated attribute\n    name = "name"\n}\n')),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Deprecated attributes cannot be configured under any circumstances. Report an error or warning once the attribute is assigned."),(0,i.kt)("li",{parentName:"ul"},"Define the expired version of the attribute through ",(0,i.kt)("strong",{parentName:"li"},"version"),", and define the reason for the attribute expired through ",(0,i.kt)("strong",{parentName:"li"},"reason"),"."),(0,i.kt)("li",{parentName:"ul"},"When strict is true, the attribute assignment will cause an error, otherwise it will report a warning and ignore the attribute assignment.")),(0,i.kt)("h3",{id:"composition"},"Composition"),(0,i.kt)("p",null,"The composition is a common way to define complex structures. KCL provides simplified means for the configuration definition of combined structures."),(0,i.kt)("p",null,"Assuming we have the following schemas, which is defined by a combination of multiple schemas."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"schema Name:\n    firstName: str\n    lastName: str\n\nschema Person:\n    name: Name\n    age: int\n\nschema Group:\n    name: str\n    persons: [Person]\n")),(0,i.kt)("p",null,"To config a group:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'group = Group {\n    name = "group"\n    persons = [{\n        name = {\n            firstName = "John"\n            lastName = "Doe"\n        }\n        age = 24\n    }]\n}\n')),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Top-level schema name is required to config a schema."),(0,i.kt)("li",{parentName:"ul"},"The schema of the attributes in the schema can be omitted.")),(0,i.kt)("p",null,"Multi-level nested schemas will make the configuration verbose. KCL supports defining attributes in the schema through ",(0,i.kt)("inlineCode",{parentName:"p"},"selector expression"),". The selector form is ",(0,i.kt)("strong",{parentName:"p"},"x.y.z"),", see the following example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'group = Group {\n    name = "group"\n    persons = [{\n        name.firstName = "John"\n        name.lastName = "Doe"\n        age = 24\n    }]\n}\n')),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Selector can be used to represent attribute in a schema")),(0,i.kt)("h3",{id:"inheritance"},"Inheritance"),(0,i.kt)("p",null,"Inheritance is an effective means to define a hierarchical structure definition, and KCL supports limited ",(0,i.kt)("strong",{parentName:"p"},"single inheritance")," of the schema."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'schema Person:\n    firstName: str\n    lastName: str\n\n# schema Scholar inherits schema Person\nschema Scholar(Person):\n    fullName: str = firstName + \'_\' + lastName\n    subject: str\n\nJohnDoe = Scholar {\n    firstName = "John",\n    lastName = "Doe",\n    subject = "CS"\n}\n')),(0,i.kt)("p",null,"The result is a ",(0,i.kt)("strong",{parentName:"p"},"dict"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"{\n    'JohnDoe': {\n        'firstName': 'John'\n        'lastName': 'Doe'\n        'fullName': 'John Doe'\n        'subject': 'CS'\n    }\n}\n")),(0,i.kt)("p",null,"Each schema can be treated as a separated function context. Statements, including attribute statements and init statements, in the context of schemas will be evaluated from base schema to subschema according to the inheritance order. Each schema context is evaluated only once sequentially. The same goes for expressions in the check block. In the example, firstName and lastName are configured in the context of Person schema, and fullName is formed by splicing firstName and lastName in the context of Scholar schema."),(0,i.kt)("p",null,"The default value can be modified in each schema. Value defined in ",(0,i.kt)("strong",{parentName:"p"},"Configuration Definition")," has a higher priority than the default value. Attributes with default values in any schema context \u200b\u200bwill eventually be unioned by configuration data. References to attributes in the schema context statements will use the value with unioned configuration data on evaluating at runtime. For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"schema a:\n    x = 1\n    y = x * 2\n\nschema b(a):\n    x = 2\n\nv = a {\n    x = 3\n}\n\n")),(0,i.kt)("p",null,"The result is a ",(0,i.kt)("strong",{parentName:"p"},"dict"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"{\n    'v': {\n        'x': 3\n        'y': 6\n    }\n}\n")),(0,i.kt)("p",null,"Notes:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Report an error if inheriting more than one base schema."),(0,i.kt)("li",{parentName:"ul"},"The type of the base schema attribute cannot be modified in the subschema."),(0,i.kt)("li",{parentName:"ul"},"Report an error if inheriting a ",(0,i.kt)("strong",{parentName:"li"},"mixin"),"."),(0,i.kt)("li",{parentName:"ul"},"Report an error when a circular dependency occurs.")),(0,i.kt)("p",null,"Limitations:"),(0,i.kt)("p",null,"Since inheritance will derive some complex demands, we are cautious about these complex demands. There are still some restrictions on inheritance, and it's still under discussion."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"KCL provides limited and deterministic polymorphism support, more complex and flexible polymorphism support, such as ",(0,i.kt)("strong",{parentName:"li"},"self"),", ",(0,i.kt)("strong",{parentName:"li"},"super")," keywords, are temporarily not included in the schema definition."),(0,i.kt)("li",{parentName:"ul"},"Currently, KCL only supports the polymorphism of the inherited attributes of the schema, and does not support the polymorphism of the expressions in the check block."),(0,i.kt)("li",{parentName:"ul"},"For the case of multiple levels of schema inheritance, the schema arguments can only be passed to the last level of sub-schema.")),(0,i.kt)("h3",{id:"mixin"},"Mixin"),(0,i.kt)("p",null,"In addition to ",(0,i.kt)("strong",{parentName:"p"},"composition")," and ",(0,i.kt)("strong",{parentName:"p"},"inheritance"),", KCL supports declarative reuse of schema code through the ",(0,i.kt)("strong",{parentName:"p"},"mixin")," mechanism. To use a mixin, we only need to declare the ",(0,i.kt)("strong",{parentName:"p"},"mixin")," in the schema definition."),(0,i.kt)("p",null,"The ",(0,i.kt)("strong",{parentName:"p"},"mixin")," syntax is the following:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bnf"},'//////////// mixin_stmt ////////////\nmixin_stmt: "mixin" "[" [mixins | multiline_mixins] "]" "\\n"\nmultiline_mixins: "\\n" _INDENT mixins "\\n" _DEDENT\nmixins: operand_name ("," ("\\n" mixins | operand_name))*\n')),(0,i.kt)("p",null,"Here is a simple example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'schema Person:\n    mixin [FullNameMixin]\n    firstName: str = "default"\n    lastName: str\n\nschema FullNameMixin:\n    fullName: str = "{} {}".format(firstName, lastName)\n\nJohnDoe = Person {\n    firstName = "John"\n    lastName = "Doe"\n}\n')),(0,i.kt)("p",null,"The result is a ",(0,i.kt)("strong",{parentName:"p"},"dict"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"{\n    'JohnDoe': {\n        'firstName': 'John'\n        'lastName': 'Doe'\n        'fullName': 'John Doe'\n    }\n}\n")),(0,i.kt)("p",null,"Multiple mixins can be added to a single schema, and mixins context will be evaluated after the host schema context at runtime. In the inheritance scenario, the mixin context can be regarded as a part of the host schema context, and the overall evaluation of schema context order is not affected."),(0,i.kt)("p",null,"Notes:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The name of ",(0,i.kt)("strong",{parentName:"li"},"mixin")," schema must end with 'Mixin', otherwise an error will be reported."),(0,i.kt)("li",{parentName:"ul"},"The attributes referenced in the ",(0,i.kt)("strong",{parentName:"li"},"mixin")," must be defined in the ",(0,i.kt)("strong",{parentName:"li"},"mixin")," itself or host schema, otherwise an error will be reported.")),(0,i.kt)("h3",{id:"protocol"},"Protocol"),(0,i.kt)("p",null,"In addition to schema, an additional type definition method ",(0,i.kt)("inlineCode",{parentName:"p"},"protocol")," is provided in KCL, and its properties are as follows:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"In a protocol, only attributes and their types can be defined, complex logic and check expressions cannot be written, and mixins cannot be used."),(0,i.kt)("li",{parentName:"ul"},"A protocol can only inherit or refer to other protocols, but cannot inherit or refer to other schemas.")),(0,i.kt)("p",null,"We can use ",(0,i.kt)("strong",{parentName:"p"},"protocol")," to add an optional host type to the dynamically inserted ",(0,i.kt)("strong",{parentName:"p"},"mixin"),"."),(0,i.kt)("p",null,"The ",(0,i.kt)("strong",{parentName:"p"},"mixin")," can define its host type through the ",(0,i.kt)("inlineCode",{parentName:"p"},"for")," keyword, and internally it will query the type corresponding to the attribute from the host type."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"protocol DataProtocol:  # A mixin host type\n    data: str\n\nmixin DataMixin for DataProtocol:  # Using the `for` keyword to define a mixin host type\n    x: int = data  # The type of `data` is `str`, which is from `data` of `DataProtocol`\n")),(0,i.kt)("p",null,"In ",(0,i.kt)("inlineCode",{parentName:"p"},"DataMixin"),", the ",(0,i.kt)("inlineCode",{parentName:"p"},"data")," attribute is obtained according to the ",(0,i.kt)("inlineCode",{parentName:"p"},"DataProtocol")," host type as ",(0,i.kt)("inlineCode",{parentName:"p"},"str")," type, and then a type error will occur when the value is assigned to ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," of type ",(0,i.kt)("inlineCode",{parentName:"p"},"int"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"protocol DataProtocol:\n    data: str\n\nmixin DataMixin for DataProtocol:\n    x: int = data  # Error: expect int, got str\n    x: str = data  # Error: can't change schema field type of 'x' from int to str\n")),(0,i.kt)("p",null,"Please note that the host type ",(0,i.kt)("strong",{parentName:"p"},"protocol")," can only be used for ",(0,i.kt)("strong",{parentName:"p"},"mixin")," definitions (the suffix name is ",(0,i.kt)("inlineCode",{parentName:"p"},"Mixin"),"), otherwise an error will be reported."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"protocol DataProtocol:\n    data: str\n\nschema Data for DataProtocol:  # Error: only schema mixin can inherit from protocol\n    x: str = data\n")),(0,i.kt)("h3",{id:"schema-context-evaluation"},"Schema Context Evaluation"),(0,i.kt)("p",null,"The schema definition is composed of attribute statements, configuration data, init statements, mixins, and checks. In a separate schema context, the evaluation top-down order is as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"|------------------------------------------|\n|            attribute defaulting          |\n|------------------------------------------|\n|             configuration union          |\n|------------------------------------------|\n|            attribute templating          |\n|------------------------------------------|\n|       statements in declaration order    |\n|------------------------------------------|\n|          mixins in declaration order     |\n|------------------------------------------|\n|        check expressions in any order    |\n|------------------------------------------|\n")),(0,i.kt)("p",null,"In the case of schema inheritance, each schema context is evaluated from the base schema in the order of inheritance, and each context is evaluated only once.\nSuppose there are schemas a, b, and c, where c inherits b and b inherits a. Schema contexts will be evaluated in top-down order as:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"|-----------------|\n|    schema a     |\n|-----------------|\n|    schema b     |\n|-----------------|\n|    schema c     |\n|-----------------|\n")),(0,i.kt)("h3",{id:"members"},"Members"),(0,i.kt)("p",null,"Built-in function and members of schema"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"instances()\nReturn the list of existing instances of a schema.")),(0,i.kt)("h3",{id:"irrelevant-order-calculation"},"Irrelevant Order Calculation"),(0,i.kt)("p",null,"The irrelevant order calculation in the schema indicates the reference relationship between the internal attributes of the schema. For example, when we declare an expression of the form ",(0,i.kt)("inlineCode",{parentName:"p"},"a = b + 1"),", the calculation of the value of ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," depends on the calculation of the value of ",(0,i.kt)("inlineCode",{parentName:"p"},"b"),". When the compiler calculate the value of ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," and the value of ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," depends on the value of ",(0,i.kt)("inlineCode",{parentName:"p"},"b"),", the compiler will choose to first calculate the value of ",(0,i.kt)("inlineCode",{parentName:"p"},"b"),", and then calculate the value of a according to the expression ",(0,i.kt)("inlineCode",{parentName:"p"},"a = b + 1"),", which is slightly different from the calculation method of traditional procedural language the difference."),(0,i.kt)("p",null,"Since the calculation of values in the schema is based on dependencies, just like a directed acyclic graph traverses each node in the graph according to the order of topological sorting, the order of declaration of attributes in the schema is not so important, so the feature is called the irrelevant order calculation."),(0,i.kt)("p",null,"Please note that there can be no circular references between different schema attribute values."),(0,i.kt)("p",null,"We can see this feature through the following examples."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'schema Person:\n    name?: str\n    age: int = _age\n\n    _age = 10\n\n    if name == "Son":\n        _age = 18\n\nschema Son(Person):\n    name: str = "Son"\n\nperson = Person {}\nson = Son {}\n')),(0,i.kt)("p",null,"The output is"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"person:\n  name: null\n  age: 10\nson:\n  name: Son\n  age: 18\n")),(0,i.kt)("p",null,"Besides, we can achieve KCL polymorphism such as"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'schema Person:\n    name?: str\n    _age: int = _age\n\n    _age = 10\n    if name == "Son":\n        _age = 18\n    elif name == "SonConf":\n        _age = 24\n\nschema Son(Person):\n    name: str = "Son"\n\nperson = Person() {}\nson = Son() {\n    name = "SonConf"\n}\n')),(0,i.kt)("p",null,"The output is"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"person:\n  name: null\n  age: 10\nson:\n  name: SonConf\n  age: 24\n")),(0,i.kt)("p",null,"More examples:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"schema Fib:\n    n1: int = n - 1\n    n2: int = n1 - 1\n    n: int\n    value: int = _value\n\n    if n <= 2:\n        _value = 1\n    else:\n        _value = (Fib {n = n1}).value + (Fib {n = n2}).value\n\nfib8 = (Fib {n = 8}).value\n")),(0,i.kt)("p",null,"The output is"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"fib8: 21\n")),(0,i.kt)("p",null,"As in the above examples, we can see that in the schema, we only need to simply specify the dependency between attributes, and the compiler will automatically calculate the value based on the dependency, which can help us save a lot of boilerplate code and reduce configuration difficulty of writing."))}u.isMDXComponent=!0}}]);