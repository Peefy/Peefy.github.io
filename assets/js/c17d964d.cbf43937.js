"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[46103],{3905:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>k});var a=t(67294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=a.createContext({}),p=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},d=function(e){var n=p(e.components);return a.createElement(s.Provider,{value:n},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},c=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),u=p(t),c=i,k=u["".concat(s,".").concat(c)]||u[c]||m[c]||r;return t?a.createElement(k,l(l({ref:n},d),{},{components:t})):a.createElement(k,l({ref:n},d))}));function k(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,l=new Array(r);l[0]=c;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o[u]="string"==typeof e?e:i,l[1]=o;for(var p=2;p<r;p++)l[p]=t[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}c.displayName="MDXCreateElement"},37392:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>l,default:()=>m,frontMatter:()=>r,metadata:()=>o,toc:()=>p});var a=t(87462),i=(t(67294),t(3905));const r={title:"Expressions",linkTitle:"Expressions",type:"docs",weight:2,description:"Expressions"},l=void 0,o={unversionedId:"reference/lang/spec/expressions",id:"version-0.4.4/reference/lang/spec/expressions",title:"Expressions",description:"Expressions",source:"@site/versioned_docs/version-0.4.4/reference/lang/spec/expressions.md",sourceDirName:"reference/lang/spec",slug:"/reference/lang/spec/expressions",permalink:"/docs/0.4.4/reference/lang/spec/expressions",draft:!1,editUrl:"https://github.com/kcl-lang/kcl-lang.io/tree/main/versioned_docs/version-0.4.4/reference/lang/spec/expressions.md",tags:[],version:"0.4.4",lastUpdatedBy:"peefy",lastUpdatedAt:1693477178,formattedLastUpdatedAt:"Aug 31, 2023",frontMatter:{title:"Expressions",linkTitle:"Expressions",type:"docs",weight:2,description:"Expressions"},sidebar:"reference",previous:{title:"Errors",permalink:"/docs/0.4.4/reference/lang/spec/error"},next:{title:"KCL Spec",permalink:"/docs/0.4.4/reference/lang/spec/kcl-spec"}},s={},p=[{value:"Syntax",id:"syntax",level:2},{value:"Primary Expressions",id:"primary-expressions",level:3},{value:"Operands",id:"operands",level:3},{value:"Identifiers",id:"identifiers",level:3},{value:"Basic Literals",id:"basic-literals",level:3},{value:"Parenthesized Expressions",id:"parenthesized-expressions",level:3},{value:"Dictionary Expressions",id:"dictionary-expressions",level:3},{value:"List Expressions",id:"list-expressions",level:3},{value:"Comprehensions",id:"comprehensions",level:3},{value:"Conditional Expressions",id:"conditional-expressions",level:3},{value:"Unary Expressions",id:"unary-expressions",level:3},{value:"Binary Expressions",id:"binary-expressions",level:3},{value:"Logical Operations",id:"logical-operations",level:4},{value:"Comparisons",id:"comparisons",level:4},{value:"Arithmetic Operations",id:"arithmetic-operations",level:4},{value:"Membership Tests",id:"membership-tests",level:4},{value:"Function Invocations",id:"function-invocations",level:3},{value:"Selector Expressions",id:"selector-expressions",level:3},{value:"Select attribute",id:"select-attribute",level:4},{value:"Select method",id:"select-method",level:4},{value:"Index expressions",id:"index-expressions",level:3},{value:"Slice expressions",id:"slice-expressions",level:3}],d={toc:p},u="wrapper";function m(e){let{components:n,...t}=e;return(0,i.kt)(u,(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"syntax"},"Syntax"),(0,i.kt)("p",null,"In KCL, an expression specifies the computation of a value."),(0,i.kt)("p",null,"The syntax is the following:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'expression: test ("," test)*\ntest: if_expr | primary_expr | unary_expr | binary_expr\n')),(0,i.kt)("p",null,"KCL expressions consist of ",(0,i.kt)("inlineCode",{parentName:"p"},"if")," expression, ",(0,i.kt)("inlineCode",{parentName:"p"},"primary")," expression, ",(0,i.kt)("inlineCode",{parentName:"p"},"unary")," expression, and ",(0,i.kt)("inlineCode",{parentName:"p"},"binary")," expression."),(0,i.kt)("h3",{id:"primary-expressions"},"Primary Expressions"),(0,i.kt)("p",null,"Primary expressions are the operands for unary and binary expressions."),(0,i.kt)("p",null,"Operands are self-delimiting. An ",(0,i.kt)("strong",{parentName:"p"},"operand")," may be followed by any number of selector dot, a function call, or slice suffixes, to form a primary expression. The grammar uses ",(0,i.kt)("inlineCode",{parentName:"p"},"expression"),", where a multiple-component expression is allowed, and ",(0,i.kt)("inlineCode",{parentName:"p"},"test")," where it accepts an expression of only a single component."),(0,i.kt)("p",null,"Syntax:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"primary_expr: operand | primary_expr select_suffix | primary_expr call_suffix | primary_expr subscript_suffix\n")),(0,i.kt)("h3",{id:"operands"},"Operands"),(0,i.kt)("p",null,"Operand denotes the elementary value in an expression. An operand may be an identifier, a literal, or a parenthesized expression."),(0,i.kt)("p",null,"Syntax:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'operand: operand_name | number | string | "True" | "False" | "None" | list_expr | list_comp | dict_expr | dict_comp | "(" expression ")"\noperand_name: identifier | qualified_identifier\n')),(0,i.kt)("h3",{id:"identifiers"},"Identifiers"),(0,i.kt)("p",null,"In KCL, an identifier is a name, may with selectors, that identifies a value."),(0,i.kt)("p",null,"Syntax:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"identifier: NAME\n")),(0,i.kt)("p",null,"Examples:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"x\na\n_b\n")),(0,i.kt)("p",null,"Use the ",(0,i.kt)("inlineCode",{parentName:"p"},"$")," character prefix to define keyword identifiers."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'$if = 1\n$else = "s"\n')),(0,i.kt)("p",null,"Please note: whether the non-keyword identifier is prefixed with ",(0,i.kt)("inlineCode",{parentName:"p"},"$")," has the same effect."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"_a = 1\n$_a = 2  # equal to `_a = 2`\n")),(0,i.kt)("p",null,"To simplify the definition of the qualified identifier, such as 'pkg.type', we additionally define ",(0,i.kt)("inlineCode",{parentName:"p"},"qualified_identifier"),":"),(0,i.kt)("p",null,"Syntax:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'qualified_identifier: identifier "." identifier\n')),(0,i.kt)("p",null,"Examples:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"pkg.a\n")),(0,i.kt)("p",null,"The package name in qualified_identifier must be imported."),(0,i.kt)("h3",{id:"basic-literals"},"Basic Literals"),(0,i.kt)("p",null,"Basic literals supported in KCL are ",(0,i.kt)("inlineCode",{parentName:"p"},"int"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"float"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"string")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"bool")," including ",(0,i.kt)("inlineCode",{parentName:"p"},"True")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"False"),". Evaluation of basic literal yields a value of the given type with the given value."),(0,i.kt)("p",null,"Syntax:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'operand: number | string | "True" | "False" | "None" | "Undefined"\n')),(0,i.kt)("p",null,"Examples:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'1\n2.3\n"abc"\nTrue\nFalse\nNone\nUndefined\n')),(0,i.kt)("p",null,"See more details about ",(0,i.kt)("strong",{parentName:"p"},"data type")," spec."),(0,i.kt)("h3",{id:"parenthesized-expressions"},"Parenthesized Expressions"),(0,i.kt)("p",null,"An expression enclosed in parentheses yields the result of that expression."),(0,i.kt)("p",null,"Syntax:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"operand: '(' [expression] ')'\n")),(0,i.kt)("p",null,"Examples:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"x = (1 + 2) * (3 + 4)  # 21\n")),(0,i.kt)("h3",{id:"dictionary-expressions"},"Dictionary Expressions"),(0,i.kt)("p",null,"A dictionary expression is a comma-separated immutable list of colon-separated key/value expression pairs, enclosed in curly brackets, and it yields a new dictionary object. An optional comma may follow the final pair."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"dict_expr: '{' [entries [',']] '}'\nentries: entry {',' entry}\nentry: test ':' test | \"**\" primary_expr\n")),(0,i.kt)("p",null,"Examples:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'{}\n{"one": 1}\n{"one": 1, "two": 2}\n')),(0,i.kt)("p",null,"The key and value expressions are evaluated in left-to-right order. Evaluation fails if the same key is used multiple times."),(0,i.kt)("p",null,"Only hashable values may be used as the keys of a dictionary. This includes all built-in types except dictionaries, and lists."),(0,i.kt)("p",null,"We can ignore the comma ",(0,i.kt)("inlineCode",{parentName:"p"},",")," at the end of the line for writing dict key-value pairs in multiple lines:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'data = {\n    "key1" = "value1"  # Ignore the comma \',\' at the end of line\n    "key2" = "value2"\n}  # {"key1": "value1", "key2": "value2"}\n')),(0,i.kt)("p",null,"We can ignore the key quotation marks when we writing simple literals on the key."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'data = {\n    key1 = "value1"  # Ignore the comma \',\' at the end of line\n    key2 = "value2"\n}  # {"key1": "value1", "key2": "value2"}\n')),(0,i.kt)("p",null,"In addition, the ",(0,i.kt)("strong",{parentName:"p"},"config selector expressions")," can be used to init a schema instance."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'person = {\n    base.count = 2\n    base.value = "value"\n    labels.key = "value"\n}  # {"base": {"count": 2, "value": "value"}, "labels": {"key": "value"}}\n')),(0,i.kt)("p",null,"We can ",(0,i.kt)("strong",{parentName:"p"},"merge")," dict using the dict unpacking operator ",(0,i.kt)("inlineCode",{parentName:"p"},"**")," like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'_part1 = {\n    a = "b"\n}\n\n_part2 = {\n    c = "d"\n}\n\na_dict = {**_part1, **_part2}  # {"a: "b", "c": "d"}\n')),(0,i.kt)("p",null,"We can use ",(0,i.kt)("inlineCode",{parentName:"p"},"if expressions")," to dynamically add elements to the dict element, elements that meet the conditions are added to the dict, and elements that do not meet the conditions are ignored."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'a = 1  # 1\ndata = {\n    key1 = "value1"\n    if a == 1: key2 = "value2"\n    if a > 0: key3 = "value3"\n    if a < 0: key4 = "value4"\n}  # {"key1": "value1", "key2": "value2", "key3": "value3"}\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'a = 1  # 1\ndata1 = {\n    key1 = "value1"\n    if a == 1:\n        key2 = "value2"\n    elif a > 0:\n        key3 = "value3"\n    else:\n        key4 = "value4"\n}  # {"key1": "value1", "key2": "value2"}\ndata2 = {\n    key1 = "value1"\n    if a == 1: key2 = "value2"\n    elif a > 0: key3 = "value3"\n    else: key4 = "value4"\n}  # {"key1": "value1", "key2": "value2"}\n')),(0,i.kt)("h3",{id:"list-expressions"},"List Expressions"),(0,i.kt)("p",null,"A list expression is a comma-separated immutable list of element expressions, enclosed in square brackets, and it yields a new list. An optional comma may follow the last element expression."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"list_expr: '[' [list_item [',']] ']'\nlist_item: test | \"*\" primary_expr \n")),(0,i.kt)("p",null,"Element expressions are evaluated in left-to-right order."),(0,i.kt)("p",null,"Examples:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"[]                      # [], empty list\n[1]                     # [1], a 1-element list\n[1, 2, 3]               # [1, 2, 3], a 3-element list\n")),(0,i.kt)("p",null,"We can use ",(0,i.kt)("inlineCode",{parentName:"p"},"if expressions")," to dynamically add elements to the list element, elements that meet the conditions are added to the list, and elements that do not meet the conditions are ignored."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"a = 1  # 1\ndata = [\n    1\n    if a == 1: 2\n    if a > 0: 3\n    if a < 0: 4\n]  # [1, 2, 3]\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"a = 1  # 1\ndata1 = [\n    1\n    if a == 1:\n        2\n    elif a == 2:\n        3\n    else:\n        3\n]  # [1, 2]\ndata2 = [\n    1\n    if a == 1: 2\n    elif a == 2: 2\n    else: 3\n]  # [1, 2]\n")),(0,i.kt)("h3",{id:"comprehensions"},"Comprehensions"),(0,i.kt)("p",null,"A comprehension constructs a new list or dictionary value by looping over one or more iterables and evaluating a body expression that produces successive elements of the result."),(0,i.kt)("p",null,"Syntax:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"list_comp: '[' list_item comp_clause+ ']' .\ndict_comp: '{' entry comp_clause+ '}' .\n\ncomp_clause: 'for' loop_variables [\",\"] 'in' test ['if' test]\nloop_variables: primary_expr (',' primary_expr)*\n")),(0,i.kt)("p",null,"A list comprehension consists of a single expression followed by one or more clauses, the first of which must be a ",(0,i.kt)("inlineCode",{parentName:"p"},"for")," clause. Each ",(0,i.kt)("inlineCode",{parentName:"p"},"for")," clause resembles a ",(0,i.kt)("inlineCode",{parentName:"p"},"for")," statement, and specifies an iterable operand and a set of variables to be assigned by successive values of the iterable. An ",(0,i.kt)("inlineCode",{parentName:"p"},"if")," cause resembles an ",(0,i.kt)("inlineCode",{parentName:"p"},"if")," statement, and specifies a condition that must be met for the body expression to be evaluated. A sequence of ",(0,i.kt)("inlineCode",{parentName:"p"},"for")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"if")," clauses acts like a nested sequence of ",(0,i.kt)("inlineCode",{parentName:"p"},"for")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"if")," statements."),(0,i.kt)("p",null,"Examples:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"[x * x for x in range(5)]                 # [0, 1, 4, 9, 16]\n[x * x for x in range(5) if x % 2 == 0]   # [0, 4, 16]\n[[x, y] for x in range(5) \\\n        if x % 2 == 0 \\\n        for y in range(5) \\\n        if y > x]                       # [[0, 1], [0, 2], [0, 3], [0, 4], [2, 3], [2, 4]]\n")),(0,i.kt)("p",null,"Besides, we can use two variables in the list comprehension, the first variable denotes the list index and the second variable denotes the list item."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"data = [1000, 2000, 3000]\n# Single variable loop\ndataLoop1 = [i * 2 for i in data]  # [2000, 4000, 6000]\ndataLoop2 = [i for i in data if i == 2000]  # [2000]\ndataLoop3 = [i if i > 2 else i + 1 for i in data]  # [1000, 2000, 3000]\n# Double variable loop\ndataLoop4 = [i + v for i, v in data]  # [1000, 2001, 3002]\ndataLoop5 = [v for i, v in data if v == 2000]  # [2000]\n# Use `_` to ignore loop variables\ndataLoop6 = [v if v > 2000 else v + i for i, v in data]  # [1000, 2001, 3000]\ndataLoop7 = [i for i, _ in data]  # [0, 1, 2]\ndataLoop8 = [v for _, v in data if v == 2000]  # [2000]\n")),(0,i.kt)("p",null,"A dict comprehension resembles a list comprehension, but its body is a pair of expressions, key: value, separated by a colon, and its result is a dictionary containing the key/value pairs for which the body expression was evaluated. Evaluation fails if the value of any key is un-hashable."),(0,i.kt)("p",null,"Besides, we can use two variables in the dict comprehension, the first variable denotes the dict key and the second variable denotes the dict value of the key."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'data = {"key1" = "value1", "key2" = "value2"}\n# Single variable loop\ndataKeys1 = {k: k for k in data}  # {"key1": "key1", "key2": "key2"}\ndataValues1 = {k: data[k] for k in data}  # {"key1": "value1", "key2": "value2"}\n# Double variable loop\ndataKeys2 = {k: k for k, v in data}  # {"key1": "key1", "key2": "key2"}\ndataValues2 = {v: v for k, v in data}  # {"value1": "value1", "value2": "value2"}\ndataFilter = {k: v for k, v in data if k == "key1" and v == "value1"}  # {"key1": "value1"}\n# Use `_` to ignore loop variables\ndataKeys3 = {k: k for k, _ in data}  # {"key1": "key1", "key2": "key2"}\ndataValues3 = {v: v for _, v in data}  # {"value1": "value1", "value2": "value2"}\n')),(0,i.kt)("p",null,"As with a ",(0,i.kt)("inlineCode",{parentName:"p"},"for")," loop, the loop variables may exploit compound assignment:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'[x * y + z for [x, y], z in [[[2, 3], 5], [["o", 2], "!"]]      # [11, \'oo!\']\n')),(0,i.kt)("p",null,"KCL does not accept an un-parenthesized list as the operand of a for clause:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"[x * x for x in 1, 2, 3]  # parse error: unexpected comma\n")),(0,i.kt)("p",null,"Comprehensions defines a new lexical block, so assignments to loop variables have no effect on variables of the same name in an enclosing block:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"x = 1\n_ = [x for x in [2]]            # new variable x is local to the comprehension\nprint(x)                        # 1\n")),(0,i.kt)("p",null,"The operand of a comprehension's first clause (always a for) is resolved in the lexical block enclosing the comprehension. In the examples below, identifiers referring to the outer variable named x have been distinguished by subscript."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"x0 = [1, 2, 3]\n[x * x for x in x0]                 # [1, 4, 9]\n[x * x for x in x0 if x % 2 == 0]   # [4]\n")),(0,i.kt)("p",null,"All subsequent for and if expressions are resolved within the comprehension's lexical block, as in this rather obscure example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"x0 = [[1, 2], [3, 4], [5, 6]]\n[x * x for x in x0 for x in x if x % 2 == 0]     # [4, 16, 36]\n")),(0,i.kt)("p",null,"which would be more clearly rewritten as:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"x = [[1, 2], [3, 4], [5, 6]]\n[z * z for y in x for z in y if z % 2 == 0]     # [4, 16, 36]\n")),(0,i.kt)("h3",{id:"conditional-expressions"},"Conditional Expressions"),(0,i.kt)("p",null,"A conditional expression has the form ",(0,i.kt)("inlineCode",{parentName:"p"},"a if cond else b"),". It first evaluates the condition ",(0,i.kt)("inlineCode",{parentName:"p"},"cond"),". If it's true, it evaluates ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," and yields its value; otherwise it yields the value of ",(0,i.kt)("inlineCode",{parentName:"p"},"b"),"."),(0,i.kt)("p",null,"Syntax:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'if_expr: test "if" test "else" test\n')),(0,i.kt)("p",null,"Examples:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"x = True if enabled else False  # if enabled is\n")),(0,i.kt)("h3",{id:"unary-expressions"},"Unary Expressions"),(0,i.kt)("p",null,"In KCL, supported unary operators are ",(0,i.kt)("inlineCode",{parentName:"p"},"+"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"-"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"~"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"not"),"."),(0,i.kt)("p",null,"Syntax:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'unary_expr: ("+" | "-" | "~") primary_expr\n          | "not" test\n')),(0,i.kt)("p",null,"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"+ number        unary positive          (int, float)\n- number        unary negation          (int, float)\n~ number        unary bitwise inversion (int)\nnot x           logical negation        (any type)\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"+")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"-")," operators may be applied to any number (int or float) and return the number.\nThe ",(0,i.kt)("inlineCode",{parentName:"p"},"not")," operator returns the negation of the truth value of its operand."),(0,i.kt)("p",null,"Examples:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"~1   # -2\n~-1  # 0\n~0   # -1\nnot True   # False\nnot 0   # True\n")),(0,i.kt)("h3",{id:"binary-expressions"},"Binary Expressions"),(0,i.kt)("p",null,"In KCL, binary expressions consist of ",(0,i.kt)("inlineCode",{parentName:"p"},"comparisons"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"logical operations"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"arithmetic operations")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"membership tests"),"."),(0,i.kt)("p",null,"Syntax:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"binary_expr: test bin_op test\nbin_op: 'or'\n      | 'and'\n      | '==' | '!=' | '<' | '>' | '<=' | '>='\n      | 'in' | 'not' 'in'\n      | '|'\n      | '^'\n      | '&'\n      | '-' | '+'\n      | '*' | '%' | '/' | '//'\n      | '<<' | '>>'\n")),(0,i.kt)("h4",{id:"logical-operations"},"Logical Operations"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"or")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"and")," operators yield the logical disjunction and conjunction of their arguments, which need not be Booleans."),(0,i.kt)("p",null,"The expression ",(0,i.kt)("inlineCode",{parentName:"p"},"x or y")," yields the value of ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," if its truth value is ",(0,i.kt)("inlineCode",{parentName:"p"},"True"),", or the value of ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," otherwise."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'False or False   # False\nFalse or True    # True\nTrue  or True    # True\n1 or "hello"     # 1\n')),(0,i.kt)("p",null,"Similarly, ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," yields the value of ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," if its truth value is ",(0,i.kt)("inlineCode",{parentName:"p"},"False"),", or the value of ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," otherwise."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'False and False   # False\nFalse and True    # False\nTrue  and True    # True\n1 and "hello"     # "hello"\n')),(0,i.kt)("p",null,'These operators use "short circuit" evaluation, so the second expression is not evaluated if the value of the first expression has already determined the result, allowing constructions like these:'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'x and x[0] == 1   # x[0] is not evaluated if x is empty\nlen(x) == 0 or x[0] == ""\nnot x or not x[0]\n')),(0,i.kt)("h4",{id:"comparisons"},"Comparisons"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"==")," operator reports whether its operands are equal; the ",(0,i.kt)("inlineCode",{parentName:"p"},"!=")," operator is its negation."),(0,i.kt)("p",null,"The operators ",(0,i.kt)("inlineCode",{parentName:"p"},"<"),", ",(0,i.kt)("inlineCode",{parentName:"p"},">"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"<="),", and ",(0,i.kt)("inlineCode",{parentName:"p"},">=")," perform an ordered comparison of their operands. It is an error to apply these operators to operands of unequal type, unless one of the operands is an ",(0,i.kt)("inlineCode",{parentName:"p"},"int")," and the other is a ",(0,i.kt)("inlineCode",{parentName:"p"},"float"),". Of the built-in types, only the following support ordered comparison, using the ordering relation shown:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"NoneType        # None <= None\nbool            # False < True\nint             # mathematical\nfloat           # as defined by IEEE 754\nstring          # lexicographical\nlist            # lexicographical\n")),(0,i.kt)("p",null,"Comparison of floating-point values follows the IEEE 754 standard, which breaks several mathematical identities. For example, if ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," is a ",(0,i.kt)("inlineCode",{parentName:"p"},"NaN")," value, the comparisons ",(0,i.kt)("inlineCode",{parentName:"p"},"x < y"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"x == y"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"x > y")," all yield false for all values of ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),"."),(0,i.kt)("p",null,"The remaining built-in types support only equality comparisons. Values of type ",(0,i.kt)("inlineCode",{parentName:"p"},"dict")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"schema")," compare equal if their elements compare equal, and values of type function or ",(0,i.kt)("inlineCode",{parentName:"p"},"builtin_function_or_method")," are equal only to themselves."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"dict                            # equal contents\nschema                          # equal exported-attributes\nfunction                        # identity\nbuiltin_function_or_method      # identity\n")),(0,i.kt)("h4",{id:"arithmetic-operations"},"Arithmetic Operations"),(0,i.kt)("p",null,"The following table summarizes the binary arithmetic operations available for built-in types:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Arithmetic (int or float; result has type float unless both operands have type int)\n   number + number              # addition\n   number - number              # subtraction\n   number * number              # multiplication\n   number / number              # real division  (result is always a float)\n   number // number             # floored division\n   number % number              # remainder of floored division\n   number ^ number              # bitwise XOR\n   number << number             # bitwise left shift\n   number >> number             # bitwise right shift\n\nConcatenation\n   string + string\n     list + list\n\nRepetition (string/list)\n      int * sequence\n sequence * int\n\nUnion\n      int | int\n     list | list\n     dict | dict\n   schema | schema\n   schema | dict\nbasictype | basictype\n")),(0,i.kt)("p",null,"The operands of the arithmetic operators ",(0,i.kt)("inlineCode",{parentName:"p"},"+"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"-"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"*"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"//"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"%")," must both be numbers (",(0,i.kt)("inlineCode",{parentName:"p"},"int")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"float"),") but need not have the same type. The type of the result has type ",(0,i.kt)("inlineCode",{parentName:"p"},"int")," only if both operands have that type. The result of real division / always has type ",(0,i.kt)("inlineCode",{parentName:"p"},"float"),"."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"+")," operator may be applied to non-numeric operands of the same type, such as two lists, or two strings, in which case it computes the concatenation of the two operands and yields a new value of the same type."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'"Hello, " + "world"           # "Hello, world"\n[1, 2] + [3, 4]               # [1, 2, 3, 4]\n')),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"*")," operator may be applied to an integer n and a value of type ",(0,i.kt)("inlineCode",{parentName:"p"},"string"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"list"),", in which case it yields a new value of the same sequence type consisting of n repetitions of the original sequence. The order of the operands is immaterial. Negative values of n behave like zero."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"'mur' * 2               # 'murmur'\n3 * range(3)            # [0, 1, 2, 0, 1, 2, 0, 1, 2]\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"&")," operator requires two operands of the same type, such as ",(0,i.kt)("inlineCode",{parentName:"p"},"int"),". For integers, it yields the bitwise intersection (AND) of its operands."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"|")," operator likewise computes bitwise, unions basic types and unions collection and schema data, such as ",(0,i.kt)("strong",{parentName:"p"},"list"),", ",(0,i.kt)("strong",{parentName:"p"},"dict")," and ",(0,i.kt)("strong",{parentName:"p"},"schema"),"."),(0,i.kt)("p",null,"Computing bitwise examples:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"0x12345678 | 0xFF  # 0x123456FF\n")),(0,i.kt)("p",null,"Unioning basic types examples:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"schema x:\n    a: int | str  # attribute a could be a int or string\n")),(0,i.kt)("p",null,"A union type is used to define a schema attribute type. See more details in ",(0,i.kt)("strong",{parentName:"p"},"schema")," spec.\nSupported types in a union type are ",(0,i.kt)("inlineCode",{parentName:"p"},"int"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"str"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"float"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"bool"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"list")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"dict"),"."),(0,i.kt)("p",null,"Unioning collection and schema data:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Unioning List. Overwrite the list expression on the right side of the operator ",(0,i.kt)("inlineCode",{parentName:"li"},"|")," to the list variable on the left side of the operator one by one according to the ",(0,i.kt)("strong",{parentName:"li"},"index"),".")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"_a = [1, 2, 3]\n_b = [4, 5, 6, 7]\nx = _a | _b  # [4, 5, 6, 7]  4 -> 1; 5 -> 2; 6 -> 3; 7 -> None\n")),(0,i.kt)("p",null,"Unioning to the specific index or all elements is still under discussion."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Unioning Dict. Union the dict expression on the right side of the operator ",(0,i.kt)("inlineCode",{parentName:"li"},"|")," one by one to the dict variable on the left side of the operator according to the ",(0,i.kt)("strong",{parentName:"li"},"key"))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'_a = {key1 = "value1"}\n_b = {key1 = "overwrite", key2 = "value2"}\n_c = _a | _b  # {"key1": "overwrite", "key2": "value2"}\n')),(0,i.kt)("p",null,"The union of collection and schema is a new one whose attributes are unioning b to a, preserving the order of the attributes of the operands, left before right."),(0,i.kt)("p",null,"Unioning to the specific key or all keys is still under discussion."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Unioning Schema.")),(0,i.kt)("p",null,"The union operation for schema is similar to dict."),(0,i.kt)("p",null,"Schema union could be done as:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'schema Person:\n    firstName: str\n    lastName: str\n\n_a = Person {\n    firstName = "John"\n}\n_b = {lastName = "Doe"}\n_a = _a | _b  # {"firstName": "John", "lastName": "Doe"}\n')),(0,i.kt)("p",null,"Unioning to a specific attribute is still under discussion. Unioning to all attributes is not applicable to schema instances."),(0,i.kt)("p",null,"See ",(0,i.kt)("strong",{parentName:"p"},"selector expression")," in ",(0,i.kt)("strong",{parentName:"p"},"expression")," spec for more details."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"^")," operator accepts operands of ",(0,i.kt)("inlineCode",{parentName:"p"},"int"),". For integers, it yields the bitwise XOR (exclusive OR) of its operands."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"<<")," and ",(0,i.kt)("inlineCode",{parentName:"p"},">>")," operators require operands of ",(0,i.kt)("inlineCode",{parentName:"p"},"int")," type both. They shift the first operand to the left or right by the number of bits given by the second operand. It is a dynamic error if the second operand is negative. Implementations may impose a limit on the second operand of a left shift."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"0x12345678 & 0xFF               # 0x00000078\n0b01011101 ^ 0b110101101        # 0b111110000\n0b01011101 >> 2                 # 0b010111\n0b01011101 << 2                 # 0b0101110100\n")),(0,i.kt)("h4",{id:"membership-tests"},"Membership Tests"),(0,i.kt)("p",null,"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"      any in     sequence       (list, dict, schema, string)\n      any not in sequence\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"in")," operator reports whether its first operand is a member of its second operand, which must be a list, dict, schema, or string. The ",(0,i.kt)("inlineCode",{parentName:"p"},"not in")," operator is its negation. Both return a Boolean."),(0,i.kt)("p",null,"The meaning of membership varies by the type of the second operand: the members of a list are its elements; the members of a dict are its keys; the members of a string are all its substrings."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'1 in [1, 2, 3]                  # True\n\nd = {"one" = 1, "two" = 2}\n"one" in d                      # True\n"three" in d                    # False\n1 in d                          # False\n[] in d                         # False\n\n"nasty" in "dynasty"            # True\n"a" in "banana"                 # True\n"f" not in "way"                # True\n\nd = data {one = 1, two = 2}       # data is a schema with attributes one and two\n"one" in d                      # True\n"three" in d                    # False\n')),(0,i.kt)("h3",{id:"function-invocations"},"Function Invocations"),(0,i.kt)("p",null,"KCL allows calling built-in functions and functions from built-in and system modules. Whether KCL allows defining new functions is under discussion."),(0,i.kt)("p",null,"Syntax:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'call_suffix: "(" [arguments [","]] ")"\narguments: argument ("," argument)*\nargument: test | identifier "=" test | "*" test | "**" test\n')),(0,i.kt)("p",null,"To call a function, the basic way is shown as the following code excerpt:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'print("An argument")\n\nimport math\n# 2 powers 3 is 8.\na = math.pow(2, 3)\n')),(0,i.kt)("p",null,"As you can see, arguments are separated with ",(0,i.kt)("inlineCode",{parentName:"p"},","),". Arguments can only be passed in this way. KCL supports positional arguments and key-value arguments."),(0,i.kt)("p",null,"Note that:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Some functions have parameters with default values."),(0,i.kt)("li",{parentName:"ul"},"Some functions accept variadic arguments.")),(0,i.kt)("p",null,"When an argument is not supplied for a parameter without a default value,\nan error will be reported."),(0,i.kt)("h3",{id:"selector-expressions"},"Selector Expressions"),(0,i.kt)("p",null,"A selector expression selects the attribute or method of the value."),(0,i.kt)("h4",{id:"select-attribute"},"Select attribute"),(0,i.kt)("p",null,"Syntax:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'select_suffix: ["?"] "." identifier\n')),(0,i.kt)("p",null,"KCL provides a wealth of ways to identify or filter attributes."),(0,i.kt)("p",null,"x.y"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"schema: it denotes the attribute value of a schema ",(0,i.kt)("inlineCode",{parentName:"li"},"x")," identified by ",(0,i.kt)("inlineCode",{parentName:"li"},"y")),(0,i.kt)("li",{parentName:"ul"},"package: it denotes the identifier of a package ",(0,i.kt)("inlineCode",{parentName:"li"},"x")," identified by ",(0,i.kt)("inlineCode",{parentName:"li"},"y"))),(0,i.kt)("p",null,"Examples:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'schema Person:\n    name: str\n    age: int\n\nperson = Person {\n    name = "Alice"\n    age = 18\n}\nname = person.name  # "Alice"\nage = person.age  # 18\n')),(0,i.kt)("p",null,"x?.y"),(0,i.kt)("p",null,"If the x if None/Undefined or empty(empty list or dict), just return None, otherwise behave as x.y."),(0,i.kt)("p",null,"Examples"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"noneData = None\ndata?.name # None\n\nemptyDict = {}\nemptyDict?.name # None\n\nemptyList = []\nemptyList?[0] # None\n")),(0,i.kt)("p",null,"As a supplementary of the ",(0,i.kt)("inlineCode",{parentName:"p"},"selector")," expression in KCL code, the KCL compiler needs to provide corresponding identifying and filtering features through the command line and api form."),(0,i.kt)("h4",{id:"select-method"},"Select method"),(0,i.kt)("p",null,"Syntax:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'select_suffix: "." identifier\n')),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"identifier")," identifies method belongs to the built-in types ",(0,i.kt)("inlineCode",{parentName:"p"},"string"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"list"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"dict"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"schema"),"."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A selector expression fails if the value does not have an attribute of the specified name."),(0,i.kt)("li",{parentName:"ul"},"A selector expression that selects a method typically appears within a call expression, as in these examples:")),(0,i.kt)("p",null,"Examples:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'["able", "baker", "charlie"].index("baker")     # 1\n"banana".count("a")                             # 3\n"banana".reverse()                              # error: string has no .reverse field or method\nPerson.instances()                              # all instances of schema Person\n')),(0,i.kt)("p",null,"But when not called immediately, the selector expression evaluates to a bound method, that is, a method coupled to a specific receiver value. A bound method can be called like an ordinary function, without a receiver argument:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'f = "banana".count\nf                                               # <built-in method count of string value>\nf("a")                                          # 3\nf("n")                                          # 2\n')),(0,i.kt)("h3",{id:"index-expressions"},"Index expressions"),(0,i.kt)("p",null,"An index expression ",(0,i.kt)("inlineCode",{parentName:"p"},"a[i]")," yields the ",(0,i.kt)("inlineCode",{parentName:"p"},"i")," th element of an indexable type such as a string or list. The index ",(0,i.kt)("inlineCode",{parentName:"p"},"i")," must be an ",(0,i.kt)("inlineCode",{parentName:"p"},"int")," value in the range ",(0,i.kt)("inlineCode",{parentName:"p"},"-n")," \u2264 ",(0,i.kt)("inlineCode",{parentName:"p"},"i")," < ",(0,i.kt)("inlineCode",{parentName:"p"},"n"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"len(a)"),"; any other index results in an error."),(0,i.kt)("p",null,"Syntax:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'subscript_suffix: "[" [test] "]"\n')),(0,i.kt)("p",null,"A valid negative index ",(0,i.kt)("inlineCode",{parentName:"p"},"i")," behaves like the non-negative index ",(0,i.kt)("inlineCode",{parentName:"p"},"n+i"),", allowing for convenient indexing relative to the end of the sequence."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'"abc"[0]                        # "a"\n"abc"[1]                        # "b"\n"abc"[-1]                       # "c"\n\n["zero", "one", "two"][0]       # "zero"\n["zero", "one", "two"][1]       # "one"\n["zero", "one", "two"][-1]      # "two"\n')),(0,i.kt)("p",null,"An index expression ",(0,i.kt)("inlineCode",{parentName:"p"},"d[key]")," may also be applied to a dictionary ",(0,i.kt)("inlineCode",{parentName:"p"},"d"),", to obtain the value associated with the specified key. It returns ",(0,i.kt)("inlineCode",{parentName:"p"},"Undefined")," if the dictionary contains no such key."),(0,i.kt)("p",null,"An index expression appearing on the left side of an assignment causes the specified list or dictionary element to be updated:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"a = range(3)            # a == [0, 1, 2]\nb = a[2]  # 2\n\n\n")),(0,i.kt)("p",null,"It is a dynamic error to attempt to update an element of an immutable type, such as a list or string, or a frozen value of a mutable type."),(0,i.kt)("h3",{id:"slice-expressions"},"Slice expressions"),(0,i.kt)("p",null,"A slice expression ",(0,i.kt)("inlineCode",{parentName:"p"},"a[start:stop:stride]")," yields a new value containing a sub-sequence of ",(0,i.kt)("inlineCode",{parentName:"p"},"a"),", which must be a string, or list."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'subscript_suffix: "[" [test] [":" [test] [":" [test]]] "]"\n')),(0,i.kt)("p",null,"Each of the ",(0,i.kt)("inlineCode",{parentName:"p"},"start"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"stop"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"stride")," operands is optional; if present, and not ",(0,i.kt)("inlineCode",{parentName:"p"},"None"),", each must be an integer.\nThe ",(0,i.kt)("inlineCode",{parentName:"p"},"stride")," value defaults to 1. If the stride is not specified, the colon preceding it may be omitted too. It is an error to specify a stride of zero."),(0,i.kt)("p",null,"Conceptually, these operands specify a sequence of values ",(0,i.kt)("inlineCode",{parentName:"p"},"i")," starting at start and successively adding ",(0,i.kt)("inlineCode",{parentName:"p"},"stride")," until ",(0,i.kt)("inlineCode",{parentName:"p"},"i")," reaches or passes ",(0,i.kt)("inlineCode",{parentName:"p"},"stop"),". The result consists of the concatenation of values of ",(0,i.kt)("inlineCode",{parentName:"p"},"a[i]")," for which ",(0,i.kt)("inlineCode",{parentName:"p"},"i")," is valid.`"),(0,i.kt)("p",null,"The effective start and stop indices are computed from the three operands as follows. Let ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," be the length of the sequence."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"If the stride is positive"),": If the ",(0,i.kt)("inlineCode",{parentName:"p"},"start")," operand was omitted, it defaults to -infinity. If the ",(0,i.kt)("inlineCode",{parentName:"p"},"end")," operand was omitted, it defaults to +infinity. For either operand, if a negative value was supplied, ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," is added to it. The ",(0,i.kt)("inlineCode",{parentName:"p"},"start")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"end"),' values are then "clamped" to the nearest value in the range 0 to ',(0,i.kt)("inlineCode",{parentName:"p"},"n"),", inclusive."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"If the stride is negative"),": If the ",(0,i.kt)("inlineCode",{parentName:"p"},"start")," operand was omitted, it defaults to +infinity. If the ",(0,i.kt)("inlineCode",{parentName:"p"},"end")," operand was omitted, it defaults to -infinity. For either operand, if a negative value was supplied, ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," is added to it. The ",(0,i.kt)("inlineCode",{parentName:"p"},"start")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"end"),' values are then "clamped" to the nearest value in the range -1 to ',(0,i.kt)("inlineCode",{parentName:"p"},"n"),"-1, inclusive."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'"abc"[1:]               # "bc"  (remove first element)\n"abc"[:-1]              # "ab"  (remove last element)\n"abc"[1:-1]             # "b"   (remove first and last element)\n"banana"[1::2]          # "aaa" (select alternate elements starting at index 1)\n"banana"[4::-2]         # "nnb" (select alternate elements in reverse, starting at index 4)\n')),(0,i.kt)("p",null,"It's not allowed to define a slice expression as a left value in KCL.\nCause list and string are immutable, re-slicing can directly operate to operand to ensure better performance."))}m.isMDXComponent=!0}}]);