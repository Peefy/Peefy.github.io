"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[21788],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>g});var a=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=a.createContext({}),c=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},p=function(e){var n=c(e.components);return a.createElement(s.Provider,{value:n},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=c(t),m=r,g=d["".concat(s,".").concat(m)]||d[m]||u[m]||o;return t?a.createElement(g,i(i({ref:n},p),{},{components:t})):a.createElement(g,i({ref:n},p))}));function g(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=m;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l[d]="string"==typeof e?e:r,i[1]=l;for(var c=2;c<o;c++)i[c]=t[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},55580:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var a=t(87462),r=(t(67294),t(3905));const o={slug:"2023-06-29-k8s-sidecar-2",title:"Talking about the SideCar design pattern in K8S - Part 2",authors:{name:"KCL Team",title:"KCL Team"},tags:["KCL","k8s","SideCar"]},i=void 0,l={permalink:"/blog/2023-06-29-k8s-sidecar-2",editUrl:"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-06-29-k8s-sidecar-2/index.md",source:"@site/blog/2023-06-29-k8s-sidecar-2/index.md",title:"Talking about the SideCar design pattern in K8S - Part 2",description:"Introduction",date:"2023-06-29T00:00:00.000Z",formattedDate:"June 29, 2023",tags:[{label:"KCL",permalink:"/blog/tags/kcl"},{label:"k8s",permalink:"/blog/tags/k-8-s"},{label:"SideCar",permalink:"/blog/tags/side-car"}],readingTime:2.435,hasTruncateMarker:!1,authors:[{name:"KCL Team",title:"KCL Team"}],frontMatter:{slug:"2023-06-29-k8s-sidecar-2",title:"Talking about the SideCar design pattern in K8S - Part 2",authors:{name:"KCL Team",title:"KCL Team"},tags:["KCL","k8s","SideCar"]},prevItem:{title:"KCL Introduction on WAIC 2023 Meeting",permalink:"/blog/2023-07-08-kcl-waic-meeting"},nextItem:{title:"Talking about the Sidecar design pattern in K8S - Part 1",permalink:"/blog/2023-06-05-k8s-sidecar-1"}},s={authorsImageUrls:[void 0]},c=[{value:"Introduction",id:"introduction",level:2},{value:"1. OpenAPI Definition for Pods",id:"1-openapi-definition-for-pods",level:3},{value:"2. Defining Pod Resources with KCL",id:"2-defining-pod-resources-with-kcl",level:3},{value:"3. Conclusion",id:"3-conclusion",level:3}],p={toc:c},d="wrapper";function u(e){let{components:n,...t}=e;return(0,r.kt)(d,(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"introduction"},"Introduction"),(0,r.kt)("p",null,"In the previous blog ",(0,r.kt)("a",{parentName:"p",href:"/blog/2023-06-05-k8s-sidecar-1/"},"Exploring the Sidecar Design Pattern in K8s - Part 1"),", we introduced the Sidecar design pattern using layman's terms. In this blog, we'll use KCL, a modern, type-safe configuration language, to showcase the description of Pod resources. In the subsequent blogs, we'll use KCL to explore the practical applications of the Sidecar pattern."),(0,r.kt)("h3",{id:"1-openapi-definition-for-pods"},"1. OpenAPI Definition for Pods"),(0,r.kt)("p",null,"Let's go back to the simplest example of Nginx, where the YAML file follows a similar pattern:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: v1\nkind: Pod\nmetadata:\n  name: web-app\nspec:\n  containers:\n  - image: nginx\n    name: main-container\n    ports:\n      - containerPort: 80\n")),(0,r.kt)("p",null,"Here, the Pod data follows the definition of the io.k8s.api.core.v1.Pod model in the Kubernetes specification. The complete OpenAPI definition can be found here. By analyzing it carefully, we can see that the apiVersion and kind information are commonly used default configurations. We need a more modern configuration language to simplify it."),(0,r.kt)("h3",{id:"2-defining-pod-resources-with-kcl"},"2. Defining Pod Resources with KCL"),(0,r.kt)("p",null,"KCL is a configuration policy language for the cloud-native domain. For more information, please refer to the ",(0,r.kt)("a",{parentName:"p",href:"https://kcl-lang.io/"},"official website"),". Basic KCL configuration programs still follow the ",(0,r.kt)("inlineCode",{parentName:"p"},"K=V")," format, which is similar to YAML. For example, we can rewrite the configuration of the Nginx container using the following KCL code:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'import k8s.api.core.v1 as k8core\n\nk8core.Pod {\n    metadata.name = "web-app"\n    spec.containers = [{\n        name = "main-container"\n        image = "nginx"\n        ports = [{containerPort: 80}]\n    }]\n}\n')),(0,r.kt)("p",null,"Here, the ",(0,r.kt)("inlineCode",{parentName:"p"},"import")," statement imports the ",(0,r.kt)("inlineCode",{parentName:"p"},"k8s/api/core/v1")," package from the k8s package, and the ",(0,r.kt)("inlineCode",{parentName:"p"},"Pod")," structure definition corresponds to the ",(0,r.kt)("inlineCode",{parentName:"p"},"Pod")," model. The default values for apiVersion and kind have already been included, so we only need to add the ",(0,r.kt)("inlineCode",{parentName:"p"},"metadata.name")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"spec.containers")," properties (KCL also provides syntax sugar for some multi-level nested properties). We can use the ",(0,r.kt)("a",{parentName:"p",href:"https://kcl-lang.io/docs/user_docs/guides/package-management/installation/"},"kpm package management tool")," to create a KCL program to define a Pod resource and execute the program to get the corresponding YAML:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},'# 1. Initialize a kcl program package called hello.\nkpm init hello\n# 2. Edit the main.k file inside the hello package and add the KCL configuration code mentioned earlier.\ncat <<EOF > hello/main.k\nimport k8s.api.core.v1 as k8core\nk8core.Pod {\n    metadata.name = "web-app"\n    spec.containers = [{\n        name = "main-container"\n        image = "nginx"\n        ports = [{containerPort: 80}]\n    }]\n}\nEOF\n# 3. Navigate to the hello package, add the k8s dependency, and run the hello package.\ncd hello && kpm add k8s && kpm run\n')),(0,r.kt)("p",null,"The following YAML output can be obtained:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: v1\nkind: Pod\nmetadata:\n  name: web-app\nspec:\n  containers:\n    - image: nginx\n      name: main-container\n      ports:\n        - containerPort: 80\n")),(0,r.kt)("h3",{id:"3-conclusion"},"3. Conclusion"),(0,r.kt)("p",null,"In this blog, we briefly introduced how to use KCL to build Pod configurations for more flexible and robust configurations. In the subsequent blogs, we'll use KCL to extract and abstract the best Sidecar pattern practices, including using KCL to abstract the Sidecar model and using KCL to inject Sidecars into existing upstream YAML configurations."))}u.isMDXComponent=!0}}]);