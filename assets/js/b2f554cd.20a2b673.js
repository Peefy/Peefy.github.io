"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[11477],{30010:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"2023-10-25-biweekly-newsletter","metadata":{"permalink":"/blog/2023-10-25-biweekly-newsletter","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-10-25-biweekly-newsletter/index.md","source":"@site/blog/2023-10-25-biweekly-newsletter/index.md","title":"KCL Biweekly Newsletter (2023 10.12 - 10.25) | FindReferences and Rename in IDE, ArtifactHub integration in KPM!","description":"KCL is a constraint-based record and functional language hosted by Cloud Native Computing Foundation(CNCF) that enhances the writing of complex configurations, including those for cloud-native scenarios. With its advanced programming language technology and practices, KCL is dedicated to promoting better modularity, scalability, and stability for configurations. It enables simpler logic writing and offers ease of automation APIs and integration with homegrown systems.","date":"2023-10-25T00:00:00.000Z","formattedDate":"October 25, 2023","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Biweekly-Newsletter","permalink":"/blog/tags/biweekly-newsletter"}],"readingTime":3.37,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2023-10-25-biweekly-newsletter","title":"KCL Biweekly Newsletter (2023 10.12 - 10.25) | FindReferences and Rename in IDE, ArtifactHub integration in KPM!","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["KCL","Biweekly-Newsletter"]},"nextItem":{"title":"A New Paradigm for Cloud Native Configuration and Policy Management - KRM KCL Specification","permalink":"/blog/2023-10-23-cloud-native-supply-chain-krm-kcl-spec"}},"content":"![](/img/biweekly-newsletter.png)\\n\\n[KCL](https://github.com/kcl-lang) is a constraint-based record and functional language hosted by Cloud Native Computing Foundation(CNCF) that enhances the writing of complex configurations, including those for cloud-native scenarios. With its advanced programming language technology and practices, KCL is dedicated to promoting better modularity, scalability, and stability for configurations. It enables simpler logic writing and offers ease of automation APIs and integration with homegrown systems.\\n\\nThis section will update the KCL language community\'s latest developments every two weeks, including features, website updates, and the latest community news, helping everyone better understand the KCL community!\\n\\n***KCL Website: [https://kcl-lang.io](https://kcl-lang.io)***\\n\\n## Overview\\n\\nThank you to all contributors for their outstanding work over the past two weeks (10.12 - 10.25 2023). Here is an overview of the key content:\\n\\n**\ud83d\udd27 Language and Toolchain Updates**\\n\\n- **KCL IDE Updates** - Supports for symbol find-references and rename; Optimized the formatting output for import statements and union types; Fixed the bug where file changes caused the language server to crash.\\n- **KCL Package Management Tool KPM Updates** - kpm is integrating with ArtifactHub, enabling KCL packages publishing to ArtifactHub.\\n- **KCL Language Updates** - Optimized error messages for mismatched parameter types in methods, providing clearer indications of the mismatch. \\n- **Unified Interface of KCL Command-Line** - Redesigned the command-line interface and workflow for KCL tools to achieve a unified experience.\\n\\n## Special Thanks\\n\\nThe following are listed in no particular order:\\n\\n+ Thanks to @jakezhu9 for enhancing the KCL syntax parsing unit tests, migrating some test cases to the snaptest framework \ud83d\ude4c [https://github.com/kcl-lang/kcl/pull/794](https://github.com/kcl-lang/kcl/pull/794)\\n+ Thanks to @opsnull for correcting code examples in kcl-lang.io website \ud83d\ude4c [https://github.com/kcl-lang/kcl-lang.io/pull/182](https://github.com/kcl-lang/kcl-lang.io/pull/182)\\n+ Thanks to @prahaladramji for fixing and optimizing the formatting functionality in the KCL IntelliJ plugin \ud83d\ude4c [https://github.com/kcl-lang/intellij-kcl/pull/15](https://github.com/kcl-lang/intellij-kcl/pull/15), etc.\\n+ Thanks to @steeling, @prahaladramji, @liangyuanpen, @Kory Taborn, and others for valuable feedback and discussions while using KCL and the toolchain \ud83d\ude4c\\n\\n## Featured Updates\\n\\n### IDE Extension Updates\\n\\nIn the upcoming release, the KCL IDE extension will support find/go-to references navigation, symbol renaming, and some optimizations for formatting import statements and union types. Additionally, virtual file system-related bugs causing language service crashes have been fixed.\\n\\nGo-to references:\\n![](/img/docs/tools/Ide/vs-code/FindRefs.png)\\n\\nRename symbols:\\n![](/img/docs/tools/Ide/vs-code/Rename.gif)\\n\\nFormatting improvements for import statements and union types: optimized behavior for newlines between reference statements and other code blocks (formatted as a single newline) and spacing between union types (formatted with ` | ` as separators):\\n![](/img/blog/2023-10-25-kcl-biweekly-newsletter/Format.gif)\\n\\n### KCL Package Manager Updates\\n\\nIn the upcoming release, KPM will support integration with [ArtifactHub](https://artifacthub.io/). You can now submit a PR to the [kcl-lang Registry repository](https://github.com/kcl-lang/artifacthub) to publish your KCL packages on ArtifactHub. The pre-uploaded KCL Kubernetes package can be seen on the [ArtifactHub staging page](https://staging.artifacthub.io/packages/search?ts_query_web=kcl&sort=relevance&page=1). The functionality will be released in version v0.6.1:\\n\\n![](/img/docs/tools/kpm/artifacthubStaging.png)\\n\\n### KCL Language Updates\\n\\nThe compilation command of KCL continues to improve error message output, aiming to provide clear and understandable guidance to help developers quickly identify and fix errors while writing correct code. Recently, error messages related to method parameter type mismatches have been optimized, clearly indicating parameter type mismatches:\\n\\n![](/img/blog/2023-10-25-kcl-biweekly-newsletter/error-msg.png)\\n\\nAdditionally, a fix addressed the issue of lazy evaluation in property assignments, deferring the computation and constraint validation of property assignments until after configuration merging to avoid unnecessary compilation errors.\\n\\n### Unified Interface of KCL Command-Line\\n\\nWe are redesigning the command-line interface of KCL tools to achieve a unified user workflow, seamless integration with related tools and multi-language APIs, and command-line tool extensibility. Welcome to join the discussion if anyone are insterested: https://github.com/kcl-lang/kcl/issues/756.\\n\\n### Community Updates\\n\\nWith the inclusion in CNCF Sandbox, we are glad to announce that the CNCF KCL Slack channel is now available for KCL-related discussions. Feel free to join:\\n\\n1. Join the CNCF workspace by providing your email address: https://communityinviter.com/apps/cloud-native/cncf\\n2. Join the CNCF KCL channel: https://cloud-native.slack.com/archives/C05TC96NWN8\\n\\n## Resources\\n\\n\u2764\ufe0f Thanks to all KCL users and community members for their valuable feedback and suggestions in the community.\\n\\nFor more resources, please refer to\\n\\n- [KCL Website](https://kcl-lang.io/)\\n- [KusionStack Website](https://kusionstack.io/)\\n\\n- [KCL 2023 Roadmap](https://kcl-lang.io/docs/community/release-policy/roadmap)\\n- [KCL v0.7.0 Milestone](https://github.com/kcl-lang/kcl/milestone/7)\\n- [KCL Github Issues](https://github.com/kcl-lang/kcl/issues)\\n- [KCL Github Discussion](https://github.com/orgs/kcl-lang/discussions)\\n- [KCL Community](https://github.com/kcl-lang/community)"},{"id":"2023-10-23-cloud-native-supply-chain-krm-kcl-spec","metadata":{"permalink":"/blog/2023-10-23-cloud-native-supply-chain-krm-kcl-spec","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-10-23-cloud-native-supply-chain-krm-kcl-spec/index.md","source":"@site/blog/2023-10-23-cloud-native-supply-chain-krm-kcl-spec/index.md","title":"A New Paradigm for Cloud Native Configuration and Policy Management - KRM KCL Specification","description":"This blog is a review of the content of the KCL speech at the 2023 CNCF KCD Hangzhou Conference. Activity link//community.cncf.io/events/details/cncf-kcd-hangzhou-presents-kcd-hangzhou-2023/","date":"2023-10-23T00:00:00.000Z","formattedDate":"October 23, 2023","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Meeting","permalink":"/blog/tags/meeting"}],"readingTime":14.12,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2023-10-23-cloud-native-supply-chain-krm-kcl-spec","title":"A New Paradigm for Cloud Native Configuration and Policy Management - KRM KCL Specification","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["KCL","Meeting"]},"prevItem":{"title":"KCL Biweekly Newsletter (2023 10.12 - 10.25) | FindReferences and Rename in IDE, ArtifactHub integration in KPM!","permalink":"/blog/2023-10-25-biweekly-newsletter"},"nextItem":{"title":"KCL Introduction at CNCF KCD Hangzhou 2023 Meeting","permalink":"/blog/2023-10-21-kcl-kcd-hangzhou-meeting"}},"content":"> This blog is a review of the content of the KCL speech at the 2023 CNCF KCD Hangzhou Conference. Activity link: [https://community.cncf.io/events/details/cncf-kcd-hangzhou-presents-kcd-hangzhou-2023/](https://community.cncf.io/events/details/cncf-kcd-hangzhou-presents-kcd-hangzhou-2023/)\\n\\n## Background\\n\\n> With the development of cloud-native technology, we are increasingly shifting towards cloud infrastructure. Infrastructure as code (IaC) tools like Kubernetes and Terraform have become increasingly popular for managing and deploying cloud API-based applications. However, this popularity has also brought about complexity and cognitive burden issues that have reached their peak in recent years.\\n\\n![cognitive-loading](/img/blog/2023-10-23-cloud-native-supply-chain-krm-kcl-spec/cognitive-loading-en.jpg)\\n\\nFor Kubernetes, as the most widely used container orchestration system, Gartner predicts that by 2022, over 75% of organizations globally will be running containerized applications in production. The container management market is estimated to be around 300 million dollars, projected to surpass 1 billion dollars by 2025. Additionally, Kubernetes is steadily moving out of its troubled phase towards maturity and wider adoption<sup>[1]</sup>.\\n\\nFor Terraform, as the most widely used IaC tool, as of the time of writing this article, the Terraform VS Code plugin has an installation count of around 3.2 million, roughly one-third of the installation count of the Go VS Code plugin (around 10 million), and even surpasses the installation count of many general-purpose programming languages. For example, the Rust VS Code plugin has an installation count of around 2.3 million. Furthermore, HCL is the fastest-growing programming language on GitHub in 2022, surpassing all other general-purpose and domain-specific programming languages, forming a wide developer ecosystem<sup>[2]</sup>.\\n\\nFrom this, it can be seen that Kubernetes and Terraform are becoming indispensable infrastructure projects in the cloud-native field and will continue to grow in the coming years. Although the nature of these two projects is not entirely the same, they are converging and becoming increasingly complex.\\n\\nThe increasing complexity of the cloud API represented by Kubernetes and Terraform can be attributed to several factors<sup>[3]</sup><sup>[4]</sup><sup>[5]</sup>:\\n\\n+ **Increasing capabilities**: Kubernetes and cloud APIs are constantly evolving to meet the growing demands of applications and cloud computing. To meet user demands, they continuously introduce new features and capabilities such as auto-scaling, service discovery, load balancing, and permission management. The introduction of these new features increases the complexity of the system. Although we already have various automation methods, over time, the number of different resource types, potential settings for these resource types, and the complexity of relationships between these resource types grow exponentially.\\n+ **Complex configuration management requirements**: As the scale of applications grows, configuring and managing Kubernetes and cloud APIs becomes increasingly complex. For example, managing a large number of container instances and resources, configuring complex networking and storage, implementing high availability and load balancing, and repeatedly performing configurations for different environments and topologies. These complex configuration and management requirements increase the complexity of Kubernetes and cloud APIs, often resulting in the emergence of \\"YAML engineers\\" or \\"markup language human-editing engineers\\" in the Kubernetes field.\\n\\nFor cloud APIs, we can leverage IaC tools like Terraform to obtain a large number of pre-written module configurations and providers. However, for Kubernetes, there is still a lack of lightweight client-side configuration composition and abstraction solutions. Existing solutions or specifications struggle to strike a balance between abstraction capabilities and scalability. In extreme scenarios, developers often write a lot of glue code and scripts to handle configurations, which restricts stability and efficiency.\\n\\nTherefore, we propose the KCL project and the KRM KCL specification, hoping to fill the gap in configuration languages and tools in the lightweight client-side cloud-native dynamic configuration field with more modern declarative configuration languages and tools. We aim to address the following issues:\\n\\n+ **Dimension explosion**: Most static configurations, such as Kubernetes YAML configurations in the cloud-native field, need to be configured separately for each environment. In the worst case, it may introduce difficult-to-debug errors involving cross-environment dependencies, leading to poor stability and scalability.\\n+ **Configuration drift**: There is often no standardized way to manage the dynamic configurations of applications and infrastructure for different environments. Adopting non-standard methods such as scripting and piecing together glue code can result in exponential complexity and configuration drift.\\n+ **Cognitive burden**: Kubernetes and other platform technologies that serve as building platforms excel in unifying infrastructure details at the underlying level. However, they lack higher-level software delivery abstractions, which result in a higher cognitive burden for ordinary developers and affect the software delivery experience of higher-level application developers.\\n\\n## Concepts\\n\\n### KCL\\n\\n![kcl-intro](/img/blog/2023-10-23-cloud-native-supply-chain-krm-kcl-spec/kcl-intro-en.jpg)\\n\\nKCL is a specialized configuration policy language for the cloud-native domain. It was open-sourced in June 2022 and became a CNCF Sandbox project hosted by the CNCF foundation in September 2023. KCL aims to improve the user experience of writing cloud-native configuration policies and programmability at the Kubernetes API layer. The KCL project is currently included in the CNCF foundation\'s Automation & Configuration Landscape. The \\"C\\" in KCL stands for Configuration, the \\"L\\" stands for Language, and the \\"K\\" is derived from the first letter of Kubernetes<sup>[6]</sup>.\\n\\nUnlike general-purpose programming languages, KCL is a domain-specific programming language that solves nearly infinite variations of business scenarios and complexities with a convergent set of syntax and semantics. For example, within the Kubernetes domain alone, there are thousands of resources and a fragmented Operator ecosystem in the community. KCL encapsulates the thought process and approach of writing complex configurations and policies into its language features, avoiding the security risks and side effects associated with using general-purpose languages for configuration.\\n\\nAs a configuration language, KCL provides the most important functionality for application and platform developers/SREs, which is **dynamic configuration management**. Through code abstraction, we can build an application-centric model that shields developers from the complexities of infrastructure and platform concepts and provides them with an interface that is centered around the application and easy to understand. Additionally, KCL allows platform engineers to quickly extend and define their own models, and it provides rich manageability capabilities, including out-of-the-box KCL code libraries, semantic versioning, OCI Registry, language toolchains, and automation support.\\n\\nFurthermore, KCL operates within a completely open cloud-native ecosystem and is not tightly coupled to any orchestration/engineering tools or Kubernetes controllers. In cloud-native supply chain scenarios and large-scale operational scenarios, KCL can provide API abstraction, composition, and validation capabilities for both the client and runtime. Users can choose suitable engines such as Kubectl<sup>[7]</sup>, KusionStack<sup>[8]</sup>, KubeVela<sup>[9]</sup>, or Helmfile<sup>[10]</sup> to combine with KCL and apply configurations to the cluster.\\n\\n![kcl-concept](/img/blog/2023-10-23-cloud-native-supply-chain-krm-kcl-spec/kcl-concept-en.jpg)\\n\\nIn addition, KCL itself is a modern, high-level domain-specific programming language, which is a compiled static and strongly-typed language. KCL provides developers with the core capabilities of **configuration (config)**, **model abstraction (schema)**, **logic (lambda)**, and **policies (rules)** through a record and function-oriented language design.\\n\\nKCL aims to provide programmability independent of the runtime, without providing system functionalities such as threads and IO locally. It strives to offer programming support that is stable, secure, low-noise, low side-effect, high-performance, easy to automate, and easy to manage in order to solve domain-specific problems.\\n\\n### KRM KCL Specification\\n\\n![krm-kcl](/img/blog/2023-10-23-cloud-native-supply-chain-krm-kcl-spec/krm-kcl-en.jpg)\\n\\nThe KRM KCL specification is a configuration specification based on the Kubernetes Resource Model (KRM). KRM is a generic configuration model used to describe and manage various cloud-native resources such as containers, pods, and services. KRM provides a unified way to define and manage these resources, enabling them to be portable and reusable across different environments<sup>[11]</sup>.\\n\\nAs one of the official Kubernetes specifications, the core concept of KRM is KRM functions. The input of KRM functions is a set of Kubernetes resources and the configuration of the KRM function, and the output is a set of Kubernetes resources along with the results of the function execution, such as error messages and debug information. KRM KCL is the implementation of KRM functions using KCL code and extends it with support for various code sources such as OCI Registry, Git, and HTTPS.\\n\\nIn the KRM KCL specification, the behaviors of the KCL configuration model are mainly divided into three categories:\\n\\n+ **Mutation**: Takes input KCL parameters `params` and a list of KRM resources and outputs a modified list of KRM resources.\\n+ **Validation**: Takes input KCL parameters `params` and a list of KRM resources and outputs the list of KRM resources and resource validation results.\\n+ **Abstraction**: Takes input KCL parameters `params` and outputs a list of KRM resources.\\n\\nUsing KCL, we can achieve the following capabilities programmatically:\\n\\n+ Modify resources using KCL, such as adding/modifying label tags or annotation comments based on certain conditions or injecting Sidecar container configurations in all Kubernetes Resource Model (KRM) resources containing PodTemplate.\\n+ Validate all KRM resources using KCL schema, such as constraining containers to only be launched in a root manner.\\n+ Generate KRM resources or abstract/combine different Kubernetes APIs using the abstraction model, for example, instantiating a web application configuration using the \\"web-service\\" model.\\n\\nWith the help of KCL IDE and KCL package management tools, we can write models and upload them to the OCI Registry for model reuse. We can programmatically extend the support for the KRM KCL specification, and these models can be used separately in the client or runtime based on specific scenario requirements.\\n\\n## Developer Experience\\n\\nRegarding the mentioned domain-specific problems and the related concepts of KCL, we primarily provide three aspects of support to users: language, toolchain, and cloud-native integrations.\\n\\n![workspace](/img/blog/2023-10-23-cloud-native-supply-chain-krm-kcl-spec/workspace.png)\\n\\nAlthough KCL is a domain-specific language, it is comprehensive in its capabilities. KCL provides toolchain functionalities that are equivalent to general-purpose languages, such as formatting, testing, documentation, package management, etc., to assist in writing, understanding, and validating configurations or policies. IDE plugins like VS Code and Playground reduce the cost of configuration writing and sharing. Automation of configuration management and execution is achieved through multilingual SDKs in Rust, Go, and Python.\\n\\n![ide](/img/blog/2023-10-23-cloud-native-supply-chain-krm-kcl-spec/ide.png)\\n\\nFor IDE plugins, KCL currently mainly supports VS Code, IntelliJ, and NeoVim. These plugins, based on the same KCL Language Server, offer features like autocompletion, navigation, hover, code refactoring, and formatting<sup>[12]</sup>.\\n\\n![integration](/img/blog/2023-10-23-cloud-native-supply-chain-krm-kcl-spec/integration-en.jpg)\\n\\nAs a CNCF project, KCL is integrated with many other CNCF ecosystem projects. For example, KCL provides plugins for existing CNCF ecosystem configuration management tools like Kubectl, Helm, Kustomize, kpt, helmfile, etc. At runtime, KCL offers the KCL Kubernetes Operator to meet various configuration management needs. Additionally, we provide the following integration support:\\n\\n+ **Multilingual Support**: We offer multilingual SDKs to help users work with KCL in different programming languages and integrate it into their own applications.\\n+ **Package Management Support**: We provide KCL package management tools that allow distribution and reuse of configurations and policy code through standard OCI supply chain methods like Harbor, Docker Hub, GitHub Packages, etc.\\n+ **Schema and Data Migration Support**: We support one-click migration of schema and data from other ecosystems to KCL Schema, including Go/Rust struct definitions, JsonSchema, Protobuf, OpenAPI, Terraform Provider Schema, JSON, YAML, and more.\\n\\n![artifact-hub](/img/blog/2023-10-23-cloud-native-supply-chain-krm-kcl-spec/artifact-hub.png)\\n\\n![artifact-hub-k8s](/img/blog/2023-10-23-cloud-native-supply-chain-krm-kcl-spec/artifact-hub-k8s.png)\\n\\nFurthermore, KCL supports integration with ArtifactHub. You can publish your KCL package to ArtifactHub by submitting a PR to the `kcl-lang/artifacthub` repository. This allows you to see the effects of the uploaded KCL package on the ArtifactHub page, such as the k8s package<sup>[13]</sup>.\\n\\nIn addition to that, KCL provides many out-of-the-box cloud-native models, primarily covering **Kubernetes** and **Terraform** models. Developers can easily add corresponding configuration model dependencies or view the KCL source code with just one line of KCL command.\\n\\n![performance](/img/blog/2023-10-23-cloud-native-supply-chain-krm-kcl-spec/performance.png)\\n\\nIn addition to the external work related to language, toolchain, and cloud-native integration, we have also made significant efforts to ensure stability and performance within KCL. In scenarios with large code bases or high computational requirements, KCL outperforms languages like CUE, Jsonnet, HCL, etc. Furthermore, KCL\'s progressive static typing system, immutability, schema, and validation rules ensure further stability of configurations.\\n\\n## Case Studies\\n\\n### Kubernetes\\n\\nKCL currently focuses on the cloud-native domain, particularly in Kubernetes scenarios.\\n\\n![k8s-mutation](/img/blog/2023-10-23-cloud-native-supply-chain-krm-kcl-spec/k8s-mutation-en.jpg)\\n\\nAs a small programming language within the cloud-native domain, KCL can be directly used to address simple tasks in the environment. For example, the `append-env` model can be used to inject environment variables into Kubernetes resources without the need for scripting. These models are shareable, reusable, and have been tested for code reliability, stability, and scalability.\\n\\n![k8s-validation](/img/blog/2023-10-23-cloud-native-supply-chain-krm-kcl-spec/k8s-validation-en.jpg)\\n\\nIn addition to in-place editing of Kubernetes configurations, KCL offers a variety of out-of-the-box models for Kubernetes configuration validation. These models address security and compliance issues in the cloud-native supply chain. For example, the `disallow-svc-lb` model can be used to validate whether the `Service` resource incorrectly sets the `LoadBalancer` type, and the `https-only` model can verify if the `Ingress` resource contains explicit annotations set to use https.\\n\\nCompared to other policy tools or engines, the advantage of using KCL is that a validation model can be used both on the client side and at runtime. Schema and constraint conditions can be defined simultaneously in the programming language interface, without the need for additional OpenAPI Schema or JSON Schema integration.\\n\\n![kcl-operator](/img/blog/2023-10-23-cloud-native-supply-chain-krm-kcl-spec/kcl-operator-en.jpg)\\n\\nIn addition to abstracting, editing, and verifying configurations on the client side, KCL also provides runtime support. KCL Operator provides Kubernetes cluster integration, allowing Access Webhook to generate, mutate, or validate resources based on KCL configuration when applying Kubernetes resources to the cluster. Webhook will capture creation, application, and editing operations, and `KCLRun` will execute resources on the configuration associated with each operation<sup>[14]</sup>.\\n\\nUsing the KCL Operator, resource configuration management and security verification can be automated in a lightweight manner within the Kubernetes cluster through KCL code in a few steps, without the need to repeatedly develop Webhook Server to dynamically modify and verify configurations at runtime.\\n\\n### Terraform\\n\\nAnother scenario that KCL focuses on is the ecosystem model of Terraform.\\n\\n![tf-validation](/img/blog/2023-10-23-cloud-native-supply-chain-krm-kcl-spec/tf-validation-en.jpg)\\n\\nIn the cloud-native supply chain scenario, apart from the user\'s business code, it is often necessary to verify the security of the Infrastructure as Code (IaC) code. Therefore, KCL also provides validation models related to Terraform. For example, the example shown in the image only requires a few lines of KCL code to enforce the requirement of not deleting resources during automatic scaling operations in an AWS resource group<sup>[15]</sup>.\\n\\nCompared to other policy engines or tools, KCL supports easy conversion from Terraform Provider Schema to KCL Schema, making policy writing more accessible.\\n\\n### IaC & GitOps\\n\\n![gitops](/img/blog/2023-10-23-cloud-native-supply-chain-krm-kcl-spec/gitops-en.jpg)\\n\\nWhether it is the Kubernetes model or the Terraform model, and whether it is using the standalone KCL or KRM KCL configuration format, KCL supports integration with various CI/CD and GitOps tools. KCL allows developers to define the resources required for an application in a declarative manner. By combining KCL with GitOps tools, we can achieve better Infrastructure as Code (IaC) implementation, improve deployment efficiency, and simplify application configuration management<sup>[16]</sup>.\\n\\nWith GitOps, developers and operations teams can manage the deployment of applications by separately modifying application and configuration code. The GitOps toolchain can automatically change configurations based on the automation capabilities of KCL, enabling continuous deployment and ensuring consistency. If any issues arise, the GitOps toolchain allows for quick rollbacks.\\n\\n![app-delivery](/img/blog/2023-10-23-cloud-native-supply-chain-krm-kcl-spec/app-delivery-en.jpg)\\n\\nKCL can also be used in conjunction with various CI/CD and application configuration delivery engines within an enterprise, such as KusionStack, to achieve separation of concerns, application-centric programmable model interfaces, and GitOps workflows. This simplifies the deployment and operations of scalable applications in today\'s hybrid and multi-cloud environments, enhancing release and operations efficiency as well as developer experience.\\n\\n![k8s-abstraction](/img/blog/2023-10-23-cloud-native-supply-chain-krm-kcl-spec/k8s-abstraction-en.jpg)\\n\\nFurthermore, with the Schema structure and automation API of KCL, we can integrate KCL into external systems and use CLI/API/UI forms to automate the addition, deletion, modification, and retrieval of KCL configurations. This not only enables GitOps and Infrastructure as Code (IaC) but also provides a user-friendly configuration management interface for developers. It supports changes to KCL code in the form of UI forms, improving the efficiency of configuration management and application delivery while avoiding configuration drift and other issues.\\n\\n## Summary\\n\\nThis article mainly reviews the content of the KCL presentation at the CNCF KCD community conference. It discusses the challenges encountered in the cloud-native domain, especially in the Kubernetes and Terraform ecosystems, as well as the concepts, user experiences, and practices of the KRM KCL specification.\\n\\nOf course, the problems that KCL can solve and the scenarios it can be applied to are much broader than what is covered in this article. Due to the limitations of the article length, we will continue to share the best practices of adopters in the community. We also welcome everyone to join our community for further discussions and exchanges \u2764\ufe0f.\\n\\n## More Resources\\n\\nFor more resources, please refer to:\\n\\n+ [KCL Website](https://kcl-lang.io/)\\n+ [KCL Repo](https://github.com/kcl-lang/kcl)\\n+ [KusionStack Website](https://kusionstack.io/)\\n+ [KusionStack Repo](https://github.com/KusionStack/kusion)\\n\\nSee the [community](https://github.com/kcl-lang/community) for ways to join us. \ud83d\udc4f\ud83d\udc4f\ud83d\udc4f\\n\\n## Reference\\n\\n+ [1] Forecast Analysis: Container Management (Software and Services), Worldwide: [https://www.gartner.com/en/documents/3985796](https://www.gartner.com/en/documents/3985796)\\n+ [2] The top programming languages: [https://octoverse.github.com/2022/top-programming-languages](https://octoverse.github.com/2022/top-programming-languages)\\n+ [3] Declarative Application Management in Kubernetes: [https://docs.google.com/document/d/1cLPGweVEYrVqQvBLJg6sxV-TrE5Rm2MNOBA_cxZP2WU/edit#](https://docs.google.com/document/d/1cLPGweVEYrVqQvBLJg6sxV-TrE5Rm2MNOBA_cxZP2WU/edit#)\\n+ [4] CNCF Platform Engineering Whitepaper: [https://tag-app-delivery.cncf.io/whitepapers/platforms/](https://tag-app-delivery.cncf.io/whitepapers/platforms/)\\n+ [5] Google SRE Workbook: Configuration Specifics: [https://sre.google/workbook/configuration-specifics/](https://sre.google/workbook/configuration-specifics/)\\n+ [6] KCL Website: [https://kcl-lang.io/](https://kcl-lang.io/)\\n+ [7] Kubectl: [https://kubernetes.io/docs/reference/kubectl/](https://kubernetes.io/docs/reference/kubectl/)\\n+ [8] KusionStack: [https://kusionstack.io](https://kusionstack.io)\\n+ [9] KubeVela: [https://kubevela.net](https://kubevela.net)\\n+ [10] Helmfile: [https://github.com/helmfile/helmfile](https://github.com/helmfile/helmfile)\\n+ [11] KRM KCL Specification: [https://github.com/kcl-lang/krm-kcl](https://github.com/kcl-lang/krm-kcl)\\n+ [12] KCL IDE Extension: [https://kcl-lang.io/docs/tools/Ide/](https://kcl-lang.io/docs/tools/Ide/)\\n+ [13] ArtifactHub KCL Integration: [https://artifacthub.io/](https://artifacthub.io/)\\n+ [14] KCL Operator: [https://github.com/kcl-lang/kcl-operator](https://github.com/kcl-lang/kcl-operator)\\n+ [15] Terraform KCL Policy: [https://kcl-lang.io/docs/user_docs/guides/working-with-terraform/validation](https://kcl-lang.io/docs/user_docs/guides/[]working-with-terraform/validation)\\n+ [16] GitOps using KCL: [https://kcl-lang.io/docs/user_docs/guides/gitops/gitops-quick-start](https://kcl-lang.io/docs/user_docs/guides/gitops/gitops-quick-start)"},{"id":"2023-10-21-kcl-kcd-hangzhou-meeting","metadata":{"permalink":"/blog/2023-10-21-kcl-kcd-hangzhou-meeting","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-10-21-kcl-kcd-hangzhou-meeting/index.md","source":"@site/blog/2023-10-21-kcl-kcd-hangzhou-meeting/index.md","title":"KCL Introduction at CNCF KCD Hangzhou 2023 Meeting","description":"Download PDF (Chinese)","date":"2023-10-21T00:00:00.000Z","formattedDate":"October 21, 2023","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Meeting","permalink":"/blog/tags/meeting"}],"readingTime":0.025,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2023-10-21-kcl-kcd-hangzhou-meeting","title":"KCL Introduction at CNCF KCD Hangzhou 2023 Meeting","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["KCL","Meeting"]},"prevItem":{"title":"A New Paradigm for Cloud Native Configuration and Policy Management - KRM KCL Specification","permalink":"/blog/2023-10-23-cloud-native-supply-chain-krm-kcl-spec"},"nextItem":{"title":"KCL Biweekly Newsletter (2023 09.07 - 10.11) | v0.6.0 Is Out - Enhancement on IDE Extensions and Package Management!","permalink":"/blog/2023-10-11-biweekly-newsletter"}},"content":"[Download PDF (Chinese)](https://kcl-lang.io/talks/kcl-cncf-kcd-hangzhou2023.pdf)\\n\\n![Talk Cover](/img/blog/2023-10-21-kcl-kcd-hangzhou-meeting/talk-cover.png)"},{"id":"2023-10-11-biweekly-newsletter","metadata":{"permalink":"/blog/2023-10-11-biweekly-newsletter","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-10-11-biweekly-newsletter/index.md","source":"@site/blog/2023-10-11-biweekly-newsletter/index.md","title":"KCL Biweekly Newsletter (2023 09.07 - 10.11) | v0.6.0 Is Out - Enhancement on IDE Extensions and Package Management!","description":"KCL is an open-source, constraint-based record and functional language that enhances the writing of complex configurations, including those for cloud-native scenarios. With its advanced programming language technology and practices, KCL is dedicated to promoting better modularity, scalability, and stability for configurations. It enables simpler logic writing and offers ease of automation APIs and integration with homegrown systems.","date":"2023-10-11T00:00:00.000Z","formattedDate":"October 11, 2023","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Biweekly-Newsletter","permalink":"/blog/tags/biweekly-newsletter"}],"readingTime":3.985,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2023-10-11-biweekly-newsletter","title":"KCL Biweekly Newsletter (2023 09.07 - 10.11) | v0.6.0 Is Out - Enhancement on IDE Extensions and Package Management!","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["KCL","Biweekly-Newsletter"]},"prevItem":{"title":"KCL Introduction at CNCF KCD Hangzhou 2023 Meeting","permalink":"/blog/2023-10-21-kcl-kcd-hangzhou-meeting"},"nextItem":{"title":"KCL Joining CNCF as a Sandbox Project! \ud83c\udf89","permalink":"/blog/2023-09-19-kcl-joining-cncf-sandbox"}},"content":"![](/img/biweekly-newsletter.png)\\n\\n[KCL](https://github.com/kcl-lang) is an open-source, constraint-based record and functional language that enhances the writing of complex configurations, including those for cloud-native scenarios. With its advanced programming language technology and practices, KCL is dedicated to promoting better modularity, scalability, and stability for configurations. It enables simpler logic writing and offers ease of automation APIs and integration with homegrown systems.\\n\\nThis section will update the KCL language community\'s latest developments every two weeks, including features, website updates, and the latest community news, helping everyone better understand the KCL community!\\n\\n***KCL Website: [https://kcl-lang.io](https://kcl-lang.io)***\\n\\n## Overview\\n\\nThank you to all contributors for their outstanding work over the past two weeks (09.07 - 10.11 2023). Here is an overview of the key content:\\n\\n**\ud83d\udd27 Language and Toolchain Updates**\\n\\n- **KCL v0.6.0 Release on 9/15** - Updates to the language, toolchain, and community integration. Detailed information could be found [here](/blog/2023-09-15-kcl-0.6.0-release/index.md).\\n- **KCL IDE Updates** - Supports for hover tooltips on standard library and built-in functions, and quick fixes for KCL code errors. And a plugin compatible with Intellij IDEA 2023.2 is released.\\n- **KCL Package Management Tool KPM Updates** - `kpm run` now could compile KCL files and embeded with the import tool.\\n- **KCL Documentation Tool Updates** - The docstring Examples section is added to the output documentation.\\n- **KCL Language Updates** - Optimized error message output and added suggestions for fixing some errors.\\n\\n**\ud83d\udcf0 Official Website and Use Case Updates**\\n\\n- KCL website adds v0.6.0 documentation version.\\n- More KCL model examples for containers, services, and Pod Security Policy (PSP): https://github.com/kcl-lang/krm-kcl/tree/main/examples\\n\\n## Special Thanks\\n\\nThe following are listed in no particular order:\\n\\n+ Thanks to @jakezhu9 for contributing the KCL Import tool to convert Terraform Schema to KCL Schema \ud83d\ude4c [https://github.com/kcl-lang/kcl-go/pull/152](https://github.com/kcl-lang/kcl-go/pull/152)\\n+ Thanks to @jakezhu9 for contributing the integration of the Import tool to kpm \ud83d\ude4c [https://github.com/kcl-lang/kpm/pull/194](https://github.com/kcl-lang/kpm/pull/194)\\n+ Thanks to @zwpaper for contributions to KCL documentation and Tree Sitter Grammar \ud83d\ude4c [https://github.com/kcl-lang/tree-sitter-kcl/pull/1](https://github.com/kcl-lang/tree-sitter-kcl/pull/1), etc.\\n+ Thanks to @mrgleeco, @ghpu, @steeling, @prahaladramji, @zwpaper, and others for valuable feedback and discussions while using KCL and the toolchain \ud83d\ude4c\\n\\n## Featured Updates\\n\\n### IDE Extension Updates\\n\\nIn the recent v0.6.0 release, the KCL IDE plugin has enhanced on hover tooltips for the standard library and builtin functions, along with support for quick fixes for KCL code errors. Additionally, end-to-end tests for the language server and integration tests for the konfig repository have been added to ensure the stability and iteration of the IDE plugin. In the upcoming release, a new `kcl-language-server version` subcommand has been added to display version information. Please refer to [https://kcl-lang.io/docs/user_docs/getting-started/install/#2-install-kcl-ide-extension](https://kcl-lang.io/docs/user_docs/getting-started/install/#2-install-kcl-ide-extension) for instructions on how to upgrade and install the KCL IDE extension in various IDE platforms.\\n\\n![](/img/docs/tools/Ide/vs-code/hover-built-in.png)\\n\\n#### IntelliJ Plugin\\n\\nBesides, the IntelliJ plugin is now compatible with version 2023.2+ and can be downloaded from the following link: [https://github.com/kcl-lang/intellij-kcl/releases](https://github.com/kcl-lang/intellij-kcl/releases)\\n\\n\\n### KCL Package Manager Updates\\n\\nThe kpm run command now supports compiling KCL files and has integrated an import tool. Additionally, the `--quiet` option has been added to suppress output logs.\\n\\n![](/img/docs/tools/kpm/kpm-run-file.png)\\n\\n### KCL Language Updates\\n\\nIn the upcoming release, the KCL compilation command has optimized error message output and added repair suggestions on some cases:\\n\\n![](/img/blog/2023-10-11-kcl-biweekly-newsletter/error-suggestion.png)\\n\\n### KCL Models Updates\\n\\nIn the past few weeks, we have provided more usage examples for configuring and validating containers, services, and Pod Security Policy (PSP). \\n\\n+ readonly-root-fs\\n+ allowed-image-repos\\n+ deny-all\\n+ deny-endpoint-edit-default-role\\n+ disallow-ingress-wildcard\\n+ disallow-svc-lb\\n+ disallow-svc-node-port\\n+ disallowed-image-repos\\n+ horizontal-pod-auto-scaler\\n+ psp-allow-privilege-escalation\\n+ psp-app-armor\\n+ psp-capabilities\\n+ psp-flexvolume-drivers\\n+ required-image-digests\\n+ required-probes\\n+ validate-auto-mount-service-account-token\\n+ validate-container-limits\\n+ validate-container-requests\\n+ validate-deprecated-api\\n+ k8s_manifests_containers\\n\\nYou can refer to the corresponding examples to incorporate the above configurations and validations: [https://github.com/kcl-lang/krm-kcl/tree/main/examples](https://github.com/kcl-lang/krm-kcl/tree/main/examples). Now, let\'s explain using the Kubectl KCL plugin and the disallow-svc-lb model. The purpose of disallow-svc-lb is to validate Service resources and disallow the use of LoadBalancer as the Service type. Write the following YAML file (manifests.yaml): \\n\\n  ```yaml\\n  apiVersion: krm.kcl.dev/v1alpha1\\n  kind: KCLRun\\n  metadata:\\n    name: disallow-svc-lb\\n    annotations: \\n      krm.kcl.dev/version: 0.0.1\\n      krm.kcl.dev/type: validation\\n      documentation: >-\\n        A validation that prevents the creation of Service resources of type `LoadBalancer`\\n  spec:\\n    source: oci://ghcr.io/kcl-lang/disallow-svc-lb\\n  ---\\n  apiVersion: v1\\n  kind: Service\\n  metadata:\\n    name: my-service\\n  spec:\\n    selector:\\n      app.kubernetes.io/name: MyApp\\n    ports:\\n      - name: http\\n        protocol: TCP\\n        port: 80\\n    type: LoadBalancer # The service type is incorrectly set to LoadBalancer.\\n  ```\\nUsing the Kubectl KCL tool for resource validation on the client-side, we will get the following result:\\n\\n```shell\\nkubectl kcl apply -f manifests.yaml\\n```\\n\\nThe output is\\n\\n```\\nA validation that prevents the creation of Service resources of type `LoadBalancer`, for Service: my-service\\n```\\n\\n## Resources\\n\\n\u2764\ufe0f Thanks to all KCL users and community members for their valuable feedback and suggestions in the community.\\n\\nFor more resources, please refer to\\n\\n- [KCL Website](https://kcl-lang.io/)\\n- [KusionStack Website](https://kusionstack.io/)\\n\\n- [KCL 2023 Roadmap](https://kcl-lang.io/docs/community/release-policy/roadmap)\\n- [KCL v0.7.0 Milestone](https://github.com/kcl-lang/kcl/milestone/7)\\n- [KCL Github Issues](https://github.com/kcl-lang/kcl/issues)\\n- [KCL Github Discussion](https://github.com/orgs/kcl-lang/discussions)\\n- [KCL Community](https://github.com/kcl-lang/community)"},{"id":"2023-09-19-kcl-joining-cncf-sandbox","metadata":{"permalink":"/blog/2023-09-19-kcl-joining-cncf-sandbox","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-09-19-kcl-joining-cncf-sandbox/index.md","source":"@site/blog/2023-09-19-kcl-joining-cncf-sandbox/index.md","title":"KCL Joining CNCF as a Sandbox Project! \ud83c\udf89","description":"kcl-joining-cncf-sandbox","date":"2023-09-19T00:00:00.000Z","formattedDate":"September 19, 2023","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Biweekly-Newsletter","permalink":"/blog/tags/biweekly-newsletter"}],"readingTime":9.505,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2023-09-19-kcl-joining-cncf-sandbox","title":"KCL Joining CNCF as a Sandbox Project! \ud83c\udf89","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["KCL","Biweekly-Newsletter"]},"prevItem":{"title":"KCL Biweekly Newsletter (2023 09.07 - 10.11) | v0.6.0 Is Out - Enhancement on IDE Extensions and Package Management!","permalink":"/blog/2023-10-11-biweekly-newsletter"},"nextItem":{"title":"KCL v0.6.0 Release Blog","permalink":"/blog/2023-09-15-kcl-0.6.0-release"}},"content":"![kcl-joining-cncf-sandbox](/img/blog/2023-09-19-kcl-joining-cncf-sandbox/kcl-joining-cncf-sandbox-en.png)\\n\\n**On September 20, 2023, the KCL project was approved by the TOC of the Cloud Native Computing Foundation (CNCF) and officially became a CNCF Sandbox project**.\\n\\nThis means that KCL has gained recognition from the cloud native open source community, ensuring the neutrality of the project and facilitating the participation of developers and partners in project construction. It is a significant step towards dynamic configuration management and automation capabilities for cloud native application delivery.\\n\\n\x3c!--TODO: CNCF Sandbox Review Figure--\x3e\\n\\n* *Project Link: https://github.com/kcl-lang/kcl*\\n* *Project Website: https://kcl-lang.io*\\n\\nBy joining CNCF as a sandbox project, the KCL community aims to attract more developers and users to contribute and further promote the mature application of the project in cloud native scenarios. In addition, joining CNCF provides KCL with an enhanced platform for collaboration and innovation. It offers an opportunity to engage with a diverse community of developers, organizations, and industry experts at the forefront of cloud native technology. We look forward to collaborating with other CNCF projects, contributing our technical expertise, and exploring the possibilities of integrating with more CNCF projects.\\n\\n## What is CNCF?\\n\\nCNCF, short for Cloud Native Computing Foundation, is a sub-foundation under the Linux Foundation. CNCF is dedicated to building a sustainable ecosystem for cloud native software, covering areas such as storage, computing, orchestration, scheduling, CI/CD, DevOps, service governance, and service gateways.\\n\\n*Kubernetes is one of the most representative projects of CNCF*.\\n\\n## What is CNCF Sandbox Project?\\n\\n![cncf-sandbox-logo](/img/blog/2023-09-19-kcl-joining-cncf-sandbox/cncf-sandbox-logo.png)\\n\\nThe CNCF community classifies projects into Sandbox, Incubating, and Graduated. Well-known graduated projects include Kubernetes, Prometheus, Istio, ETCD, Containerd, ArgoCD, and Helm. For a complete list of graduated and incubating projects, you can visit [https://www.cncf.io/projects/](https://www.cncf.io/projects/).\\n\\nSandbox is a category created by CNCF to provide a beneficial and neutral home for open source projects to promote collaboration and development. Projects selected for the Sandbox are recognized by the CNCF Technical Oversight Committee (TOC) and have the potential for experimentation and development. You can find the list of Sandbox projects at https://www.cncf.io/sandbox-projects/. To enter the Sandbox, at least 66% of the TOC members (all 11 people listed at https://github.com/cncf/toc#members) need to vote in favor, which means at least 8 people.\\n\\n## What is KCL?\\n\\nKCL is an open-source, constraint-based record and function language. It aims to improve the writing of complex configurations, such as cloud-native Kubernetes configurations, using mature programming language techniques and practices. KCL focuses on modularity, extensibility, and stability around configuration, aiming to create a simpler logic writing experience and build a simpler path for automation and ecosystem integration.\\n\\nKey milestones of the project include:\\n\\n+ May 2022: KCL was initiated and officially open-sourced by Ant Group.\\n+ June 2023: KCL became an official CNCF Landscape project.\\n+ September 2023: KCL was reviewed by the CNCF Application Delivery TAG and approved through TOC voting, officially becoming a CNCF Sandbox project (https://github.com/cncf/sandbox/issues/48).\\n\\n## Why do we need KCL?\\n\\nJust like recording music with a staff and storing time series data in a sequential database, we use specialized configuration and policy languages to write and manage large-scale complex configurations and policies within specific problem domains of cloud native configuration and automation. Unlike high-level general-purpose languages with hybrid writing paradigms and hybrid engineering capabilities, the core logic of specialized languages is to solve domain problems with almost infinite changes and complexity through a converged finite set of syntax and semantics, and to deposit complex configuration and strategy writing ideas and methods into language characteristics.\\n\\nIn addition, KCL hopes to fill the gap in configuration languages and tools in the field of lightweight client cloud native dynamic configuration through more modern declarative configuration languages and tools, and address the following issues:\\n\\n+ **Configuration Bloat**: Most static configurations such as Kubernetes YAML in the cloud native domain need to be configured separately for each environment; In the worst-case scenario, it may introduce difficult to debug errors involving environmental cross linking, with poor stability and scalability.\\n+ **Configuration Drift**: There is often no standard way to manage the static configuration of applications and infrastructure in different environments. Using non-standard methods such as combining scripts and glue code can lead to exponential complexity growth and configuration drift.\\n+ **Cognitive loading**: Kubernetes and others, as platform technology tools for building platforms, excel in the details of the underlying unified infrastructure, but lack higher-level abstraction for application software delivery, which has a high cognitive loading on ordinary developers and affects the software delivery experience of higher-level application developers.\\n\\nIn response to the above issues, KCL expects to provide the following capabilities:\\n\\n+ Shielding the details and complexity of infrastructure and platforms through methods such as code **abstraction**, reducing the cognitive loading on developers.\\n+ **Mutate** and **Validate** existing inventory configurations or templates to directly solve cloud generated small configuration scenarios such as Helm Chart configuration hard coding issues, but it goes far beyond that.\\n+ Improve team collaboration efficiency by **managing large-scale configuration** data across teams without side effects through language configuration.\\n\\nSpecifically, KCL can\\n\\n+ Improve the ability of **configuration semantic verification** at the code level, such as schema definition, field optional/mandatory, type, range, and other configuration check and verification capabilities.\\n+ Provide the ability to write, combine, and abstract **configuration blocks, such as structural definition, structural inheritance, constraint definition, and configuration policy merging.\\n+ Improve configuration flexibility through **modern programming languages** and **writing code**, such as conditional statements, loops, functions, package management, and other features to enhance configuration reuse capabilities.\\n+ Provide **comprehensive tool chain support**, rich IDE plugins, languages, and ecological tool chain support to reduce the threshold of getting started and improve the user experience.\\n+ By using **package management tools** and **OCI registry**, configurations can be shared, propagated, and delivered in a simpler way among different teams/roles.\\n+ Provide **high-performance** compilers to meet the requirements of large-scale configuration scenarios, such as meeting the rendering performance requirements of generating configurations of different environments and topologies based on deployment context from a baseline configuration, as well as the performance requirements of automatic configuration modification.\\n+ By enhancing its automation and integration capabilities through means such as **multilingual SDK and KCL language plugin**, it can significantly reduce the learning cost of KCL while leveraging the value of configuration and policy writing.\\n\\n![](/img/docs/user_docs/intro/kcl-overview.png)\\n\\nIn addition to the language itself, KCL also provides many additional tools such as formatting, testing, documentation, etc. to help you use, understand, and check the written configuration or strategy; Reduce the cost of configuration writing and sharing through IDE plugins such as VS Code, package management tools, and Playground; Automatically manage and execute configurations through Rust, Go, and Python multilingual SDKs.\\n\\n## What can KCL do?\\n\\n### Dynamic Configuration Management\\n\\n![standalone-kcl-form](/img/blog/2023-09-19-kcl-joining-cncf-sandbox/standalone-kcl-form.png)\\n\\nAs a configuration language, the most important feature that KCL provides to application and platform developers/SREs is dynamic configuration management. Through code abstraction, we can build an application-centric model that shields complex infrastructure and platform concepts, providing developers with a centralized and easy-to-understand interface. Additionally, KCL allows platform personnel to quickly extend and define their own models, which can be shared and reused through the OCI registry.\\n\\n![krm-kcl-form](/img/blog/2023-09-19-kcl-joining-cncf-sandbox/krm-kcl-form.png)\\n\\nFurthermore, KCL also supports direct integration with the Kubernetes Resource Model (KRM) specification. KRM KCL is a generic configuration model specification used to describe and manage various cloud native resources, such as container, pod, and service configurations and abstractions. The KRM KCL specification provides a unified way to define and manage these resources, enabling them to be portable and reusable across different environments. It operates in a fully open Kubernetes world, with minimal binding to any orchestration/engine tools or Kubernetes controllers. It allows platform personnel to extend their abstractions, configuration editing and validation logic, while providing a developer-friendly configuration management interface based on the separation of concerns.\\n\\n### GitOps\\n\\n![gitops](/img/blog/2023-09-19-kcl-joining-cncf-sandbox/gitops.png)\\n\\nWhether using standalone KCL or KRM KCL configuration forms, we support integration between KCL and various CI/CD and GitOps tools. KCL allows developers to define the resources required by applications in a declarative manner. By combining KCL with GitOps tools, we can better achieve Infrastructure as Code (IaC), improve deployment efficiency, and simplify application configuration management.\\n\\nWith GitOps, developers and operations teams can manage application deployments by separately modifying application and configuration code. The GitOps toolchain can automatically make changes to the configuration based on the automation capabilities of KCL, enabling continuous deployment and ensuring consistency. If any issues arise, the GitOps toolchain can quickly roll back the changes.\\n\\n## Integrations\\n\\n![integration](/img/blog/2023-09-19-kcl-joining-cncf-sandbox/integration.png)\\n\\nIn addition to integrating with GitOps automation tools like ArgoCD, as a CNCF project, KCL has also integrated with many other CNCF ecosystem projects. For example, it provides KCL plugins for existing CNCF ecosystem configuration management tools such as Helm, Kustomize, and kpt. It also provides a KCL Kubernetes Operator at runtime to meet different configuration management needs. Furthermore, we offer the following integration support:\\n\\n+ **Multi-language support**: We provide multi-language SDKs to help users operate KCL in different languages and integrate it into their own applications.\\n+ **Package management support**: We provide the KPM package management tool to distribute and reuse KCL configurations through Docker Hub, GitHub container registry, etc.\\n+ **Schema migration support**: We support one-click migration of schemas from other ecosystems to KCL schemas, such as Go/Rust struct definitions, JsonSchema, Protobuf, OpenAPI, Terraform Provider Schema, etc.\\n\\n## Practices\\n\\n![practice-krm-kcl](/img/blog/2023-09-19-kcl-joining-cncf-sandbox/practice-krm-kcl.png)\\n\\nFirstly, as a small language in the cloud-native field, KCL can be directly used to solve simple problems in scenarios. For example, using the KCL model to directly inject environment variables for Kubernetes resources, and using the KCL model and Helm KCL plugins to non-invasively handle the hard-coded configuration of Helm Charts instead of directly modifying the Helm Chart by forking it.\\n\\n![practice-konfig-gitops](/img/blog/2023-09-19-kcl-joining-cncf-sandbox/practice-konfig-gitops.png)\\n\\nSecondly, KCL can also be used in conjunction with various CI/CD and application configuration delivery engines such as [KusionStack](https://kusionstack.io) within enterprises to achieve separation of concerns, application-centric programmable model interfaces, and GitOps processes. This simplifies the deployment and operation of scaled applications in today\'s hybrid multi-cloud environments, improving release and operation efficiency and developer experience.\\n\\nOf course, KCL can solve more problems and scenarios than mentioned above. We will continue to share best practices from adopters in the community, and we welcome everyone to join our community for further discussions and exchanges \u2764\ufe0f. https://github.com/kcl-lang/community\\n\\n## Community\\n\\n![community](/img/blog/2023-09-19-kcl-joining-cncf-sandbox/community.png)\\n\\nIn just one year of KCL being open source, we have released many versions and built the KCL community in collaboration with contributors and maintainers from all over the world. We have also gained recognition from some adopters, such as Youzan and Huawei. By joining CNCF, our goal is to increase project visibility and drive community adoption and participation, as strong and well-known foundation organizations are crucial for advancing the development of language ecosystems.\\n\\nAdditionally, we have received recognition from companions in the open-source community from all over the world, including China, North America, Europe, and Australia. We thank all the users and community developers who have accompanied KCL on this journey, and we welcome more companions to join our community and build together \u2764\ufe0f.\\n\\n## Conclusion\\n\\nFor KCL, joining CNCF does not mean the end, but a new beginning. We will work together with our community companions to build a better KCL language, toolchain, and IDE experience! Lastly, we welcome everyone to join our community for discussions and contributions \ud83d\udc4f\ud83d\udc4f\ud83d\udc4f\\n\\n## Resources\\n\\n+ KCL Website: https://kcl-lang.io/\\n+ KusionStack Website: https://kusionstack.io/\\n+ KCL Community: https://github.com/kcl-lang/community\\n+ KCL 2023 Roadmap: https://kcl-lang.io/docs/community/release-policy/roadmap\\n+ KCL GitHub Issues: https://github.com/kcl-lang/kcl/issues\\n+ KCL GitHub Discussion: https://github.com/orgs/kcl-lang/discussions"},{"id":"2023-09-15-kcl-0.6.0-release","metadata":{"permalink":"/blog/2023-09-15-kcl-0.6.0-release","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-09-15-kcl-0.6.0-release/index.md","source":"@site/blog/2023-09-15-kcl-0.6.0-release/index.md","title":"KCL v0.6.0 Release Blog","description":"Introduction","date":"2023-09-15T00:00:00.000Z","formattedDate":"September 15, 2023","tags":[{"label":"Release Blog","permalink":"/blog/tags/release-blog"},{"label":"KCL","permalink":"/blog/tags/kcl"}],"readingTime":15.015,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2023-09-15-kcl-0.6.0-release","title":"KCL v0.6.0 Release Blog","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["Release Blog","KCL"]},"prevItem":{"title":"KCL Joining CNCF as a Sandbox Project! \ud83c\udf89","permalink":"/blog/2023-09-19-kcl-joining-cncf-sandbox"},"nextItem":{"title":"A New Paradigm for Dynamic Configuration Management - KRM KCL Specification","permalink":"/blog/2023-09-06-dcm-using-kcl"}},"content":"\x3c!-- KCL v0.6.0 \u91cd\u78c5\u53d1\u5e03 - \u9762\u5411\u4e91\u539f\u751f\u573a\u666f\u66f4\u6613\u7528\u7684\u8bed\u8a00\u3001\u5de5\u5177\u94fe\uff0c\u793e\u533a\u96c6\u6210\u548c\u6269\u5c55\u652f\u6301 --\x3e\\n\\n## Introduction\\n\\nThe KCL team is pleased to announce that KCL v0.6.0 is now available! This release has brought three key updates to everyone: **Language**, **Tools**, and **Integrations**.\\n\\n+ *Use KCL language, tools and IDE extensions with more complete features and fewer errors to improve code writing experience and efficiency.*\\n+ *Use KPM, OCI Registry and other tools to directly use and share your cloud native domain models, reducing learning and hands-on costs.*\\n+ *Use cloud-native integration extensions such as Helmfile KCL plugin and KCL Operator to simultaneously support in-place mutation and validation of Kubernetes resources on both the client and runtime, avoiding hardcoded configurations.*\\n\\nYou can visit the [KCL release page](https://github.com/kcl-lang/kcl/releases/tag/v0.6.0) or the [KCL website](https://kcl-lang.io/) to get KCL binary download link and more detailed release information.\\n\\n[KCL](https://github.com/kcl-lang/kcl) is an open-source, constraint-based record and functional language. KCL improves the writing of numerous complex configurations, such as cloud-native scenarios, through its mature programming language technology and practice. It is dedicated to building better modularity, scalability, and stability around configurations, simpler logic writing, faster automation, and great built-in or API-driven integrations.\\n\\nThis blog will introduce the content of KCL v0.6.0 and recent developments in the KCL community to readers.\\n\\n## Language\\n\\n### \ud83d\udd27 Type system enhancement\\n\\nSupport automatic type inference for KCL configuration block attributes. Prior to version 0.6.0 of KCL, the key1 and key2 attributes in the code snippet below would be inferred as type str | int. With the updated version, we have further improved the precision of type inference for configuration attributes, so key1 and key2 will have more specific and precise corresponding types.\\n\\n```python\\nconfig = {\\n    key1 = \\"value1\\"\\n    key2 = 2\\n}\\nkey1 = config.key1  # The type of key1 is str\\nkey2 = config.key2  # The type of key2 is int\\n```\\n\\nIn addition, we have optimized error messages for schema semantic checking, union type checking, and type checking errors in system library functions.\\n\\nFor more information, please refer to [here](https://github.com/kcl-lang/kcl/pull/678)\\n\\n### \ud83c\udfc4 API Update\\n\\nKCL Schema model parsing: The GetSchemaType API is used to retrieve KCL package-related information and default values for schema attributes.\\n\\n### \ud83d\udc1e Bug Fixes\\n\\n#### Fix schema required/optional attribute check in KCL\\n\\nIn previous versions of KCL, the required/optional attribute check for KCL would miss nested schema attribute checks. In version KCL v0.6.0, we have fixed such similar issues.\\n\\n```python\\nschema S:\\n    a: int\\n    b: str\\nschema L:\\n    # In previous versions, the required attribute check for attributes \'a\' and \'b\' of S in [S] and {str:S} would be missed.\\n    # This issue has been fixed in KCL v0.6.0 and later versions.\\n    ss?: [S]\\n    sss?: {str:S}\\nl = L {\\n    ss = [S {b = \\"b\\"}]\\n}\\n```\\n\\nFor more information, please see [here](https://github.com/kcl-lang/kcl/pull/672)\\n\\n## IDE & Toolchain Updates\\n\\n### IDE Updates\\n\\n#### Features\\n\\n+ Performance improvement for all IDE features\\n+ Support variable and schema attribute completion for KCL packages\\n+ Support KCL schema attribute document attribute hover\\n+ Support for quick fix of useless import statements\\n\\n![ide-quick-fix](/img/blog/2023-09-15-kcl-0.6.0-release/ide-quick-fix-en.png)\\n\\n+ Support right-click formatting of files and code fragments in VS Code.\\n\\n![ide-format](/img/blog/2023-09-15-kcl-0.6.0-release/ide-format-en.png)\\n\\n+ Support hover for built-in functions and function information in system libraries\\n\\n![ide-func-hover](/img/blog/2023-09-15-kcl-0.6.0-release/ide-func-hover.png)\\n\\n#### IDE Extension Updates\\n\\nWe have integrated the KCL language server LSP into NeoVim and Idea, enabling the completion, navigation, and hover features supported by VS Code IDE in NeoVim and IntelliJ IDEA.\\n\\n+ NeoVim KCL Extension\\n\\n![kcl.nvim](/img/docs/tools/Ide/neovim/overview.png)\\n\\n+ IntelliJ Extension\\n\\n![intellij](/img/docs/tools/Ide/intellij/overview.png)\\n\\nFor more information on downloading, installation, and features of the IDE plugins, please refer to:\\n\\n+ [https://kcl-lang.io/docs/user_docs/getting-started/install#neovim](https://kcl-lang.io/docs/user_docs/getting-started/install#neovim)\\n+ [https://kcl-lang.io/docs/user_docs/getting-started/install#intellij-idea](https://kcl-lang.io/docs/user_docs/getting-started/install#intellij-idea)\\n\\n### KCL Formatting Tool Updates\\n\\nSupport formatting of configuration blocks with incorrect indentation\\n\\n+ Before formatting\\n\\n```python\\nconfig = {\\na ={\\nx = 1\\n y =2\\n}\\nb = {\\n x = 1\\n y = 2\\n}\\n}\\n```\\n\\n+ After formatting\\n\\n```python\\nconfig = {\\n    a = {\\n        x = 1\\n        y = 2\\n    }\\n    b = {\\n        x = 1\\n        y = 2\\n    }\\n}\\n```\\n\\n### KCL Documentation Tool Updates\\n\\n+ Support for exporting Markdown documents\\n+ Support for exporting document index pages\\n+ Support for exporting documents with custom style templates\\n+ Support for HTML escaping in exported documents\\n+ Enhanced document generation to parse and render example code snippets in document comments\\n+ By tracking model updates in Github workflow and regenerating the documentation, automatic synchronization of the documentation can be achieved. Please refer to [here](https://github.com/KusionStack/catalog/pull/31/files) for more details.\\n\\n#### Generate model document from kpm package\\n\\n1. Create a kpm package and add documentation comments (using docstring) to the `Service` model. The documentation can include explanations, example code, and usage instructions to help other developers quickly get started and use it correctly.\\n\\n```\\n\\n\u279c kpm init demo\\n\\n\u279c cat > demo/server.k << EOF\\nschema Service:\\n    \\"\\"\\"\\n    Service is a kind of workload profile that describes how to run your application code. This\\n    is typically used for long-running web applications that should \\"never\\" go down, and handle\\n    short-lived latency-sensitive web requests, or events.\\n    \\n    Attributes\\n    ----------\\n    workloadType : str = \\"Deployment\\" | \\"StatefulSet\\", default is Deployment, required.\\n        workloadType represents the type of workload used by this Service. Currently, it supports several\\n        types, including Deployment and StatefulSet.\\n    image : str, default is Undefined, required.\\n        Image refers to the Docker image name to run for this container.\\n        More info: https://kubernetes.io/docs/concepts/containers/images\\n    replicas : int, default is 2, required.\\n        Number of container replicas based on this configuration that should be ran.\\n    \\n    Examples\\n    --------\\n    # Instantiate a long-running service and its image is \\"nginx:v1\\"\\n\\n    svc = Service {\\n        workloadType: \\"Deployment\\"\\n        image: \\"nginx:v1\\"\\n        replica: 2\\n    }\\n    \\"\\"\\"\\n    workloadType: \\"Deployment\\" | \\"StatefulSet\\"\\n    image: str\\n    replica: int\\nEOF\\n\\n```\\n\\n2. Generate the package documentation in Markdown format\\n\\nThe following command will output the demo package documentation to the `doc/` directory in the current working directory:\\n\\n```shell\\nkcl-go doc generate --file-path demo\\n```\\n\\n![docgen](/img/blog/2023-09-15-kcl-0.6.0-release/docgen.png)\\n\\n> For more usage details, please use `kcl-go doc generate -h` to refer to the help information.\\n\\n#### Automatic synchronization of documents through CI pipelines\\n\\nImplement automatic documentation synchronization through a pipeline By tracking model updates in a Github workflow and regenerating the documentation, automatic synchronization of the documentation can be achieved. You can refer to the approach in the `Kusionstack/catalog` repo to generate the documentation and automatically submit change PRs to the documentation repository.\\n\\nBy tracking model updates in Github workflow and regenerating documents, automatic document synchronization can be achieved. Can refer to the approach in the [Kusionstack/catalog](https://github.com/KusionStack/catalog/pull/31/files) repo is to generate documents and automatically submit change PRs to the document repository.\\n\\n### KCL Import Tool Updates\\n\\nThe KCL Import Tool now adds support for converting Terraform Provider Schema to KCL Schema based on Protobuf, JsonSchema OpenAPI models, and Go Structures, such as the following Terraform Provider Json (obtained through the command `terraform providers schema -json > provider.json` , For more details, please refer to [https://developer.hashicorp.com/terraform/cli/commands/providers/schema](https://developer.hashicorp.com/terraform/cli/commands/providers/schema))\\n\\n```json\\n{\\n    \\"format_version\\": \\"0.2\\",\\n    \\"provider_schemas\\": {\\n        \\"registry.terraform.io/aliyun/alicloud\\": {\\n            \\"provider\\": {\\n                \\"version\\": 0,\\n                \\"block\\": {\\n                    \\"attributes\\": {},\\n                    \\"block_types\\": {},\\n                    \\"description_kind\\": \\"plain\\"\\n                }\\n            },\\n            \\"resource_schemas\\": {\\n                \\"alicloud_db_instance\\": {\\n                    \\"version\\": 0,\\n                    \\"block\\": {\\n                        \\"attributes\\": {\\n                            \\"db_instance_type\\": {\\n                                \\"type\\": \\"string\\",\\n                                \\"description_kind\\": \\"plain\\",\\n                                \\"computed\\": true\\n                            },\\n                            \\"engine\\": {\\n                                \\"type\\": \\"string\\",\\n                                \\"description_kind\\": \\"plain\\",\\n                                \\"required\\": true\\n                            },\\n                            \\"security_group_ids\\": {\\n                                \\"type\\": [\\n                                    \\"set\\",\\n                                    \\"string\\"\\n                                ],\\n                                \\"description_kind\\": \\"plain\\",\\n                                \\"optional\\": true,\\n                                \\"computed\\": true\\n                            },\\n                            \\"security_ips\\": {\\n                                \\"type\\": [\\n                                    \\"set\\",\\n                                    \\"string\\"\\n                                ],\\n                                \\"description_kind\\": \\"plain\\",\\n                                \\"optional\\": true,\\n                                \\"computed\\": true\\n                            },\\n                            \\"tags\\": {\\n                                \\"type\\": [\\n                                    \\"map\\",\\n                                    \\"string\\"\\n                                ],\\n                                \\"description_kind\\": \\"plain\\",\\n                                \\"optional\\": true\\n                            }\\n                        },\\n                        \\"block_types\\": {},\\n                        \\"description_kind\\": \\"plain\\"\\n                    }\\n                },\\n                \\"alicloud_config_rule\\": {\\n                    \\"version\\": 0,\\n                    \\"block\\": {\\n                        \\"attributes\\": {\\n                            \\"compliance\\": {\\n                                \\"type\\": [\\n                                    \\"list\\",\\n                                    [\\n                                        \\"object\\",\\n                                        {\\n                                            \\"compliance_type\\": \\"string\\",\\n                                            \\"count\\": \\"number\\"\\n                                        }\\n                                    ]\\n                                ],\\n                                \\"description_kind\\": \\"plain\\",\\n                                \\"computed\\": true\\n                            },\\n                            \\"resource_types_scope\\": {\\n                                \\"type\\": [\\n                                    \\"list\\",\\n                                    \\"string\\"\\n                                ],\\n                                \\"description_kind\\": \\"plain\\",\\n                                \\"optional\\": true,\\n                                \\"computed\\": true\\n                            }\\n                        }\\n                    }\\n                }\\n            },\\n            \\"data_source_schemas\\": {}\\n        }\\n    }\\n}\\n```\\n\\nThen the tool can output the following KCL code\\n\\n```python\\n\\"\\"\\"\\nThis file was generated by the KCL auto-gen tool. DO NOT EDIT.\\nEditing this file might prove futile when you re-run the KCL auto-gen generate command.\\n\\"\\"\\"\\n\\nschema AlicloudConfigRule:\\n    \\"\\"\\"\\n    AlicloudConfigRule\\n\\n    Attributes\\n    ----------\\n    compliance: [ComplianceObject], optional\\n    resource_types_scope: [str], optional\\n    \\"\\"\\"\\n\\n    compliance?: [ComplianceObject]\\n    resource_types_scope?: [str]\\n\\nschema ComplianceObject:\\n    \\"\\"\\"\\n    ComplianceObject\\n\\n    Attributes\\n    ----------\\n    compliance_type: str, optional\\n    count: int, optional\\n    \\"\\"\\"\\n\\n    compliance_type?: str\\n    count?: int\\n\\nschema AlicloudDbInstance:\\n    \\"\\"\\"\\n    AlicloudDbInstance\\n\\n    Attributes\\n    ----------\\n    db_instance_type: str, optional\\n    engine: str, required\\n    security_group_ids: [str], optional\\n    security_ips: [str], optional\\n    tags: {str:str}, optional\\n    \\"\\"\\"\\n\\n    db_instance_type?: str\\n    engine: str\\n    security_group_ids?: [str]\\n    security_ips?: [str]\\n    tags?: {str:str}\\n\\n    check:\\n        isunique(security_group_ids)\\n        isunique(security_ips)\\n```\\n\\n### Package Manage Tool Updates\\n\\n#### kpm pull supports pulling packages by package name\\n\\nkpm supports pulling the corresponding package by using the `kpm pull <package_name>:<package_version>` command.\\n\\nTaking the `k8s` package as an example, you can directly download the package to your local machine using the following commands:\\n\\n```shell\\nkpm pull k8s\\n```\\n\\nor\\n\\n```shell\\nkpm pull k8s:1.27\\n```\\n\\nThe package downloaded with kpm pull will be saved in the directory `<execution_directory>/<oci_registry>/<package_name>`. For example, if you use the default kpm registry and run the kpm pull k8s command, you can find the downloaded content in the directory `<execution_directory>/ghcr.io/kcl-lang/k8s`.\\n\\n```\\n$ tree ghcr.io/kcl-lang/k8s -L 1\\n\\nghcr.io/kcl-lang/k8s\\n\u251c\u2500\u2500 api\\n\u251c\u2500\u2500 apiextensions_apiserver\\n\u251c\u2500\u2500 apimachinery\\n\u251c\u2500\u2500 kcl.mod\\n\u251c\u2500\u2500 kcl.mod.lock\\n\u251c\u2500\u2500 kube_aggregator\\n\u2514\u2500\u2500 vendor\\n\\n6 directories, 2 files\\n```\\n\\n#### kpm supports adding local paths as dependencies\\n\\n\\"Different projects have different KCL packages, and there are dependencies between them. However, they are stored in different directories. I hope that these packages stored in different directories can be managed together, rather than having to put them together for them to compile.\\" If you also have this need, you can try this feature. The kpm add command currently supports adding local paths as dependencies to a KCL package. You just need to run the command `kpm add <local_package_path>`, and your local package will be added as a third-party library dependency to the current package.\\n\\n```shell\\nkpm pull k8s\\n```\\n\\nAfter completion, you can find the downloaded k8s package in the directory `\\"the_directory_where_you_executed_the_command/ghcr.io/kcl-lang/k8s\\"`.\\nCreate a new KCL package using the `kpm init mynginx` command.\\n\\n```shell\\nkpm init mynginx\\n```\\n\\nThen, navigate into this package.\\n\\n```shell\\ncd mynginx\\n```\\n\\nInside this package, you can use the kpm add command to add the k8s package you downloaded locally as a third-party library dependency to `mynginx`.\\n\\n```shell\\nkpm add ../ghcr.io/kcl-lang/k8s/\\n```\\n\\nNext, add the following content to `main.k`.\\n\\n```shell\\nimport k8s.api.core.v1 as k8core\\n\\nk8core.Pod {\\n    metadata.name = \\"web-app\\"\\n    spec.containers = [{\\n        name = \\"main-container\\"\\n        image = \\"nginx\\"\\n        ports = [{containerPort: 80}]\\n    }]\\n}\\n```\\n\\nNormal compilation can be performed through the `kpm run` command.\\n\\n```shell\\nkpm run\\n```\\n\\n#### kpm adds checking for existing package tags\\n\\nWe have added a check for duplicate tags in the `kpm push` command. In order to avoid situations where packages with the same tag have different content, we have added restrictions on the push function in the `kpm`. If the version of the kcl package you push already exists, you will not be able to push the current kcl package. You will receive the following information:\\n\\n```shell\\nkpm: package \'my_package\' will be pushed.\\nkpm: package version \'0.1.0\' already exists\\n```\\n\\nModifying the content of a package that has already been pushed to the registry without changing the tag carries a high risk, as the package may already be in use by others. Therefore, if you need to push your package, we recommend:\\n\\n+ Change your tag and follow semantic versioning conventions.\\n+ If you must modify the content of a package without changing the tag, you will need to delete the existing tag from the registry.\\n\\n## Integrations\\n\\n### Helmfile KCL Plugin\\n\\nHelmfile is a declarative specification and tool for deploying Helm Charts. With the Helmfile KCL plugin, you can:\\n\\n+ Edit or verify Helm Chart through non-invasive hook methods, separating the data and logic parts of Kubernetes configuration management\\n  + Modify resource labels/annotations, inject sidecar container configuration\\n  + Use KCL schema to validate resources\\n  + Define your own abstract application models\\n+ Maintain multiple environment and tenant configurations elegantly, rather than simply copying and pasting.\\n\\nHere is a detailed explanation using a simple example. With the Helmfile KCL plugin, you do not need to install any components related to KCL. You only need the latest version of the Helmfile tool on your local device.\\n\\nWe can write a `helmfile.yaml` file as follows:\\n\\n```yaml\\nrepositories:\\n-\xa0name:\xa0prometheus-community\\n\xa0\xa0url:\xa0https://prometheus-community.github.io/helm-charts\\n\\nreleases:\\n-\xa0name:\xa0prom-norbac-ubuntu\\n\xa0\xa0namespace:\xa0prometheus\\n\xa0\xa0chart:\xa0prometheus-community/prometheus\\n\xa0\xa0set:\\n\xa0\xa0-\xa0name:\xa0rbac.create\\n\xa0\xa0\xa0\xa0value:\xa0false\\n\xa0\xa0transformers:\\n\xa0\xa0#\xa0Use\xa0KCL\xa0Plugin\xa0to\xa0mutate\xa0or\xa0validate\xa0Kubernetes\xa0manifests.\\n\xa0\xa0-\xa0apiVersion:\xa0krm.kcl.dev/v1alpha1\\n\xa0\xa0\xa0\xa0kind:\xa0KCLRun\\n\xa0\xa0\xa0\xa0metadata:\\n\xa0\xa0\xa0\xa0\xa0\xa0name:\xa0\\"set-annotation\\"\\n\xa0\xa0\xa0\xa0\xa0\xa0annotations:\\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0config.kubernetes.io/function:\xa0|\\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0container:\\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0image:\xa0docker.io/kcllang/kustomize-kcl:v0.2.0\\n\xa0\xa0\xa0\xa0spec:\\n\xa0\xa0\xa0\xa0\xa0\xa0source:\xa0|\\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0[resource\xa0|\xa0{if\xa0resource.kind\xa0==\xa0\\"Deployment\\":\xa0metadata.annotations:\xa0{\\"managed-by\\"\xa0=\xa0\\"helmfile-kcl\\"}}\xa0for\xa0resource\xa0in\xa0option(\\"resource_list\\").items]\\n```\\n\\nIn the above file, we referenced the Prometheus Helm Chart and injected the `managed-by=\\"helmfile-kcl\\"` label into all deployment resources of Prometheus with just one line of KCL code. The following command can be used to deploy the above configuration to the Kubernetes cluster:\\n\\n```shell\\nhelmfile\xa0apply\\n```\\n\\nFor more use cases, please refer to [https://github.com/kcl-lang/krm-kcl](https://github.com/kcl-lang/krm-kcl)\\n\\n### KCL Operator\\n\\nKCL Operator provides cluster integration, allowing you to use Access Webhook to generate, mutate, or validate resources based on KCL configuration when apply resources to the cluster. Webhook will capture creation, application, and editing operations, and execute [KCLRun](https://github.com/kcl-lang/krm-kcl) on the configuration associated with each operation, and the KCL programming language can be used to\\n\\n+ Add labels or annotations based on a condition.\\n+ Inject a sidecar container in all KRM resources that contain a `PodTemplate`.\\n+ Validating all KRM resources using KCL Schema, such as constraints on starting containers only in a root mode.\\n+ Generating KRM resources using an abstract model or combining and using different KRM APIs. \\n\\nHere is a simple resource annotation mutation example to introduce the usage of the KCL operator.\\n\\n#### 0. Prerequisites\\n\\nPrepare a Kubernetes cluster like `k3d` the kubectl tool.\\n\\n#### 1. Install KCL Operator\\n\\n```shell\\nkubectl apply -f https://raw.githubusercontent.com/kcl-lang/kcl-operator/main/config/all.yaml\\n```\\n\\nUse the following command to observe and wait for the pod status to be `Running`.\\n\\n```shell\\nkubectl get po\\n```\\n\\n#### 2. Deploy KCL Annotation Setting Model\\n\\n```shell\\nkubectl apply -f- << EOF\\napiVersion: krm.kcl.dev/v1alpha1\\nkind: KCLRun\\nmetadata:\\n  name: set-annotation\\nspec:\\n  # Set dynamic parameters required for the annotation modification model, here we can add the labels we want to modify/add\\n  params:\\n    annotations:\\n      managed-by: kcl-operator\\n  # Reference the annotation modification model on OCI\\n  source: oci://ghcr.io/kcl-lang/set-annotation\\nEOF\\n```\\n\\n#### 3. Deploy a Pod to Verify the Model Result\\n\\nExecute the following command to deploy a `Pod` resource:\\n\\n```shell\\nkubectl apply -f- << EOF\\napiVersion: v1\\nkind: Pod\\nmetadata:\\n  name: nginx\\n  annotations:\\n    app: nginx\\nspec:\\n  containers:\\n  - name: nginx\\n    image: nginx:1.14.2\\n    ports:\\n    - containerPort: 80\\nEOF\\nkubectl get po nginx -o yaml | grep kcl-operator\\n```\\n\\nWe can see the following output:\\n\\n```shell\\n    managed-by: kcl-operator\\n```\\n\\nWe can see that the Nginx Pod automatically added the annotation `managed-by=kcl-operator`.\\n\\nIn addition, besides referencing an existing model for the source field of the `KCLRun` resource, we can directly set KCL code for the source field to achieve the same effect. For example:\\n\\n```yaml\\napiVersion: krm.kcl.dev/v1alpha1\\nkind: KCLRun\\nmetadata:\\n  name: set-annotation\\nspec:\\n  params:\\n    annotations:\\n      managed-by: kcl-operator\\n  # Resource modification can be achieved with just one line of KCL code\\n  source: |\\n    items = [item | {metadata.annotations: option(\\"params\\").annotations} for item in option(\\"items\\")]\\n```\\n\\n![registry](/img/blog/2023-09-15-kcl-0.6.0-release/registry.png)\\n\\nWe have provided more than 30 built-in models, and you can find more code examples in the following link: [https://github.com/kcl-lang/krm-kcl/tree/main/examples](https://github.com/kcl-lang/krm-kcl/tree/main/examples)\\n\\nFor example\\n\\n+ Use the `web-service` model to directly instantiate the Kubernetes resources required for a web application\\n+ Add annotations to existing k8s resources using the `set-annotation` model\\n+ Use the `https-only` model to verify that your `Ingress` configuration can only be set to https, otherwise an error will be reported.\\n\\n### Vault Integration\\n\\nIn just three steps, we can use `Vault` to store and manage sensitive information and use it in KCL.\\n\\nFirstly, we install and use Vault to store `foo` and `bar` information.\\n\\n```shell\\nvault kv put secret/foo foo=foo\\nvault kv put secret/bar bar=bar\\n```\\n\\nThen write the following KCL code (main.k)\\n\\n```python\\napiVersion = \\"apps/v1\\"\\nkind = \\"Deployment\\"\\nmetadata = {\\n    name = \\"nginx\\"\\n    labels.app = \\"nginx\\"\\n    annotations: {\\n        \\"secret-store\\": \\"vault\\"\\n        # Valid format:\\n        #  \\"ref+vault://PATH/TO/KV_BACKEND#/KEY\\"\\n        \\"foo\\": \\"ref+vault://secret/foo#/foo\\"\\n        \\"bar\\": \\"ref+vault://secret/bar#/bar\\"\\n    }\\n}\\nspec = {\\n    replicas = 3\\n    selector.matchLabels = metadata.labels\\n    template.metadata.labels = metadata.labels\\n    template.spec.containers = [\\n        {\\n            name = metadata.name\\n            image = \\"${metadata.name}:1.14.2\\"\\n            ports = [{ containerPort = 80 }]\\n        }\\n    ]\\n}\\n```\\n\\nFinally, the decrypted configuration can be obtained through the `vals` command-line tool\\n\\n```shell\\nkcl main.k | vals eval -f -\\n```\\n\\nFor more details and use cases, please refer to [here](https://kcl-lang.io/docs/user_docs/guides/secret-management/vault)\\n\\n### GitLab CI Integration\\n\\nUsing KCL, we can not only use Github Action as CI for application publishing through GitOps, but also provide GitLab CI integration in this version. Please refer to: *[https://kcl-lang.io/docs/user_docs/guides/ci-integration/gitlab-ci](https://kcl-lang.io/docs/user_docs/guides/ci-integration/gitlab-ci)*\\n\\n## Other Updates and Bug Fixes\\n\\nSee [here](https://github.com/kcl-lang/kcl/compare/v0.5.0...v0.6.0) for more updates and bug fixes.\\n\\n## Documents\\n\\nThe versioning semantic option is added to the [KCL website](https://kcl-lang.io/). Currently, v0.4.x, v0.5.x and v0.6.0 versions are supported.\\n\\n## Community\\n\\n+ Thank @jakezhu9 for his contribution to converting KCL Import tools, including Terraform Provider Schema, JsonSchema, JSON, YAML, and other configuration formats/data to KCL schema/configurations \ud83d\ude4c\\n+ Thank @xxmao123 for her contribution to connecting KCL LSP language server to the Idea IDE extension \ud83d\ude4c\\n+ Thank @starkers for his contribution to the KCL NeoVim extension \ud83d\ude4c\\n+ Thank @starkers for adding KCL installation support to mason.nvim registry \ud83d\ude4c\\n+ Thank @Ekko for his contribution to the integration of KCL cloud native tools and KCL Operator \ud83d\ude4c\\n+ Thank @prahalaramji for the upgrade, update, and contribution to the KCL Homebrew installation script \ud83d\ude4c\\n+ Thank @yyxhero for providing assistance and support in the Helmfile KCL plugin support \ud83d\ude4c\\n+ Thank @nkabir, @mihaigalos, @prahalaramji, @yamin-oanda, @dhhopen, @magick93, @MirKml, @kolloch, @steeling, and others for their valuable feedback and discussion during the past two months of using KCL. \ud83d\ude4c\\n\\n## Additional Resources\\n\\nFor more information, see [KCL FAQ](https://kcl-lang.io/docs/user_docs/support/).\\n\\n## Resources\\n\\nThank all KCL users for their valuable feedback and suggestions during this version release. For more resources, please refer to:\\n\\n+ [KCL Website](https://kcl-lang.io/)\\n+ [Kusion Website](https://kusionstack.io/)\\n+ [KCL Repo](https://github.com/kcl-lang/kcl)\\n+ [Kusion Repo](https://github.com/KusionStack/kusion)\\n\\nSee the [community](https://github.com/kcl-lang/community) for ways to join us. \ud83d\udc4f\ud83d\udc4f\ud83d\udc4f"},{"id":"2023-09-06-dcm-using-kcl","metadata":{"permalink":"/blog/2023-09-06-dcm-using-kcl","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-09-08-dcm-using-kcl/index.md","source":"@site/blog/2023-09-08-dcm-using-kcl/index.md","title":"A New Paradigm for Dynamic Configuration Management - KRM KCL Specification","description":"Introduction","date":"2023-09-08T00:00:00.000Z","formattedDate":"September 8, 2023","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Kubernetes Resource Model","permalink":"/blog/tags/kubernetes-resource-model"},{"label":"Dynamic Configuration Management","permalink":"/blog/tags/dynamic-configuration-management"}],"readingTime":13.29,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2023-09-06-dcm-using-kcl","title":"A New Paradigm for Dynamic Configuration Management - KRM KCL Specification","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["KCL","Kubernetes Resource Model","Dynamic Configuration Management"]},"prevItem":{"title":"KCL v0.6.0 Release Blog","permalink":"/blog/2023-09-15-kcl-0.6.0-release"},"nextItem":{"title":"KCL Biweekly Newsletter (2023 08.24 - 09.06) | Kubernetes Operator, IDE Extensions and v0.5.6 are out!","permalink":"/blog/2023-09-06-biweekly-newsletter"}},"content":"## Introduction\\n\\n> With the development of cloud-native technologies, we are increasingly shifting towards cloud infrastructure. Tools such as Kubernetes and Terraform have become increasingly popular for managing and deploying applications based on cloud APIs. However, along with this popularity, the complexity and cognitive burden associated with these tools have reached a peak in recent years.\\n\\n![cognitive-loading](/img/blog/2023-09-08-dcm-using-kcl/cognitive-loading.png)\\n\\nThe increasing complexity of Kubernetes and cloud APIs can be attributed to several factors:\\n\\n+ **Growing functionality and capabilities**: Kubernetes and cloud APIs continuously evolve to meet the growing demands of applications and the development of cloud computing. To fulfill user requirements, new functionalities and capabilities such as auto-scaling, service discovery, load balancing, and permission management are constantly introduced. The introduction of these new features adds to the complexity of the system. Despite the availability of various automation methods, over time, the exponential growth in the number of different resource types, potential settings for these resource types, and the complex relationships between them pose challenges.\\n+ **Complex configuration and management requirements**: As applications scale, configuring and managing Kubernetes and cloud APIs becomes increasingly complex. This includes managing a large number of container instances and resources, configuring intricate networking and storage setups, ensuring high availability and load balancing, and repetitive configurations for different environments and topologies. These complex configuration and management requirements contribute to the overall complexity of Kubernetes and cloud APIs, sometimes leading to the emergence of \\"YAML engineers\\" as a joking reference.\\n\\nDespite the increasing complexity of Kubernetes and cloud APIs, they provide powerful functionalities and flexibility to help organizations effectively manage and scale their applications. By utilizing appropriate tools, engineering practices, and methods, this complexity can be alleviated, enabling efficient utilization of these technologies to meet business needs. Dynamic configuration management techniques are one of the approaches that can help address the complexity of Kubernetes and cloud APIs to a certain extent.\\n\\n## What is Dynamic Configuration Management\\n\\nWe follow the [original definition of Dynamic Configuration Management (DCM)](https://humanitec.com/blog/what-is-dynamic-configuration-management) by its creator Chris Stephenson and extend it to a certain extent.\\n\\n> Dynamic Configuration Management (DCM) is an approach to constructing the configuration of computational workloads. Developers create workload specifications that describe everything necessary for the workload to run successfully. These specifications are used to dynamically generate configurations for deploying the workload in specific environments. With DCM, developers do not need to define or maintain environment-specific configurations for their workloads.\\n\\nDynamic Configuration Management means that developers describe the relationship between their workloads and resources in an **abstract** and **environment-agnostic** manner. They describe this relationship in a format called a workload specification or application-centric specification. The specification is generic and works across environments, which means it doesn\'t provide enough information to configure the workloads and resources themselves. To obtain executable configurations, we need to apply the specification to configuration baselines (for application and infrastructure configurations) and generate them based on the deployment context. For developers, Dynamic Configuration Management requires providing an application-centric configuration interface that they can understand. For platform engineers, Dynamic Configuration Management can help define how to handle configuration resources and workload specifications, leading to improved consistency and compliance within the organization. It also makes it easier to provide a self-service Internal Developer Platform (IDP).\\n\\nIn contrast to dynamic configuration management, static configuration management brings about a series of issues:\\n\\n+ **Configuration Bloat**: Most static configurations require separate configurations for each environment, and in the worst case, it can introduce difficult-to-debug errors involving cross-linking between environments, leading to poor stability and scalability.\\n+ **Configuration Drift**: Managing application and infrastructure configurations for different environments with static management approaches often lacks standardized methods for handling dynamic variations in configurations across environments. Employing non-standardized approaches can result in exponential complexity and lead to configuration drift.\\n\\n## Why Do We Need a New Paradigm\\n\\nJust as music is recorded on musical sheets and time-series data is stored in time-series databases, a set of configuration and policy languages is used for writing and managing scalable and complex configurations and policies in the specific problem domain of platform engineering. Unlike high-level general-purpose languages with mixed paradigms and mixed engineering capabilities, these domain-specific languages are built upon a converged, finite syntax and semantic set to tackle the near-infinite variations and complexities of the domain\'s problems, consolidating the mindset and approach to writing complex configurations and policies into the language\'s features.\\n\\nFor cloud APIs, we can leverage Infrastructure as Code (IaC) tools like Terraform to obtain a vast library of pre-written module configurations. However, when it comes to Kubernetes, there is still a lack of lightweight client-side configuration composition and abstraction solutions. Existing solutions or specifications struggle to strike a balance between abstraction capabilities and scalability. In extreme scenarios, developers often resort to writing glue code and scripts to handle configuration processing logic, which hinders stability and efficiency. For instance, although tools like Helm Chart provide template programming, the programming experience and efficiency are subpar. Additionally, when users need to dynamically adjust dependencies on `values.yaml` parameters in Helm Charts or encounter upstream Helm Charts that don\'t support the required parameter settings, they often resort to forking and maintaining the upstream Helm Charts in an intrusive manner or supplementing with tools like Kustomize, incurring additional maintenance costs and complexities.\\n\\nTherefore, we contemplate the need for a unified specification that can simultaneously support configuration language capabilities and, with minimal side effects, fulfill the requirements of stability, scalability, and efficiency in the context of scalable configuration scenarios. This specification should also address the problems inherent in static configuration management.\\n\\n+ **Abstraction and Composition Capabilities**: By providing a programmable schema, the platform personnel can shield the underlying infrastructure details and platform, while offering developers a better and more stable API abstraction.\\n+ **Stability**: By providing stable features out-of-the-box, such as rule writing and static typing, the specification enables risk mitigation and early error detection in version control systems (VCS), allowing for auditing, traceability, and rollback, and facilitating automation.\\n+ **Scalability**: Similar to the application software supply chain, infrastructure configuration should be treated as part of the software supply chain. Users can distribute and reuse configurations in a standardized manner, easily accessing commonly used configurations in the open-source world. For internal platforms, we can easily write and extend configuration code.\\n+ **High performance**: Since dynamic configuration management advocates generating configurations for different environments and topologies based on a baseline configuration and deployment context, there is a high demand for the rendering performance of the configuration code itself. Developers typically do not want to spend several minutes waiting for the actual configuration output, as it would hinder software iteration and upgrade efficiency.\\n\\n## KRM KCL Specification\\n\\nThe [KRM KCL specification](https://github.com/kcl-lang/krm-kcl) is a configuration specification based on the Kubernetes Resource Model (KRM). KRM is a universal configuration model used to describe and manage various cloud-native resources such as containers, pods, and services. It provides a unified way to define and manage these resources, enabling portability and reuse across different environments. It exists within the open Kubernetes ecosystem, decoupled from any specific orchestration/engine tools or Kubernetes controllers. It allows platform personnel to extend their abstractions, configuration editing, and validation logic, while also enabling direct reuse of existing model abstractions from the community, such as the Open Application Model (OAM), which also complies with the KRM specification.\\n\\nThe [KCL programming language](https://github.com/kcl-lang) is a core component of the KRM KCL specification. KCL is a declarative configuration language that allows users to describe the configuration requirements of their applications and associate them with underlying infrastructure. KCL has a rich syntax and semantics that can flexibly describe various configuration needs, such as environment variables, resource limits, dependencies, and more. KCL aims to hide the details of infrastructure and platforms by defining API abstractions, reducing the burden, and managing large-scale configurations across teams without side effects. It provides capabilities to write, combine, and abstract configuration blocks, such as structural definitions, constraints, and logic. In platform engineering practices, KCL is not just a key-value language but a domain-specific language tailored for the platform engineering field.\\n\\nAnother important feature of the KRM KCL specification is its support for dynamic configuration management. Traditional configuration management tools often rely on static configuration files that require manual modifications and deployments. The KRM KCL specification naturally provides a way to automatically modify configurations, which can be used standalone on the client-side or integrated with Kubernetes through the [KCL Operator](https://github.com/kcl-lang/kcl-operator) to achieve runtime configuration modifications without the need for developing Kubernetes webhooks or writing extensive configuration processing logic.\\n\\nIn addition to dynamic configuration management, the KRM KCL specification offers several other advantages. Firstly, it is based on Kubernetes and seamlessly integrates with the existing Kubernetes ecosystem. Secondly, the KRM KCL specification provides a rich set of tools and libraries that make it easy for developers to create, test, and maintain configurations. Lastly, the KRM KCL specification adopts open standards, allowing for interoperability with other configuration management tools such as Kubectl, Helm, Kustomize, and more. It possesses the following characteristics:\\n\\n+ **Declarative**: Configurations are abstracted and organized in code form, allowing users to view and edit them using editors or IDEs. The code clearly describes various aspects of resources, services, networks, and more.\\n+ **Final-state oriented**: It is abstracted and implementation-agnostic, with highly abstracted and domain-specific underlying capabilities. The concrete business logic is written by users in a declarative manner. Users can avoid manual operations and non-uniform patterns introduced by private scripts through a unified description code and GitOps workflow, reducing security risks.\\n+ **Stability**: Any modification to configuration code can potentially result in unexpected outcomes, exceptions, or failures. By combining version control and the stability features of the language itself, different versions of configuration code can be switched as needed through Git, with audibility, to meet the needs of development, testing, and production stages. For example, rolling back to a verified version in case of anomalies. Code-based version control effectively prevents configuration drift.\\n+ **Reusable and extensible**: Configuration code often exhibits the characteristic of \\"write once, reuse multiple times\\". When combined with dynamically parameterized configuration code, the reuse of configurations in different environments and for different users becomes simple. Through integration with standard software supply chains such as OCI, configuration code is treated equally with business code, better achieving Infrastructure as Code (IaC).\\n\\nIn summary, the KRM KCL specification presents a new paradigm for dynamic configuration management. Built upon KRM and KCL, it offers a more efficient and reliable configuration solution for modern software development. With its dynamic configuration management capabilities, flexible syntax and semantics, and integration with Kubernetes, the KRM KCL specification provides developers with an enhanced configuration management experience in cloud-native application development and microservices architectures.\\n\\n## How to\\n\\n![krm-kcl-form](/img/blog/2023-09-08-dcm-using-kcl/krm-kcl-form.png)\\n\\nIn the KRM KCL specification, we categorize the behaviors of the KCL configuration model into three main types:\\n\\n+ **Mutation**: Takes input KCL parameters params and a KRM list, and outputs a modified KRM list.\\n+ **Validation**: Takes input KCL parameters params and a KRM list, and outputs a KRM list and resource validation results.\\n+ **Abstraction**: Takes input KCL parameters params and outputs a KRM list.\\n\\nUsing KCL, we can programmatically achieve the following capabilities:\\n\\n+ Modify resources using KCL, such as adding/modifying label tags or annotation comments based on certain conditions, or injecting sidecar container configurations into all Kubernetes Resource Model (KRM) resources that contain PodTemplates.\\n+ Validate all KRM resources using KCL schemas, such as constraints for launching containers only in a root manner.\\n+ Generate KRM resources using an abstraction model or combine and use different KRM APIs.\\n\\nAdditionally, the configuration model source can reference OCI, Git, filesystem, and the original KCL code. With the help of KCL IDE and KPM package management tool, we can write models and upload them to OCI Registry for model reuse. These models can be used separately on the client-side or at runtime, depending on the specific scenario requirements.\\n\\n### Client-side\\n\\nWe will use a classic web service workload as an example to demonstrate the usage of the KRM KCL specification on the client-side.\\n\\nIn addition, we provide plugin support for Kubernetes community configuration management tools such as Kubectl, Helm, Kustomize, KPT, etc., in a unified programming interface. With just a few lines of configuration code, you can non-invasively edit and validate existing Kustomize YAML files, Helm Charts, define your own abstraction models, and share and reuse them.\\n\\nHere, we will provide a detailed explanation using the integration of KCL with the Kubectl tool as an example. You can find the installation instructions for the Kubectl KCL plugin at [here](https://github.com/kcl-lang/kubectl-kcl).\\n\\nFirst, execute the following command to get a sample configuration:\\n\\n```shell\\ngit clone https://github.com/kcl-lang/kubectl-kcl.git && cd ./kubectl-kcl/examples/\\n```\\n\\nThen, execute the following command to show the configuration:\\n\\n```shell\\n$ cat krm-kcl-abstraction.yaml\\n\\napiVersion: krm.kcl.dev/v1alpha1\\nkind: KCLRun\\nmetadata:\\n  name: web-service\\nspec:\\n  params:\\n    name: app\\n    containers:\\n      ngnix:\\n        image: ngnix\\n        ports:\\n        - containerPort: 80\\n    service:\\n      ports:\\n      - port: 80\\n  source: oci://ghcr.io/kcl-lang/web-service\\n```\\n\\nIn the above configuration, we use a pre-defined Kubernetes web service application abstraction model `oci://ghcr.io/kcl-lang/web-service` on the OCI registry, and configure the required fields for that model through the `params` field. By executing the following command, you can obtain the raw Kubernetes YAML output and deploy it to the cluster:\\n\\n```shell\\n$ kubectl kcl apply -f krm-kcl-abstraction.yaml\\n\\ndeployment.apps/app created\\nservice/app created\\n```\\n\\nIn addition to using YAML as the user input interface, KCL can be used as a DSL for writing configurations and policies. It allows developers and platform personnel to write and maintain configurations on a large scale using a unified KCL writing style on the client-side.\\n\\n![standalone-kcl-form](/img/blog/2023-09-08-dcm-using-kcl/standalone-kcl-form.png)\\n\\n### Runtime\\n\\nAt runtime, we provide Kubernetes cluster integration through the KCL Operator, allowing you to generate, mutate, or validate resources based on KCL configurations using an Access Webhook when applying resources to the cluster. The webhook captures create, apply, and edit operations and executes resources on the configuration associated with each operation using the `KCLRun` resource. With the KCL Operator, you can automate resource configuration management and security validation in a lightweight manner within a Kubernetes cluster using KCL code, without the need to develop a webhook server to dynamically modify and validate configurations at runtime.\\n\\nAdditionally, leveraging the modeling and abstraction capabilities of KCL, we can define functional abstractions/compositions for different resource APIs and expose them in the form of KCL schemas. Moreover, KCL schemas can be further automatically generated into OpenAPI schema definitions for other clients in the cluster to call, without the need for manually maintaining complex OpenAPI schema definitions for API abstractions/compositions.\\n\\nHere is an example of using the KCL Operator to modify resource annotations.\\n\\nInstall the KCL Operator:\\n\\n```shell\\nkubectl apply -f https://raw.githubusercontent.com/kcl-lang/kcl-operator/main/config/all.yaml\\n```\\n\\nUse the following command to observe and wait for the pod status to be `Running`:\\n\\n```shell\\nkubectl get po\\n```\\n\\nDeploy the annotation mutation model:\\n\\n```shell\\nkubectl apply -f- << EOF\\napiVersion: krm.kcl.dev/v1alpha1\\nkind: KCLRun\\nmetadata:\\n  name: set-annotation\\nspec:\\n  params:\\n    annotations:\\n      managed-by: kcl-operator\\n  source: oci://ghcr.io/kcl-lang/set-annotation\\nEOF\\n```\\n\\nDeploy a Pod resource to validate the model result:\\n\\n```shell\\nkubectl apply -f- << EOF\\napiVersion: v1\\nkind: Pod\\nmetadata:\\n  name: nginx\\n  annotations:\\n    app: nginx\\nspec:\\n  containers:\\n  - name: nginx\\n    image: nginx:1.14.2\\n    ports:\\n    - containerPort: 80\\nEOF\\nkubectl get po nginx -o yaml | grep kcl-operator\\n```\\n\\nWe can see the following output:\\n\\n```shell\\n    managed-by: kcl-operator\\n```\\n\\nWe can observe that the Nginx Pod automatically added the annotation `managed-by=kcl-operator`.\\n\\n## Summary\\n\\nDynamic configuration management can reduce the complexity of modern cloud-native configurations. With the KRM KCL specification and standard OCI models, we can achieve dynamic configuration management, allowing platform personnel and application developers to easily utilize these settings and reduce cognitive load.\\n\\n## Resources\\n\\n- [KCL Website](https://kcl-lang.io/)\\n- [KusionStack Website](https://kusionstack.io/)\\n\\n## Reference\\n\\n+ Declarative Application Management in Kubernetes: https://docs.google.com/document/d/1cLPGweVEYrVqQvBLJg6sxV-TrE5Rm2MNOBA_cxZP2WU/edit#\\n+ CNCF Platforms White Paper: https://tag-app-delivery.cncf.io/whitepapers/platforms/\\n+ Google SRE Workbook: https://sre.google/workbook/configuration-specifics/\\n+ What is Dynamic Configuration Management: https://humanitec.com/blog/what-is-dynamic-configuration-management\\n+ Implementing Dynamic Configuration Management with Score and Humanitec: https://humanitec.com/blog/implementing-dynamic-configuration-management-with-score-and-humanitec\\n+ What is Platform Engineering: https://platformengineering.org/blog/what-is-platform-engineering\\n+ What is Internal Developer Platform: https://internaldeveloperplatform.org/what-is-an-internal-developer-platform/\\n+ What Team Structure is Right for DevOps to Flourish: https://web.devopstopologies.com/#anti-types"},{"id":"2023-09-06-biweekly-newsletter","metadata":{"permalink":"/blog/2023-09-06-biweekly-newsletter","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-09-06-biweekly-newsletter/index.md","source":"@site/blog/2023-09-06-biweekly-newsletter/index.md","title":"KCL Biweekly Newsletter (2023 08.24 - 09.06) | Kubernetes Operator, IDE Extensions and v0.5.6 are out!","description":"KCL is an open-source, constraint-based record and functional language that enhances the writing of complex configurations, including those for cloud-native scenarios. With its advanced programming language technology and practices, KCL is dedicated to promoting better modularity, scalability, and stability for configurations. It enables simpler logic writing and offers ease of automation APIs and integration with homegrown systems.","date":"2023-09-06T00:00:00.000Z","formattedDate":"September 6, 2023","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Biweekly-Newsletter","permalink":"/blog/tags/biweekly-newsletter"}],"readingTime":4.635,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2023-09-06-biweekly-newsletter","title":"KCL Biweekly Newsletter (2023 08.24 - 09.06) | Kubernetes Operator, IDE Extensions and v0.5.6 are out!","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["KCL","Biweekly-Newsletter"]},"prevItem":{"title":"A New Paradigm for Dynamic Configuration Management - KRM KCL Specification","permalink":"/blog/2023-09-06-dcm-using-kcl"},"nextItem":{"title":"Congratulations to jakezhu9 for becoming a KCL Community Maintainer! KCL Import Tool Welcomes Enhanced Features!","permalink":"/blog/2023-09-04-maintainer-jakezhu9-blog"}},"content":"![](/img/biweekly-newsletter.png)\\n\\n[KCL](https://github.com/kcl-lang) is an open-source, constraint-based record and functional language that enhances the writing of complex configurations, including those for cloud-native scenarios. With its advanced programming language technology and practices, KCL is dedicated to promoting better modularity, scalability, and stability for configurations. It enables simpler logic writing and offers ease of automation APIs and integration with homegrown systems.\\n\\nThis section will update the KCL language community\'s latest developments every two weeks, including features, website updates, and the latest community news, helping everyone better understand the KCL community!\\n\\n***KCL Website: [https://kcl-lang.io](https://kcl-lang.io)***\\n\\n## Overview\\n\\nThank you to all contributors for their outstanding work over the past two weeks (08.10-08.23 2023). Here is an overview of the key content:\\n\\n**\ud83d\udd27 Language and Toolchain Updates**\\n\\n- **KCL Import Tool Updates** - Supports exporting JSON/YAML data to KCL configuration.\\n- **KCL IDE Updates** - Supports right-click formatting ability, formatting individual files or parts of KCL code.\\n- **KCL Documentation Tool Updates** - Exported documents support HTML escape.\\n- **KCL Package Management Tool KPM Updates** - `kpm run` command execution and error message optimization, supports running KCL packages located in local paths.\\n- **KCL Language Updates** - Optimized system package type check error messages and unified error message codes. \\n\\n**\ud83d\udcf0 Official Website and Use Case Updates**\\n\\n- KCL website adds v0.5.6 documentation version.\\n- Publishing KCL packages to docker.io or ghcr.io registries using Github Actions Example: [https://github.com/kcl-lang/kpm/blob/main/docs/push_by_github_action.md](https://github.com/kcl-lang/kpm/blob/main/docs/push_by_github_action.md)\\n- KCL Operator example: [https://kcl-lang.io/docs/user_docs/guides/working-with-k8s/mutate-manifests/kcl-operator](https://kcl-lang.io/docs/user_docs/guides/working-with-k8s/mutate-manifests/kcl-operator)\\n\\n## Special Thanks\\n\\nThe following are listed in no particular order:\\n\\n+ Thanks to @jakezhu9 for the contribution of converting JSON and YAML configuration data to KCL configuration in the KCL Import Tool \ud83d\ude4c [https://github.com/kcl-lang/kcl-go/pull/141](https://github.com/kcl-lang/kcl-go/pull/141)\\n+ Thanks to @xxmao123 and @starkers for their contributions to the KCL NeoVim and Idea IDE extensions \ud83d\ude4c [https://github.com/kcl-lang/intellij-kcl/pull/12](https://github.com/kcl-lang/intellij-kcl/pull/12)\\n+ Thanks to @kolloch, @prahaladramji, and others for their valuable feedback and discussions during the use of KCL in the past two weeks \ud83d\ude4c \\n\\n**Congratulations @jakezhu9 for becoming a KCL community Maintainer \ud83c\udf89**\\n\\n## Featured Updates\\n\\n### KCL Operator\\n\\nKCL Operator provides cluster integration, allowing you to use Access Webhook to generate, mutate, or validate resources based on KCL configuration when apply resources to the cluster. Webhook will capture creation, application, and editing operations, and execute [KCLRun](https://github.com/kcl-lang/krm-kcl) on the configuration associated with each operation, and the KCL programming language can be used to\\n\\n+ Add labels or annotations based on a condition.\\n+ Inject a sidecar container in all KRM resources that contain a `PodTemplate`.\\n+ Validating all KRM resources using KCL Schema, such as constraints on starting containers only in a root mode.\\n+ Generating KRM resources using an abstract model or combining and using different KRM APIs. \\n\\nWith KCL Operator, you can automate resource configuration management and security validation in a Kubernetes cluster using lightweight KCL code, without the need to develop a webhook server to dynamically mutate and validate configurations at runtime. \\n\\nFurthermore, leveraging KCL\'s modeling and abstraction capabilities, we can define functionality abstractions/compositions for different resource APIs and expose them in the form of KCL Schema. We can further generate OpenAPI Schema definitions from KCL Schema for other clients in the cluster to use, without manually maintaining complex OpenAPI Schema definitions for API abstractions/compositions. Here is an example of using KCL Operator to modify resource annotations:\\n\\n#### 0. Prerequisites\\n\\nPrepare a Kubernetes cluster like `k3d` the kubectl tool.\\n\\n#### 1. Install KCL Operator\\n\\n```shell\\nkubectl apply -f https://raw.githubusercontent.com/kcl-lang/kcl-operator/main/config/all.yaml\\n```\\n\\nUse the following command to observe and wait for the pod status to be `Running`.\\n\\n```shell\\nkubectl get po\\n```\\n\\n#### 2. Deploy KCL Annotation Setting Model\\n\\n```shell\\nkubectl apply -f- << EOF\\napiVersion: krm.kcl.dev/v1alpha1\\nkind: KCLRun\\nmetadata:\\n  name: set-annotation\\nspec:\\n  # Set dynamic parameters required for the annotation modification model, here we can add the labels we want to modify/add\\n  params:\\n    annotations:\\n      managed-by: kcl-operator\\n  # Reference the annotation modification model on OCI\\n  source: oci://ghcr.io/kcl-lang/set-annotation\\nEOF\\n```\\n\\n#### 3. Deploy a Pod to Verify the Model Result\\n\\nExecute the following command to deploy a `Pod` resource:\\n\\n```shell\\nkubectl apply -f- << EOF\\napiVersion: v1\\nkind: Pod\\nmetadata:\\n  name: nginx\\n  annotations:\\n    app: nginx\\nspec:\\n  containers:\\n  - name: nginx\\n    image: nginx:1.14.2\\n    ports:\\n    - containerPort: 80\\nEOF\\nkubectl get po nginx -o yaml | grep kcl-operator\\n```\\n\\nWe can see the following output:\\n\\n```shell\\n    managed-by: kcl-operator\\n```\\n\\nWe can see that the Nginx Pod automatically added the annotation `managed-by=kcl-operator`.\\n\\nIn addition, besides referencing an existing model for the source field of the `KCLRun` resource, we can directly set KCL code for the source field to achieve the same effect. For example:\\n\\n```yaml\\napiVersion: krm.kcl.dev/v1alpha1\\nkind: KCLRun\\nmetadata:\\n  name: set-annotation\\nspec:\\n  params:\\n    annotations:\\n      managed-by: kcl-operator\\n  # Resource modification can be achieved with just one line of KCL code\\n  source: |\\n    items = [item | {metadata.annotations: option(\\"params\\").annotations} for item in option(\\"items\\")]\\n```\\n\\nWe have provided more than 30 built-in models, and you can find more code examples in the following link: [https://github.com/kcl-lang/krm-kcl/tree/main/examples](https://github.com/kcl-lang/krm-kcl/tree/main/examples)\\n\\n### IDE Extension Updates\\n\\nIn the past two weeks, we have integrated the KCL language server LSP into NeoVim and Idea, enabling the completion, navigation, and hover features supported by VS Code IDE in NeoVim and IntelliJ IDEA.\\n\\n+ NeoVim KCL Extension\\n\\n![kcl.nvim](/img/docs/tools/Ide/neovim/overview.png)\\n\\n+ IntelliJ Extension\\n\\n![intellij](/img/docs/tools/Ide/intellij/overview.png)\\n\\nFor more information on downloading, installation, and features of the IDE plugins, please refer to:\\n\\n+ [https://kcl-lang.io/docs/user_docs/getting-started/install#neovim](https://kcl-lang.io/docs/user_docs/getting-started/install#neovim)\\n+ [https://kcl-lang.io/docs/user_docs/getting-started/install#intellij-idea](https://kcl-lang.io/docs/user_docs/getting-started/install#intellij-idea)\\n\\n## Resources\\n\\n\u2764\ufe0f Thanks to all KCL users and community members for their valuable feedback and suggestions in the community.\\n\\nFor more resources, please refer to\\n\\n- [KCL Website](https://kcl-lang.io/)\\n- [KusionStack Website](https://kusionstack.io/)\\n\\n- [KCL 2023 Roadmap](https://kcl-lang.io/docs/community/release-policy/roadmap)\\n- [KCL v0.6.0 Milestone](https://github.com/kcl-lang/kcl/milestone/6)\\n- [KCL Github Issues](https://github.com/kcl-lang/kcl/issues)\\n- [KCL Github Discussion](https://github.com/orgs/kcl-lang/discussions)\\n- [KCL Community](https://github.com/kcl-lang/community)"},{"id":"2023-09-04-maintainer-jakezhu9-blog","metadata":{"permalink":"/blog/2023-09-04-maintainer-jakezhu9-blog","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-09-04-maintainer-jakezhu9-blog/index.md","source":"@site/blog/2023-09-04-maintainer-jakezhu9-blog/index.md","title":"Congratulations to jakezhu9 for becoming a KCL Community Maintainer! KCL Import Tool Welcomes Enhanced Features!","description":"News Flash","date":"2023-09-04T00:00:00.000Z","formattedDate":"September 4, 2023","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Meeting","permalink":"/blog/tags/meeting"}],"readingTime":2.195,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2023-09-04-maintainer-jakezhu9-blog","title":"Congratulations to jakezhu9 for becoming a KCL Community Maintainer! KCL Import Tool Welcomes Enhanced Features!","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["KCL","Meeting"]},"prevItem":{"title":"KCL Biweekly Newsletter (2023 08.24 - 09.06) | Kubernetes Operator, IDE Extensions and v0.5.6 are out!","permalink":"/blog/2023-09-06-biweekly-newsletter"},"nextItem":{"title":"KCL Introduction Platform Engineering Tech Summit 2023 Meeting","permalink":"/blog/2023-platform-engineering-tech-summit"}},"content":"## News Flash\\n\\n![jakezhu9](/img/blog/2023-09-04-maintainer-jakezhu9-blog/jakezhu9.png)\\n\\n\ud83c\udf89 Recently, the KCL community welcomed a new member as a Maintainer. **Congratulations to jakezhu9 on successfully being promoted as a community maintainer**.\\n\\nWe would like to express our gratitude for his numerous contributions to the KCL Go SDK and the series of enhanced features he has brought to the KCL Import Tool, providing users with a more convenient and efficient experience in importing data and schemas. Here is a list of his recent significant contributions:\\n\\n+ \ud83d\udd27 Support for converting JSON/YAML data to KCL configuration: [https://github.com/kcl-lang/kcl-go/pull/145](https://github.com/kcl-lang/kcl-go/pull/145)\\n+ \ud83d\udd27 Support for converting Terraform Provider Schema to KCL Schema: [https://github.com/kcl-lang/kcl-go/pull/141](https://github.com/kcl-lang/kcl-go/pull/141)\\n+ \ud83d\udd27 Support for converting JsonSchema to KCL Schema: [https://github.com/kcl-lang/kcl-go/pull/127](https://github.com/kcl-lang/kcl-go/pull/127)\\n\\nThe addition of the new Maintainer not only signifies jakezhu9\'s outstanding technical performance but also reflects the community\'s high recognition and trust in him.\\n\\n## Experience\\n\\nHere are jakezhu9\'s reflections on participating in the KCL community:\\n\\nI feel incredibly fortunate to be a part of the KCL community and contribute to the development and growth of the project. From the initial introduction to the KusionStack and KCL, powerful tools and languages in the cloud-native field, to fixing a simple bug in the project, and gradually designing and developing the conversion and generation aspects of KCL, I have not only improved my technical skills but also gained valuable experience in open-source contributions. I have experienced the joy and sense of accomplishment that comes with continuous progress. Every time I see one of my submitted PRs get merged, I feel a great sense of satisfaction. I am grateful to the KCL community and all the seniors and fellow contributors I have encountered along the way who have provided me with ideas and suggestions that have been incredibly helpful during my development process.\\n\\nThe KCL community is an open, vibrant, and opportune open-source community where developers from different companies and schools with diverse technical backgrounds collaborate and exchange ideas on GitHub and in community meetings. Together, they explore cutting-edge technical solutions and contribute efficient and concise code to the community. Whether you are a novice or an expert in open-source, you can quickly integrate into the community and actively participate. The harmonious and friendly atmosphere in the community makes me feel incredibly welcomed. In the future, I will continue to contribute more to the KCL community, and I warmly welcome interested students to join us and participate in the construction and development of the community together!\\n\\n## Resources\\n\\nFor more resources, please refer to\\n\\n- [KCL Website](https://kcl-lang.io/)\\n- [KusionStack Website](https://kusionstack.io/)\\n\\n- [KCL 2023 Roadmap](https://kcl-lang.io/docs/community/release-policy/roadmap)\\n- [KCL v0.6.0 Milestone](https://github.com/kcl-lang/kcl/milestone/6)\\n- [KCL Github Issues](https://github.com/kcl-lang/kcl/issues)\\n- [KCL Github Discussion](https://github.com/orgs/kcl-lang/discussions)\\n- [KCL Community](https://github.com/kcl-lang/community)"},{"id":"2023-platform-engineering-tech-summit","metadata":{"permalink":"/blog/2023-platform-engineering-tech-summit","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-09-01-kcl-platform-engineering-tech-summit/index.md","source":"@site/blog/2023-09-01-kcl-platform-engineering-tech-summit/index.md","title":"KCL Introduction Platform Engineering Tech Summit 2023 Meeting","description":"Download PDF (Chinese)","date":"2023-09-01T00:00:00.000Z","formattedDate":"September 1, 2023","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Meeting","permalink":"/blog/tags/meeting"}],"readingTime":0.03,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2023-platform-engineering-tech-summit","title":"KCL Introduction Platform Engineering Tech Summit 2023 Meeting","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["KCL","Meeting"]},"prevItem":{"title":"Congratulations to jakezhu9 for becoming a KCL Community Maintainer! KCL Import Tool Welcomes Enhanced Features!","permalink":"/blog/2023-09-04-maintainer-jakezhu9-blog"},"nextItem":{"title":"5-Minute Gameplay with Helmfile KCL Plugin for Easy Management of Kubernetes Helm Charts","permalink":"/blog/2023-08-31-helmfile-kcl-plugin"}},"content":"[Download PDF (Chinese)](https://kcl-lang.github.io/talks/kcl-platform-engineering-tech-summit2023.pdf)\\n\\n![KCL Talk Cover](/img/blog/2023-09-01-kcl-platform-engineering-tech-summit/talk-cover.jpg)"},{"id":"2023-08-31-helmfile-kcl-plugin","metadata":{"permalink":"/blog/2023-08-31-helmfile-kcl-plugin","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-08-31-helmfile-kcl-plugin/index.md","source":"@site/blog/2023-08-31-helmfile-kcl-plugin/index.md","title":"5-Minute Gameplay with Helmfile KCL Plugin for Easy Management of Kubernetes Helm Charts","description":"What is KCL","date":"2023-08-31T00:00:00.000Z","formattedDate":"August 31, 2023","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Biweekly-Newsletter","permalink":"/blog/tags/biweekly-newsletter"}],"readingTime":3.755,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2023-08-31-helmfile-kcl-plugin","title":"5-Minute Gameplay with Helmfile KCL Plugin for Easy Management of Kubernetes Helm Charts","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["KCL","Biweekly-Newsletter"]},"prevItem":{"title":"KCL Introduction Platform Engineering Tech Summit 2023 Meeting","permalink":"/blog/2023-platform-engineering-tech-summit"},"nextItem":{"title":"KCL Biweekly Newsletter (2023 08.10 - 08.23) | KCL v0.5.3, v0.5.4 and v0.5.5 are out!","permalink":"/blog/2023-08-23-biweekly-newsletter"}},"content":"## What is KCL\\n\\n[KCL](https://github.com/kcl-lang) is an open-source, constraint-based record and functional language that enhances the writing of complex configurations, including those for cloud-native scenarios. With its advanced programming language technology and practices, KCL is dedicated to promoting better modularity, scalability, and stability for configurations. It enables simpler logic writing and offers ease of automation APIs and integration with homegrown systems.\\n\\n## What is Helmfile\\n\\nHelmfile is a declarative specification and tool for simplifying and managing Helm Charts. The Helmfile KCL Plugin provides additional functionality to the Helmfile tool, making it more convenient and efficient to use. With the Helmfile KCL Plugin, you can:\\n\\n+ Edit or validate Helm Chart configurations directly on the client-side using non-intrusive hooks. This allows you to separate the data and logic parts of Kubernetes configuration management without needing to fork the upstream Chart to modify internal logic include modifying resource labels/annotations and injecting Sidecar container configurations.\\n+ Validate Kubernetes resources using KCL Schema, define your own abstract models, and share them for reusability.\\n\\nIn this blog, we will quickly guide you through getting started with the Helmfile KCL Plugin, enabling you to easily manage your Kubernetes Helm Charts.\\n\\nWe will explain in detail using a simple example. With the Helmfile KCL Plugin, you do not need to install any components related to KCL. You only need the latest version of the Helmfile tool (v0.156.0+) on your local machine.\\n\\n## Using the Helmfile KCL Plugin\\n\\n### 1. Tool Installation\\n\\nFirst, make sure you have installed the Helmfile client tool. You can follow the instructions in the documentation link below.\\n\\nhttps://github.com/helmfile/helmfile\\n\\n### 2. Create the Helmfile Configuration File\\n\\nCreate a file named helmfile.yaml in the root directory of your project and write the configuration using Helmfile syntax. In this file, you can specify the Helm Charts to use, configuration values, and any other functionality supported by Helmfile. Additionally, you can use the features of the KCL Plugin in helmfile.yaml to load configurations and make in-place modifications and validations to the Helm Chart.\\n\\n```yaml\\nrepositories:\\n- name: prometheus-community\\n  url: https://prometheus-community.github.io/helm-charts\\nreleases:\\n- name: prom-norbac-ubuntu\\n  namespace: prometheus\\n  chart: prometheus-community/prometheus\\n  set:\\n  - name: rbac.create\\n    value: false\\n  transformers:\\n  # Use KCL Plugin to mutate or validate Kubernetes manifests.\\n  - apiVersion: krm.kcl.dev/v1alpha1\\n    kind: KCLRun\\n    metadata:\\n      name: \\"set-annotation\\"\\n      annotations:\\n        config.kubernetes.io/function: |\\n          container:\\n            image: docker.io/kcllang/kustomize-kcl:v0.2.0\\n    spec:\\n      source: |\\n        # A single line of KCL code can be used to modify workload configurations in-place.\\n        items = [resource | {if resource.kind == \\"Deployment\\": metadata.annotations: {\\"managed-by\\" = \\"helmfile-kcl\\"}} for resource in option(\\"resource_list\\").items]\\n```\\n\\nIn the above configuration, we reference the Prometheus Helm Chart and use a single line of KCL code to inject the label `managed-by=\\"helmfile-kcl\\"` to all the Deployment resources of Prometheus.\\n\\n### 3. Run the Helmfile Tool\\n\\nOnce everything is set up, you can run the Helmfile command to deploy, manage, and maintain your Helm Charts. Use the following command to apply the configuration mentioned above to the cluster.\\n\\n```shell\\nhelmfile apply\\n```\\n\\nYou should see the following output if everything goes well:\\n\\n```shell\\nAdding repo prometheus-community https://prometheus-community.github.io/helm-charts\\n\\"prometheus-community\\" has been added to your repositories...\\n\\n...\\n```\\n\\n## Want More?\\n\\nFor the above helmfile configuration, you can encapsulate it as a reusable logic for configuration modification without constantly writing and copying/pasting KCL code. Additionally, many commonly used Kubernetes configuration editing and validation code snippets are already packaged in the KCL official Registry: https://github.com/orgs/kcl-lang/packages\\n\\n![registry](/img/blog/2023-08-31-helmfile-kcl-plugin/registry.png)\\n\\nIn addition to supporting writing KCL code in configuration files, we also support directly referencing code snippets in Registry, as shown below\\n\\n```yaml\\napiVersion: krm.kcl.dev/v1alpha1\\nkind: KCLRun\\nmetadata:\\n  name: https-only\\n  annotations: \\n    krm.kcl.dev/version: 0.0.1\\n    krm.kcl.dev/type: validation\\n    documentation: >-\\n      Requires Ingress resources to be HTTPS only.  Ingress resources must\\n      include the `kubernetes.io/ingress.allow-http` annotation, set to `false`.\\n      By default a valid TLS {} configuration is required, this can be made\\n      optional by setting the `tlsOptional` parameter to `true`.\\n      More info: https://kubernetes.io/docs/concepts/services-networking/ingress/#tls\\nspec:\\n  # Use the OCI source\\n  source: oci://ghcr.io/kcl-lang/https-only\\n```\\n\\nSpecific example codes can be found [here](https://github.com/kcl-lang/krm-kcl/tree/main/examples)\\n\\nIf you want to contribute more KCL code repositories, feel free to contact us and refer to the documentation for contribution: https://kcl-lang.io/zh-CN/docs/user_docs/guides/package-management/share_your_pkg/\\n\\n## Conclusion\\n\\nThis blog provided a quick getting started guide to help you master the basics of the Helmfile KCL Plugin in just 5 minutes. Now, you can start using this powerful tool to simplify and optimize your Kubernetes application deployment process!\\n\\n## Resources\\n\\nFor more resources, please refer to\\n\\n- [KCL Website](https://kcl-lang.io/)\\n- [KusionStack Website](https://kusionstack.io/)\\n\\n- [KCL 2023 Roadmap](https://kcl-lang.io/docs/community/release-policy/roadmap)\\n- [KCL v0.6.0 Milestone](https://github.com/kcl-lang/kcl/milestone/6)\\n- [KCL Github Issues](https://github.com/kcl-lang/kcl/issues)\\n- [KCL Github Discussion](https://github.com/orgs/kcl-lang/discussions)\\n- [KCL Community](https://github.com/kcl-lang/community)"},{"id":"2023-08-23-biweekly-newsletter","metadata":{"permalink":"/blog/2023-08-23-biweekly-newsletter","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-08-23-biweekly-newsletter/index.md","source":"@site/blog/2023-08-23-biweekly-newsletter/index.md","title":"KCL Biweekly Newsletter (2023 08.10 - 08.23) | KCL v0.5.3, v0.5.4 and v0.5.5 are out!","description":"KCL is an open-source, constraint-based record and functional language that enhances the writing of complex configurations, including those for cloud-native scenarios. With its advanced programming language technology and practices, KCL is dedicated to promoting better modularity, scalability, and stability for configurations. It enables simpler logic writing and offers ease of automation APIs and integration with homegrown systems.","date":"2023-08-23T00:00:00.000Z","formattedDate":"August 23, 2023","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Biweekly-Newsletter","permalink":"/blog/tags/biweekly-newsletter"}],"readingTime":5.35,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2023-08-23-biweekly-newsletter","title":"KCL Biweekly Newsletter (2023 08.10 - 08.23) | KCL v0.5.3, v0.5.4 and v0.5.5 are out!","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["KCL","Biweekly-Newsletter"]},"prevItem":{"title":"5-Minute Gameplay with Helmfile KCL Plugin for Easy Management of Kubernetes Helm Charts","permalink":"/blog/2023-08-31-helmfile-kcl-plugin"},"nextItem":{"title":"KCL Biweekly Newsletter (2023 07.26 - 08.09) | KCL v0.5.1 and v0.5.2 is out!","permalink":"/blog/2023-08-09-biweekly-newsletter"}},"content":"![](/img/biweekly-newsletter.png)\\n\\n[KCL](https://github.com/kcl-lang) is an open-source, constraint-based record and functional language that enhances the writing of complex configurations, including those for cloud-native scenarios. With its advanced programming language technology and practices, KCL is dedicated to promoting better modularity, scalability, and stability for configurations. It enables simpler logic writing and offers ease of automation APIs and integration with homegrown systems.\\n\\nThis section will update the KCL language community\'s latest developments every two weeks, including features, website updates, and the latest community news, helping everyone better understand the KCL community!\\n\\n***KCL Website: [https://kcl-lang.io](https://kcl-lang.io)***\\n\\n## Overview\\n\\nThank you to all contributors for their outstanding work over the past two weeks (08.10-08.23 2023). Here is an overview of the key content:\\n\\n**\ud83d\udd27 Language and Toolchain Updates**\\n\\n- **KCL Formatting Tool Updates** - Support for formatting code snippets with syntax errors and partial code snippets and automatic correction of indentation errors in configuration blocks.\\n- **KCL Documentation Tool Updates** - Support for exporting document index pages\\n- **KCL Import Tool Updates** - Support for converting Terraform Provider Schema to KCL Schema\\n- **KCL Export Tool Updates** - Support for exporting OpenAPI Spec from KCL Schema, integrating with OpenAPI ecosystem\\n- **KCL IDE Updates** - Support for compilation cache feature to improve performance of some IDE features and providing rich error messages and import statement quick fix capabilities\\n- **KCL Package Management Tool Updates** - Support for output information experience optimization for the `kpm push` command and adding duplicate tag check when pushing KCL package. Adding the `--vendor` parameter for the `kpm push` and `kpm pkg` commands to determine whether to package third-party libraries in KCL packages together\\n- **KCL Language Updates** - Optimize Schema semantic check and union type check error messages and support for exporting type output of configuration blocks.\\n\\n\ud83c\udfc4 **API Updates**\\n\\n- KCL Schema model parsing GetSchemaType API newly added KCL package related information and schema attribute default values.\\n\\n**\ud83d\udcf0 Official Website and Use Case Updates**\\n\\n- KCL package docker.io integration example: *[https://github.com/kcl-lang/kpm/blob/main/docs/publish_to_docker_reg.md](https://github.com/kcl-lang/kpm/blob/main/docs/publish_to_docker_reg.md)*\\n- KCL Gitlab CI integration example: *[https://kcl-lang.io/docs/user_docs/guides/ci-integration/gitlab-ci](https://kcl-lang.io/docs/user_docs/guides/ci-integration/gitlab-ci)*\\n- KCL Vault and Vals Integration example: *[https://kcl-lang.io/docs/user_docs/guides/secret-management/vault](https://kcl-lang.io/docs/user_docs/guides/secret-management/vault)*\\n\\n## Special Thanks\\n\\nThe following are listed in no particular order:\\n\\n- Thanks to @jakezhu9 for the contribution of the KCL Import Tool Terraform Schema to KCL Schema conversion \ud83d\ude4c [https://github.com/kcl-lang/kcl-go/pull/141](https://github.com/kcl-lang/kcl-go/pull/141)\\n- Thanks to @xxmao123 and @starkers for the discussion and contribution of the NeoVim KCL extension \ud83d\ude4c [https://github.com/kcl-lang/vim-kcl/pull/2](https://github.com/kcl-lang/vim-kcl/pull/2)\\n- Thanks to @starkers for adding KCL installation support to the mason.nvim registry \ud83d\ude4c [https://github.com/mason-org/mason-registry/pull/2425](https://github.com/mason-org/mason-registry/pull/2425)\\n- Thanks to @prahaladramji for upgrading and updating the KCL Homebrew installation script \ud83d\ude4c [https://github.com/kcl-lang/homebrew-tap/pull/1](https://github.com/kcl-lang/homebrew-tap/pull/1)\\n- Thanks to @yamin-oanda for the discussion of Pulumi\'s official KCL support \ud83d\ude4c [https://github.com/pulumi/pulumi/discussions/13722](https://github.com/pulumi/pulumi/discussions/13722)\\n- In addition, thanks to @nkabir, @mihaigalos, @prahaladramji, @yamin-oanda, @magick93, @MirKml, and others for their valuable feedback and discussions while using KCL in the past two weeks. \ud83d\ude4c\\n\\n## Featured Updates\\n\\n### KCL Import Tool Updates\\n\\nThe KCL Import Tool now adds support for converting Terraform Provider Schema to KCL Schema based on Protobuf, JsonSchema OpenAPI models, and Go Structures, such as the following Terraform Provider Json (obtained through the command `terraform providers schema -json > provider.json` , For more details, please refer to [https://developer.hashicorp.com/terraform/cli/commands/providers/schema](https://developer.hashicorp.com/terraform/cli/commands/providers/schema))\\n\\n```json\\n{\\n    \\"format_version\\": \\"0.2\\",\\n    \\"provider_schemas\\": {\\n        \\"registry.terraform.io/aliyun/alicloud\\": {\\n            \\"provider\\": {\\n                \\"version\\": 0,\\n                \\"block\\": {\\n                    \\"attributes\\": {},\\n                    \\"block_types\\": {},\\n                    \\"description_kind\\": \\"plain\\"\\n                }\\n            },\\n            \\"resource_schemas\\": {\\n                \\"alicloud_db_instance\\": {\\n                    \\"version\\": 0,\\n                    \\"block\\": {\\n                        \\"attributes\\": {\\n                            \\"db_instance_type\\": {\\n                                \\"type\\": \\"string\\",\\n                                \\"description_kind\\": \\"plain\\",\\n                                \\"computed\\": true\\n                            },\\n                            \\"engine\\": {\\n                                \\"type\\": \\"string\\",\\n                                \\"description_kind\\": \\"plain\\",\\n                                \\"required\\": true\\n                            },\\n                            \\"security_group_ids\\": {\\n                                \\"type\\": [\\n                                    \\"set\\",\\n                                    \\"string\\"\\n                                ],\\n                                \\"description_kind\\": \\"plain\\",\\n                                \\"optional\\": true,\\n                                \\"computed\\": true\\n                            },\\n                            \\"security_ips\\": {\\n                                \\"type\\": [\\n                                    \\"set\\",\\n                                    \\"string\\"\\n                                ],\\n                                \\"description_kind\\": \\"plain\\",\\n                                \\"optional\\": true,\\n                                \\"computed\\": true\\n                            },\\n                            \\"tags\\": {\\n                                \\"type\\": [\\n                                    \\"map\\",\\n                                    \\"string\\"\\n                                ],\\n                                \\"description_kind\\": \\"plain\\",\\n                                \\"optional\\": true\\n                            }\\n                        },\\n                        \\"block_types\\": {},\\n                        \\"description_kind\\": \\"plain\\"\\n                    }\\n                },\\n                \\"alicloud_config_rule\\": {\\n                    \\"version\\": 0,\\n                    \\"block\\": {\\n                        \\"attributes\\": {\\n                            \\"compliance\\": {\\n                                \\"type\\": [\\n                                    \\"list\\",\\n                                    [\\n                                        \\"object\\",\\n                                        {\\n                                            \\"compliance_type\\": \\"string\\",\\n                                            \\"count\\": \\"number\\"\\n                                        }\\n                                    ]\\n                                ],\\n                                \\"description_kind\\": \\"plain\\",\\n                                \\"computed\\": true\\n                            },\\n                            \\"resource_types_scope\\": {\\n                                \\"type\\": [\\n                                    \\"list\\",\\n                                    \\"string\\"\\n                                ],\\n                                \\"description_kind\\": \\"plain\\",\\n                                \\"optional\\": true,\\n                                \\"computed\\": true\\n                            }\\n                        }\\n                    }\\n                }\\n            },\\n            \\"data_source_schemas\\": {}\\n        }\\n    }\\n}\\n```\\n\\nThen the tool can output the following KCL code\\n\\n```python\\n\\"\\"\\"\\nThis file was generated by the KCL auto-gen tool. DO NOT EDIT.\\nEditing this file might prove futile when you re-run the KCL auto-gen generate command.\\n\\"\\"\\"\\n\\nschema AlicloudConfigRule:\\n    \\"\\"\\"\\n    AlicloudConfigRule\\n\\n    Attributes\\n    ----------\\n    compliance: [ComplianceObject], optional\\n    resource_types_scope: [str], optional\\n    \\"\\"\\"\\n\\n    compliance?: [ComplianceObject]\\n    resource_types_scope?: [str]\\n\\nschema ComplianceObject:\\n    \\"\\"\\"\\n    ComplianceObject\\n\\n    Attributes\\n    ----------\\n    compliance_type: str, optional\\n    count: int, optional\\n    \\"\\"\\"\\n\\n    compliance_type?: str\\n    count?: int\\n\\nschema AlicloudDbInstance:\\n    \\"\\"\\"\\n    AlicloudDbInstance\\n\\n    Attributes\\n    ----------\\n    db_instance_type: str, optional\\n    engine: str, required\\n    security_group_ids: [str], optional\\n    security_ips: [str], optional\\n    tags: {str:str}, optional\\n    \\"\\"\\"\\n\\n    db_instance_type?: str\\n    engine: str\\n    security_group_ids?: [str]\\n    security_ips?: [str]\\n    tags?: {str:str}\\n\\n    check:\\n        isunique(security_group_ids)\\n        isunique(security_ips)\\n```\\n\\n### KCL Vault Integration\\n\\nIn just three steps, we can use Vault to store and manage sensitive information and use it in KCL.\\n\\nFirstly, we install and use `Vault` to store `foo` and `bar` information\\n\\n```shell\\nvault kv put secret/foo foo=foo\\nvault kv put secret/bar bar=bar\\n```\\n\\nThen write the following KCL code (main.k)\\n\\n```python\\napiVersion = \\"apps/v1\\"\\nkind = \\"Deployment\\"\\nmetadata = {\\n    name = \\"nginx\\"\\n    labels.app = \\"nginx\\"\\n    annotations: {\\n        \\"secret-store\\": \\"vault\\"\\n        # Valid format:\\n        #  \\"ref+vault://PATH/TO/KV_BACKEND#/KEY\\"\\n        \\"foo\\": \\"ref+vault://secret/foo#/foo\\"\\n        \\"bar\\": \\"ref+vault://secret/bar#/bar\\"\\n    }\\n}\\nspec = {\\n    replicas = 3\\n    selector.matchLabels = metadata.labels\\n    template.metadata.labels = metadata.labels\\n    template.spec.containers = [\\n        {\\n            name = metadata.name\\n            image = \\"${metadata.name}:1.14.2\\"\\n            ports = [{ containerPort = 80 }]\\n        }\\n    ]\\n}\\n```\\n\\nFinally, the decrypted configuration can be obtained through the `Vals` command-line tool\\n\\n```shell\\nkcl main.k | vals eval -f -\\n```\\n\\n> For more details and use cases, please refer to [https://kcl-lang.io/docs/user_docs/guides/secret-management/vault](https://kcl-lang.io/docs/user_docs/guides/secret-management/vault)\\n\\n## Community\\n\\n- \ud83c\udf89 Congratulations to Zhu Junxing from Huazhong University of Science and Technology for successfully passing the mid-term assessment of the Gitlink Coding Summer Camp (GLCC) and completing the conversion of KCL Import tool Jsonschema and Terraform Provider Schema to KCL Schema. The community will grant him the KCL Community Maintainer role in the future.\\n- \ud83d\udcbb KCL participated in the CNCF TAG Application Delivery community meeting and reported on the project.\\n\\n## Resources\\n\\n\u2764\ufe0f Thanks to all KCL users and community members for their valuable feedback and suggestions in the community. We will write more articles on the new features of KCL v0.5.x, so stay tuned!\\n\\nFor more resources, please refer to\\n\\n- [KCL Website](https://kcl-lang.io/)\\n- [KusionStack Website](https://kusionstack.io/)\\n\\n- [KCL 2023 Roadmap](https://kcl-lang.io/docs/community/release-policy/roadmap)\\n- [KCL v0.6.0 Milestone](https://github.com/kcl-lang/kcl/milestone/6)\\n- [KCL Github Issues](https://github.com/kcl-lang/kcl/issues)\\n- [KCL Github Discussion](https://github.com/orgs/kcl-lang/discussions)\\n- [KCL Community](https://github.com/kcl-lang/community)"},{"id":"2023-08-09-biweekly-newsletter","metadata":{"permalink":"/blog/2023-08-09-biweekly-newsletter","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-08-09-biweekly-newsletter/index.md","source":"@site/blog/2023-08-09-biweekly-newsletter/index.md","title":"KCL Biweekly Newsletter (2023 07.26 - 08.09) | KCL v0.5.1 and v0.5.2 is out!","description":"KCL is an open-source, constraint-based record and functional language that enhances the writing of complex configurations, including those for cloud-native scenarios. With its advanced programming language technology and practices, KCL is dedicated to promoting better modularity, scalability, and stability for configurations. It enables simpler logic writing and offers ease of automation APIs and integration with homegrown systems.","date":"2023-08-09T00:00:00.000Z","formattedDate":"August 9, 2023","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Biweekly-Newsletter","permalink":"/blog/tags/biweekly-newsletter"}],"readingTime":3.55,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2023-08-09-biweekly-newsletter","title":"KCL Biweekly Newsletter (2023 07.26 - 08.09) | KCL v0.5.1 and v0.5.2 is out!","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["KCL","Biweekly-Newsletter"]},"prevItem":{"title":"KCL Biweekly Newsletter (2023 08.10 - 08.23) | KCL v0.5.3, v0.5.4 and v0.5.5 are out!","permalink":"/blog/2023-08-23-biweekly-newsletter"},"nextItem":{"title":"Implementing GitOps using Github, Argo CD, and KCL to Simplify DevOps","permalink":"/blog/2023-07-31-kcl-github-argocd-gitops"}},"content":"![](/img/biweekly-newsletter.png)\\n\\n[KCL](https://github.com/kcl-lang) is an open-source, constraint-based record and functional language that enhances the writing of complex configurations, including those for cloud-native scenarios. With its advanced programming language technology and practices, KCL is dedicated to promoting better modularity, scalability, and stability for configurations. It enables simpler logic writing and offers ease of automation APIs and integration with homegrown systems.\\n\\nThis section will update the KCL language community\'s latest developments every two weeks, including features, website updates, and the latest community news, helping everyone better understand the KCL community!\\n\\n***KCL Website: [https://kcl-lang.io](https://kcl-lang.io)***\\n\\n## Overview\\n\\nIn the past two weeks (2023 07.26 to 08.09), a total of 34 PRs were merged in all KCL projects. Thanks to all contributors for their outstanding work. The following is a summary of the merged PRs.\\n\\n- **\ud83d\udd27 Language and toolchain updates**\\n  - KCL document tool update - Markdown document export support\\n  - KCL import tool update - JsonSchema - KCL schema conversion support\\n  - KCL package management tool KPM supports setting compilation parameters in kcl.mod, optimizing command line prompts\\n  - KCL IDE extension autocomplete, jump, hover document display optimization and Vim and NeoVim KCL plugin support\\n- **\ud83c\udfc4 API updates**\\n  - KCL Schema model parsing GetSchemaType API newly added decorator information and package information fields\\n- **\ud83c\udfe0 Community extension updates**\\n  - Helmfile KCL plugin support\\n- **\ud83d\udcf0 Website and case updates**\\n  - KCL website adds v0.5.x document version selection\\n  - Add KCL use case repository: [https://github.com/kcl-lang/examples](https://github.com/kcl-lang/examples)\\n\\n## Special Thanks\\n\\n+ Thanks to @jakezhu9 for contributing to the conversion of JsonSchema to KCL Schema in the KCL Import tool \ud83d\ude4c\\n+ Thanks to @xxmao123 for contributing to Vim and NeoVim KCL plugins \ud83d\ude4c\\n+ Thanks to @yyxhero for the help and support provided in Helmfile KCL plugin support \ud83d\ude4c\\n+ Thanks to @nkabir, @mihaigalos, @prahaladramji, @dhhopen, etc. for their valuable suggestions and discussions on using KCL \ud83d\ude4c\\n\\n## Featured Updates\\n\\n### KCL Import Tool Update\\n\\nOn the basis of converting Protobuf, OpenAPI models, and Go structures into KCL Schema, the KCL Import tool adds support for converting JsonSchema to KCL Schema. For example, for the following JsonSchema:\\n\\n```json\\n{\\n\xa0\\"$schema\\":\xa0\\"http://json-schema.org/draft-07/schema#\\",\\n\xa0\\"$id\\":\xa0\\"https://example.com/schemas/customer.json\\",\\n\xa0\\"type\\":\xa0\\"object\\",\\n\xa0\\"$defs\\":\xa0{\\n\xa0\xa0\\"address\\":\xa0{\\n\xa0\xa0\xa0\\"type\\":\xa0\\"object\\",\\n\xa0\xa0\xa0\\"properties\\":\xa0{\\n\xa0\xa0\xa0\xa0\\"city\\":\xa0{\\n\xa0\xa0\xa0\xa0\xa0\\"type\\":\xa0\\"string\\"\\n\xa0\xa0\xa0\xa0},\\n\xa0\xa0\xa0\xa0\\"state\\":\xa0{\\n\xa0\xa0\xa0\xa0\xa0\\"$ref\\":\xa0\\"#/$defs/state\\"\\n\xa0\xa0\xa0\xa0}\\n\xa0\xa0\xa0}\\n\xa0\xa0},\\n\xa0\xa0\\"state\\":\xa0{\\n\xa0\xa0\xa0\\"type\\":\xa0\\"object\\",\\n\xa0\xa0\xa0\\"properties\\":\xa0{\\n\xa0\xa0\xa0\xa0\\"name\\":\xa0{\\n\xa0\xa0\xa0\xa0\xa0\\"type\\":\xa0\\"string\\"\\n\xa0\xa0\xa0\xa0}\\n\xa0\xa0\xa0}\\n\xa0\xa0}\\n\xa0},\\n\xa0\\"properties\\":\xa0{\\n\xa0\xa0\\"name\\":\xa0{\\n\xa0\xa0\xa0\\"type\\":\xa0\\"string\\"\\n\xa0\xa0},\\n\xa0\xa0\\"address\\":\xa0{\\n\xa0\xa0\xa0\\"$ref\\":\xa0\\"#/$defs/address\\"\\n\xa0\xa0}\\n\xa0}\\n}\\n```\\n\\nAfter using the KCL Import tool, the output KCL code is as follows:\\n\\n```python\\nschema\xa0Customer:\\n\xa0\xa0\xa0\xa0\\"\\"\\"\\n\xa0\xa0\xa0\xa0Customer\\n\\n\xa0\xa0\xa0\xa0Attributes\\n\xa0\xa0\xa0\xa0----------\\n\xa0\xa0\xa0\xa0name:\xa0str,\xa0optional\\n\xa0\xa0\xa0\xa0address:\xa0Address,\xa0optional\\n\xa0\xa0\xa0\xa0\\"\\"\\"\\n\\n\xa0\xa0\xa0\xa0name?:\xa0str\\n\xa0\xa0\xa0\xa0address?:\xa0Address\\n\\nschema\xa0Address:\\n\xa0\xa0\xa0\xa0\\"\\"\\"\\n\xa0\xa0\xa0\xa0Address\\n\\n\xa0\xa0\xa0\xa0Attributes\\n\xa0\xa0\xa0\xa0----------\\n\xa0\xa0\xa0\xa0city:\xa0str,\xa0optional\\n\xa0\xa0\xa0\xa0state:\xa0State,\xa0optional\\n\xa0\xa0\xa0\xa0\\"\\"\\"\\n\\n\xa0\xa0\xa0\xa0city?:\xa0str\\n\xa0\xa0\xa0\xa0state?:\xa0State\\n\\nschema\xa0State:\\n\xa0\xa0\xa0\xa0\\"\\"\\"\\n\xa0\xa0\xa0\xa0State\\n\\n\xa0\xa0\xa0\xa0Attributes\\n\xa0\xa0\xa0\xa0----------\\n\xa0\xa0\xa0\xa0name:\xa0str,\xa0optional\\n\xa0\xa0\xa0\xa0\\"\\"\\"\\n\\n\xa0\xa0\xa0\xa0name?:\xa0str\\n```\\n\\n### Helmfile KCL Plugin\\n\\nHelmfile is a declarative specification and tool for deploying Helm Charts. With the Helmfile KCL plugin, you can:\\n\\n+ Edit or verify Helm Chart through non-invasive hook methods, separating the data and logic parts of Kubernetes configuration management\\n  + Modify resource labels/annotations, inject sidecar container configuration\\n  + Use KCL schema to validate resources\\n  + Define your own abstract application models\\n+ Maintain multiple environment and tenant configurations elegantly, rather than simply copying and pasting.\\n\\nHere is a detailed explanation using a simple example. With the Helmfile KCL plugin, you do not need to install any components related to KCL. You only need the latest version of the Helmfile tool on your local device.\\n\\nWe can write a `helmfile.yaml` file as follows:\\n\\n```yaml\\nrepositories:\\n-\xa0name:\xa0prometheus-community\\n\xa0\xa0url:\xa0https://prometheus-community.github.io/helm-charts\\n\\nreleases:\\n-\xa0name:\xa0prom-norbac-ubuntu\\n\xa0\xa0namespace:\xa0prometheus\\n\xa0\xa0chart:\xa0prometheus-community/prometheus\\n\xa0\xa0set:\\n\xa0\xa0-\xa0name:\xa0rbac.create\\n\xa0\xa0\xa0\xa0value:\xa0false\\n\xa0\xa0transformers:\\n\xa0\xa0#\xa0Use\xa0KCL\xa0Plugin\xa0to\xa0mutate\xa0or\xa0validate\xa0Kubernetes\xa0manifests.\\n\xa0\xa0-\xa0apiVersion:\xa0krm.kcl.dev/v1alpha1\\n\xa0\xa0\xa0\xa0kind:\xa0KCLRun\\n\xa0\xa0\xa0\xa0metadata:\\n\xa0\xa0\xa0\xa0\xa0\xa0name:\xa0\\"set-annotation\\"\\n\xa0\xa0\xa0\xa0\xa0\xa0annotations:\\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0config.kubernetes.io/function:\xa0|\\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0container:\\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0image:\xa0docker.io/kcllang/kustomize-kcl:v0.2.0\\n\xa0\xa0\xa0\xa0spec:\\n\xa0\xa0\xa0\xa0\xa0\xa0source:\xa0|\\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0[resource\xa0|\xa0{if\xa0resource.kind\xa0==\xa0\\"Deployment\\":\xa0metadata.annotations:\xa0{\\"managed-by\\"\xa0=\xa0\\"helmfile-kcl\\"}}\xa0for\xa0resource\xa0in\xa0option(\\"resource_list\\").items]\\n```\\n\\nIn the above file, we referenced the Prometheus Helm Chart and injected the `managed-by=\\"helmfile-kcl\\"` label into all deployment resources of Prometheus with just one line of KCL code. The following command can be used to deploy the above configuration to the Kubernetes cluster:\\n\\n```shell\\nhelmfile\xa0apply\\n```\\n\\nFor more use cases, please refer to [https://github.com/kcl-lang/krm-kcl](https://github.com/kcl-lang/krm-kcl)\\n\\n## Resources\\n\\n\u2764\ufe0f Thanks to all KCL users and community members for their valuable feedback and suggestions in the community. We will write more articles on the new features of KCL v0.5.x, so stay tuned!\\n\\nFor more resources, please refer to\\n\\n- [KCL Website](https://kcl-lang.io/)\\n- [KusionStack Website](https://kusionstack.io/)\\n\\n- [KCL 2023 Roadmap](https://kcl-lang.io/docs/community/release-policy/roadmap)\\n- [KCL v0.6.0 Milestone](https://github.com/kcl-lang/kcl/milestone/6)\\n- [KCL Github Issues](https://github.com/kcl-lang/kcl/issues)\\n- [KCL Github Discussion](https://github.com/orgs/kcl-lang/discussions)\\n- [KCL Community](https://github.com/kcl-lang/community)\\n- [KCL v0.5.0 Release](https://github.com/kcl-lang/kcl/releases/tag/v0.5.0)\\n- [KCL v0.5.1 Release](https://github.com/kcl-lang/kcl/releases/tag/v0.5.1)\\n- [KCL v0.5.2\xa0Release](https://github.com/kcl-lang/kcl/releases/tag/v0.5.2)"},{"id":"2023-07-31-kcl-github-argocd-gitops","metadata":{"permalink":"/blog/2023-07-31-kcl-github-argocd-gitops","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-07-31-kcl-github-argocd-gitops/index.md","source":"@site/blog/2023-07-31-kcl-github-argocd-gitops/index.md","title":"Implementing GitOps using Github, Argo CD, and KCL to Simplify DevOps","description":"Introduction","date":"2023-07-31T00:00:00.000Z","formattedDate":"July 31, 2023","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Github","permalink":"/blog/tags/github"},{"label":"ArgoCD","permalink":"/blog/tags/argo-cd"},{"label":"GitOps","permalink":"/blog/tags/git-ops"}],"readingTime":8.16,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2023-07-31-kcl-github-argocd-gitops","title":"Implementing GitOps using Github, Argo CD, and KCL to Simplify DevOps","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["KCL","Github","ArgoCD","GitOps"]},"prevItem":{"title":"KCL Biweekly Newsletter (2023 07.26 - 08.09) | KCL v0.5.1 and v0.5.2 is out!","permalink":"/blog/2023-08-09-biweekly-newsletter"},"nextItem":{"title":"KCL Introduction Slides","permalink":"/blog/2023-07-18-kcl-intro-slides"}},"content":"## Introduction\\n\\nIn modern software development, GitOps, as a single truth automation method for managing infrastructure and applications, plays a key role in improving efficiency and reducing Human error, and is now widely popular in cloud-native and other fields. However, there are not many practical examples related to GitOps. This blog will use KCL, Github and ArgoCD as examples to introduce GitOps in detail, hoping to help everyone practice their own GitOps automation process and simplify DevOps.\\n\\n### What is GitOps\\n\\nGitOps is a modern way to do continuous delivery. Its core idea is to have a Git repository which contains environmental and application configurations. An automated process is also needed for sync the config to cluster.\\n\\nBy changing the files in repository, developers can apply the applications automatically. The benefits of applying GitOps include:\\n\\n+ Increased productivity. Continuous delivery can speed up the time of deployment.\\n+ Lower the barrier for developer to deploy. By pushing code instead of container configuration, developers can easily deploy Kubernetes without knowing its internal implementation.\\n+ Trace the change records. Managing the cluster with Git makes every change traceable, enhancing the audit trail.\\n+ Recover the cluster with Git\'s rollback and branch.\\n\\n### GitOps with KCL\\n\\nBenefits of Using KCL and ArgoCD Together:\\n\\n+ KCL can help us **simplify complex Kubernetes deployment configuration files**, reduce the error rate of manually writing YAML files, control configuration constraint checking during compilation, and perceive errors immediately upon writing; At the same time, KCL can be used to eliminate redundant configuration templates, enhance the scalability of multi-environment and multi-tenant configurations, and improve the readability and maintainability of configurations.\\n+ ArgoCD can **automate** the deployment of Kubernetes applications, achieve continuous deployment, and provide comprehensive monitoring and control functions.\\n+ By combining KCL and ArgoCD, deployment efficiency can be improved, errors reduced, and management and monitoring of Kubernetes applications strengthened.\\n+ The combination of KCL and ArgoCD can also help us achieve **Infrastructure as Code (IaC)**, simplify application deployment and management, and better implement DevOps principles.\\n\\nWith GitOps, developer and operation teams can manage application deployment and configuration by modifying KCL code and generating YAML files. The GitOps toolchain will automatically synchronize the changes to the Kubernetes cluster, enabling continuous deployment and ensuring consistency. If there are issues, the GitOps toolchain can be used to quickly rollback.\\n\\n## Workflow\\n\\nWe hope to implement the end-to-end application development process by using containers, Continuous Integration (CI) for generation, and GitOps for Continuous Deployment (CD). In this scheme, we use a **Flask application** and **Github Actions** as examples.\\n\\n> Note: You can use any containerized application and different CI systems such as **Gitlab CI**, **Jenkins CI**, etc. in this solution.\\n\\nWe divide the Python Flask application code and configuration code into two repos, *to achieve the separation of concerns of different roles, such as developers and operation and maintenance teams*\\n\\n+ App code repo: https://github.com/kcl-lang/flask-demo\\n+ Config manifest repo: https://github.com/kcl-lang/flask-demo-kcl-manifests\\n\\nThe overall workflow is as follows:\\n\\n![workflow](/img/blog/2023-07-31-kcl-github-argocd-gitops/workflow.jpg)\\n\\n1. Pull application code from Github.\\n2. Develop and submit application code to the GitHub repository.\\n3. Trigger GitHub Actions to compile the application code, generate container images, and push the container images to the Docker Hub container registry.\\n4. Trigger GitHub Actions to synchronously update the Kubernetes manifest files defined by KCL based on the version of the container image in the `docker.io` container registry.\\n5. ArgoCD obtains Kubernetes manifest changes and updates deployment to Kubernetes cluster.\\n\\n## Steps\\n\\n### 0. Prerequisite\\n\\n+ Familiar with the basic commands of Unix/Linux\\n+ Familiar with Git and Github Action\\n+ Understand the basics of Kubernetes\\n+ Understand tools such as ArgoCD\\n+ Understand the basic knowledge of KCL\\n\\n### 1. Setup Kubernetes Cluster\\n\\n+ Install [K3d](https://github.com/k3d-io/k3d) to create a default cluster.\\n\\n```bash\\nk3d cluster create mycluster\\n```\\n\\n> Note: You can use other methods in this solution to create your own Kubernetes cluster, such as `kind`, `minikube`, etc.\\n\\n### 2. Setup ArgoCD\\n\\n#### Setup ArgoCD Controllers\\n\\n+ Install [ArgoCD](https://github.com/argoproj/argo-cd/releases/).\\n\\n```bash\\nkubectl create namespace argocd\\nkubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml\\n```\\n\\n+ Enable ArgoCD KCL Plugin\\n\\nWrite the patch YAML configuration file and update the ArgoCD configuration:\\n\\n```bash\\ngit clone https://github.com/kcl-lang/kcl-lang.io.git/ && cd ./kcl-lang.io/examples/gitops\\nkubectl apply -f ./install/kcl-cmp.yaml\\n```\\n\\nAfter completing the first step, ArgoCD will recognize the KCL plugin, but the KCL plugin has not been loaded into the ArgoCD image. To implement configuration drift detection, we have to tune the Deployment of argocd-repo-server.\\n\\n```bash\\nkubectl -n argocd patch deploy/argocd-repo-server -p \\"$(cat ./install/patch-argocd-repo-server.yaml)\\"\\n```\\n\\nWait for the init container to complete execution (Running).\\n\\n```bash\\nkubectl get pod -n argocd -l app.kubernetes.io/name=argocd-repo-server\\n```\\n\\n+ To access the ArgoCD web UI\\n\\n```bash\\nkubectl port-forward svc/argocd-server -n argocd 8080:443\\n```\\n\\n+ Open a browser and go to: `https://localhost:8080`\\n\\n+ The username is \\"admin\\" and password get be obtained from the following command:\\n\\n```bash\\nkubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath=\\"{.data.password}\\" | base64 -d\\n```\\n\\n#### Setup ArgoCD CLI\\n\\n+ Install [ArgoCD CLI](https://github.com/argoproj/argo-cd/releases)\\n\\nUse \\"admin\\" and password to login to ArgoCD\\n\\n```bash\\nargocd login localhost:8080\\n```\\n\\nCreate ArgoCD Application\\n\\n```bash\\nargocd app create flaskdemo \\\\\\n--repo https://github.com/kcl-lang/flask-demo-kcl-manifests \\\\\\n--path . \\\\\\n--dest-namespace default \\\\\\n--dest-server https://kubernetes.default.svc \\\\\\n--config-management-plugin kcl-v1.0\\n```\\n\\nAfter successfully creating, you can see the following output:\\n\\n```bash\\napplication \'flaskdemo\' created\\n```\\n\\n> If you are using a private repository, you need to configure the private repository access with private key credentials before executing the create command.Please refer [Private Repositories](https://argo-cd.readthedocs.io/en/stable/user-guide/private-repositories/#ssh-private-key-credential) for more details.\\n\\nThrough the ArgoCD UI, you can see that the created applications have not been synchronized yet. Here, you can manually synchronize or set automatic synchronization.\\n\\n![](/img/docs/user_docs/guides/gitops/argocd-kcl-app.jpg)\\n\\nFor more information on synchronization strategies, see [Sync Options](https://argo-cd.readthedocs.io/en/stable/user-guide/sync-options/)\\n\\n![](/img/docs/user_docs/guides/gitops/argocd-kcl-app-dashboard.jpg)\\n\\n### 3. Get the Application Code\\n\\n```shell\\ngit clone https://github.com/kcl-lang/flask-demo.git/\\ncd flask-demo\\n```\\n\\nThis is a web application written in Python. We can use the `Dockerfile` in the application directory to generate a container image of this application, and also use Github CI to automatically build a image named `flask_demo`, the CI configuration is as follows\\n\\n```yaml\\n# This is a basic workflow to help you get started with Actions\\n\\nname: CI\\n\\n# Controls when the workflow will run\\non:\\n  # Triggers the workflow on push or pull request events but only for the main branch\\n  push:\\n    branches: [ main ]\\n  pull_request:\\n    branches: [ main ]\\n\\n  # Allows you to run this workflow manually from the Actions tab\\n  workflow_dispatch:\\n\\n# A workflow run is made up of one or more jobs that can run sequentially or in parallel\\njobs:\\n  # This workflow contains a single job called \\"build\\"\\n  build:\\n    # The type of runner that the job will run on\\n    runs-on: ubuntu-latest\\n\\n    # Steps represent a sequence of tasks that will be executed as part of the job\\n    steps:\\n      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it\\n      - uses: actions/checkout@v2\\n      \\n      - name: Docker Login\\n        uses: docker/login-action@v1.10.0\\n        with:\\n          username: ${{ secrets.DOCKER_USERNAME }}\\n          password: ${{ secrets.DOCKER_PASSWORD }}\\n          logout: true\\n\\n      # Runs a set of commands using the runners shell\\n      - name: build image\\n        run: |\\n          make image\\n          docker tag flask_demo:latest ${{ secrets.DOCKER_USERNAME }}/flask_demo:${{ github.sha }}\\n          docker push ${{ secrets.DOCKER_USERNAME }}/flask_demo:${{ github.sha }}\\n\\n      # Trigger KCL manifest\\n      - name: Trigger CI\\n        uses: InformaticsMatters/trigger-ci-action@1.0.1\\n        with:\\n          ci-owner: kcl-lang\\n          ci-repository: flask-demo-kcl-manifests\\n          ci-ref: refs/heads/main\\n          ci-user: kcl-bot\\n          ci-user-token: ${{ secrets.DEPLOY_ACCESS_TOKEN }}\\n          ci-name: CI\\n          ci-inputs: >-\\n            image=${{ secrets.DOCKER_USERNAME }}/flask_demo\\n            sha-tag=${{ github.sha }}\\n```\\n\\nWe need the workflow in the source code repository to automatically trigger the workflow in the deployment manifest repository. At this point, we need to create a `secrets.DEPLOY_ACCESS_TOKEN` with Github CI operation permissions and **Docker Hub** image push account information `secrets.DOCKER_USERNAME` and `secrets.DOCKER_PASSWORD`  can be configured in the `Secrets and variables` settings of the Github, as shown in the following figure\\n\\n![](/img/docs/user_docs/guides/ci-integration/github-secrets.png)\\n\\n### 4. Commit the Application Code\\n\\nAfter submitting in the `flask-demo` repository, Github will automatically build a container image and push it to the Docker hub. It will also then trigger the Action of the `flask-demo-kcl-manifest` repository and modify the image value in the deployment manifest repository through [KCL Automation API](/docs/user_docs/guides/automation). Now let\'s create a submission in the `flask-demo` repository, and we can see that the code submission triggers the Github CI process for the application repository.\\n\\n![](/img/docs/user_docs/guides/ci-integration/app-ci.png)\\n\\n### 5. Configuration Automatic Update\\n\\nAfter the Github CI process in the application repository is completed, an automatic update configuration CI will be triggered in the repository where the KCL configuration is stored and submitted to the main branch of the `flask-demo-kcl-manifests` repository. The commit information is as follows\\n\\n![](/img/docs/user_docs/guides/ci-integration/image-auto-update.png)\\n\\n+ We can obtain the deployment manifest source code for compilation and validation\\n\\n```shell\\ngit clone https://github.com/kcl-lang/flask-demo-kcl-manifests.git/\\ncd flask-demo-kcl-manifests\\ngit checkout main && git pull && kcl\\n```\\n\\nThe output YAML is\\n\\n```yaml\\napiVersion: apps/v1\\nkind: Deployment\\nmetadata:\\n  name: flask_demo\\n  labels:\\n    app: flask_demo\\nspec:\\n  replicas: 1\\n  selector:\\n    matchLabels:\\n      app: flask_demo\\n  template:\\n    metadata:\\n      labels:\\n        app: flask_demo\\n    spec:\\n      containers:\\n        - name: flask_demo\\n          image: \\"kcllang/flask_demo:6428cff4309afc8c1c40ad180bb9cfd82546be3e\\"\\n          ports:\\n            - protocol: TCP\\n              containerPort: 5000\\n---\\napiVersion: v1\\nkind: Service\\nmetadata:\\n  name: flask_demo\\n  labels:\\n    app: flask_demo\\nspec:\\n  type: NodePort\\n  selector:\\n    app: flask_demo\\n  ports:\\n    - port: 5000\\n      protocol: TCP\\n      targetPort: 5000\\n```\\n\\nFrom the above configuration, it can be seen that the image of the resource is indeed automatically updated to the newly constructed image value. In addition, we can also use the **Argo CD KCL plugin** to automatically synchronize data from the Git repository and deploy the application to the Kubernetes cluster.\\n\\n## Conclusion\\n\\nThrough the blog, we can use Github, ArgoCD, and KCL to create GitOps automated pipelines, which can efficiently and stably build containerized applications, while automatically updating the latest Dbroker image labels and keeping Git configuration consistent with cluster configuration. In addition, the combination of KCL and ArgoCD can help us better realize Infrastructure as Code (IaC), improve deployment efficiency, achieve the separation of concerns of different roles, and simplify the configuration management of applications."},{"id":"2023-07-18-kcl-intro-slides","metadata":{"permalink":"/blog/2023-07-18-kcl-intro-slides","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-07-18-kcl-intro-slides/index.md","source":"@site/blog/2023-07-18-kcl-intro-slides/index.md","title":"KCL Introduction Slides","description":"Download PDF","date":"2023-07-18T00:00:00.000Z","formattedDate":"July 18, 2023","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Configuration","permalink":"/blog/tags/configuration"}],"readingTime":0.01,"hasTruncateMarker":false,"authors":[{"name":"Pengfei, Xu","title":"KCL Team Member"}],"frontMatter":{"slug":"2023-07-18-kcl-intro-slides","title":"KCL Introduction Slides","authors":{"name":"Pengfei, Xu","title":"KCL Team Member"},"tags":["KCL","Configuration"]},"prevItem":{"title":"Implementing GitOps using Github, Argo CD, and KCL to Simplify DevOps","permalink":"/blog/2023-07-31-kcl-github-argocd-gitops"},"nextItem":{"title":"KCL v0.5.0 Release Blog","permalink":"/blog/2022-kcl-0.5.0-release-blog"}},"content":"[Download PDF](https://kcl-lang.github.io/talks/kcl-intro.pdf)"},{"id":"2022-kcl-0.5.0-release-blog","metadata":{"permalink":"/blog/2022-kcl-0.5.0-release-blog","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-07-14-kcl-0.5.0-release/index.md","source":"@site/blog/2023-07-14-kcl-0.5.0-release/index.md","title":"KCL v0.5.0 Release Blog","description":"Introduction","date":"2023-07-14T00:00:00.000Z","formattedDate":"July 14, 2023","tags":[{"label":"Release Blog","permalink":"/blog/tags/release-blog"},{"label":"KCL","permalink":"/blog/tags/kcl"}],"readingTime":12.21,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2022-kcl-0.5.0-release-blog","title":"KCL v0.5.0 Release Blog","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["Release Blog","KCL"]},"prevItem":{"title":"KCL Introduction Slides","permalink":"/blog/2023-07-18-kcl-intro-slides"},"nextItem":{"title":"Rewrite KCL LSP in Rust","permalink":"/blog/2023/07/10/kcl-LSP"}},"content":"\x3c!-- KCL v0.5.0 is Coming - Better Language, Toolchain, Integrations for Cloud Native --\x3e\\n\\n## Introduction\\n\\nThe KCL team is pleased to announce that KCL v0.5.0 is now available! This release has brought three key updates to everyone: **Language**, **Tools**, and **Integrations**.\\n\\n+ *Use KCL language and IDE with more complete features and fewer errors to improve code writing experience and efficiency.*\\n+ *Use KPM, KCL OpenAPI, OCI Registry and other tools to directly use and share your cloud native domain models, reducing learning and hands-on costs.*\\n+ *Using community tools such as Github Action, ArgoCD, and Kubectl KCL plugins to integrate and extend support to improve automation efficiency.*\\n\\nYou can visit the [KCL release page](https://github.com/kcl-lang/kcl/releases/tag/v0.5.0) or the [KCL website](https://kcl-lang.io/) to get KCL binary download link and more detailed release information.\\n\\n[KCL](https://github.com/kcl-lang/kcl) is an open-source, constraint-based record and functional language. KCL improves the writing of numerous complex configurations, such as cloud-native scenarios, through its mature programming language technology and practice. It is dedicated to building better modularity, scalability, and stability around configurations, simpler logic writing, faster automation, and great built-in or API-driven integrations.\\n\\nThis blog will introduce the content of KCL v0.5.0 and recent developments in the KCL community to readers.\\n\\n## Language\\n\\n### Top-level Variable Output\\n\\nIn previous versions of KCL, running the following KCL code will not output YAML. In KCL v0.5.0, we improved this and supported exporting top-level variables to YAML configuration to reduce additional KCL code and command-line parameters, such as for the following KCL code (main.k)\\n\\n```python\\nschema Nginx:\\n    http: Http\\n\\nschema Http:\\n    server: Server\\n\\nschema Server:\\n    listen: int | str\\n    location?: Location\\n\\nschema Location:\\n    root: str\\n    index: str\\n\\nNginx {  # Nginx will be output\\n    http.server = {\\n        listen = 80\\n        location = {\\n            root = \\"/var/www/html\\"\\n            index = \\"index.html\\"\\n        }\\n    }\\n}\\n```\\n\\nIn the new version, running KCL code can directly obtain the following output\\n\\n```yaml\\n$ kcl main.k\\nhttp:\\n  server:\\n    listen: 80\\n    location:\\n      root: /var/www/html\\n      index: index.html\\n```\\n\\nSee [here](https://github.com/kcl-lang/kcl/pull/556) for more.\\n\\n### Index Signature\\n\\nIn previous versions of KCL, running the KCL command-line tool once only displayed one error message and warning. In KCL v0.5.0, it supported the ability to display multiple errors and warnings in one compilation and improved error information to improve the efficiency of KCL code error troubleshooting, such as for the following KCL code (main.k).\\n\\n```python\\nschema TeamSpec:\\n    fullName: str\\n    name = id\\n    shortName: str = name\\n\\nschema TeamMap:\\n    [n: str]: TeamSpec = TeamSpec {\\n        name = n  # n is the schema index signature key alias, we can use it directly\\n    }\\n\\nteamMap = TeamMap {\\n    a.fullName = \\"alpha\\"\\n    b.fullName = \\"bravo\\"\\n}\\n```\\n\\nIn the new version, running KCL code can directly obtain the following output.\\n\\n```shell\\n$ kcl main.k\\nteamMap:\\n  b:\\n    fullName: bravo\\n    name: b\\n    shortName: b\\n  a:\\n    fullName: alpha\\n    name: a\\n    shortName: a\\n```\\n\\nSee [here](https://github.com/kcl-lang/kcl/pull/582) for more.\\n\\n### Runtime Backtrace Output\\n\\nIn previous versions of KCL, when writing the following KCL code, the two schema configurations with the same name were merged and output. In KCL v0.5.0, it was required to explicitly use the attribute merge operator instead of the attribute overlay operator.\\n\\n```python\\nschema Fib:\\n    n1 = n - 1\\n    n2 = n1 - 1\\n    n: int\\n    value: int\\n\\n    if n <= 1:\\n        value = [][n]  # There is a index overflow runtime error.\\n    elif n == 2:\\n        value = 1\\n    else:\\n        value = Fib {n = n1}.value + Fib {n = n2}.value\\n\\nfib8 = Fib {n = 4}.value\\n```\\n\\nAfter execution, we will receive the following error message\\n\\n```shell\\n$ kcl main.k -d\\nerror[E3M38]: EvaluationError\\nEvaluationError\\n --\x3e main.k:8\\n  |\\n8 |         value = [][n]  # There is a index overflow runtime error.\\n  |  list index out of range: 1\\n  |\\nnote: backtrace:\\n        1: __main__.Fib\\n                at main.k:8\\n        2: __main__.Fib\\n                at main.k:12\\n        3: __main__.Fib\\n                at main.k:12\\n        4: main\\n                at main.k:14\\n```\\n\\nSee [here](https://github.com/kcl-lang/kcl/pull/528) for more.\\n\\n### Bugfix\\n\\n#### Type Error in Filter Expressions\\n\\nBefore KCL v0.5.0, filter expressions returned incorrect types (should return the type of the iterator instead of the type of the iterated object). In KCL v0.5.0, we fixed similar issues.\\n\\n```python\\nschema Student:\\n    name: str\\n    grade: int\\n\\nstudents: [Student] = [\\n    {name = \\"Alice\\", grade = 85}\\n    {name = \\"Bob\\", grade = 70}\\n]\\n\\nstudentsGrade70: [Student] = filter s in students {\\n    s.grade == 70\\n}  # Previously, we received a type mismatch error here. In KCL v0.5.0, we fixed similar issues.\\n```\\n\\nSee [here](https://github.com/kcl-lang/kcl/pull/546) for more.\\n\\n#### Lambda Closure Error\\n\\nIn previous versions of KCL, for the following KCL code, there was an error where the `versions` attribute was not assigned as expected. In KCL v0.5.0, we fixed similar issues.\\n\\n```python\\nz = 1\\nadd = lambda x { lambda y { x + y + z} }  # `x` is the closure of the inner lambda.\\nres = add(1)(1)  # 3\\n```\\n\\nSee [here](https://github.com/kcl-lang/kcl/pull/548) for more.\\n\\n#### String Literal Union Type Error Containing UTF-8 Characters\\n\\nIn previous versions of KCL, using string literal union type that contains UTF-8 characters resulted in an unexpected type error. In KCL v0.5.0 version, we fixed similar issues like this.\\n\\n```python\\nmsg: \\"\u65e0\u9700\u5bb9\u707e\\" | \\"\u6807\u51c6\u578b\\" | \\"\u6d41\u6c34\u578b\\" = \\"\u6d41\u6c34\u578b\\"\\n```\\n\\nSee [here](https://github.com/kcl-lang/kcl/pull/600) for more.\\n\\n## Tools & IDE\\n\\n### KCL OpenAPI Tool\\n\\nThe kcl-openapi command-line tool supports conversion from OpenAPI Spec to KCL code. Installation can be obtained through `go install` or `curl`:\\n\\n```bash\\n# go install\\ngo install kcl-lang.io/kcl-openapi@latest\\n\\n# curl install (MacOS & Linux)\\ncurl -fsSL https://kcl-lang.io/script/install-kcl-openapi.sh | /bin/bash\\n```\\n\\n#### Kubernetes KCL Package Conversion Optimization\\n\\nThe v0.5.0 version optimizes the experience of using Kubernetes KCL packages:\\n+ Built-in Kubernetes package: KCL provides out of the box KCL packages for Kubernetes 1.14-1.27 versions, which can be obtained through the package management tool `kpm pull k8s:<version>`.\\n+ If you need to convert other Kubernetes versions of the KCL model on your own, you can use the following preprocessing script to convert the `swagger.json` file downloaded from the Kubernetes repository into the KCL package. Change 1.27 of the following command to the desired Kubernetes version.\\n\\n```bash\\nversion=1.27\\nspec_path=swagger.json\\nscript_path=main.py\\nwget https://raw.githubusercontent.com/kubernetes/kubernetes/release-${version}/api/openapi-spec/swagger.json -O swagger.json\\nwget https://raw.githubusercontent.com/kcl-lang/kcl-openapi/main/scripts/preprocess/main.py -O main.py\\npython3 ${script_path} ${spec_path} --omit-status --rename=io.k8s=k8s\\nkcl-openapi generate model -f processed-${spec_path}\\n```\\n\\nThe expected execution output of the script is the corresponding version of the KCL Kubernetes model, and the generated path is `<workspace path>/models/k8s`.\\n\\n```shell\\n$ tree models/k8s\\nmodels/k8s\\n\u251c\u2500\u2500 api\\n\u2502   \u251c\u2500\u2500 admissionregistration\\n\u2502   \u2502   \u251c\u2500\u2500 v1\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 match_condition.k\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 mutating_webhook.k\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 mutating_webhook_configuration.k\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 mutating_webhook_configuration_list.k\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 rule_with_operations.k\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 service_reference.k\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 validating_webhook.k\\n...\\n```\\n\\n#### Bugfix\\n\\n+ Escape attribute names with the `-` character as `_` to comply with KCL v0.5.0 syntax, [see details](https://github.com/kcl-lang/kcl-openapi/pull/43)\\n+ Automatically recognize and set import as reference aliases to avoid reference conflicts, [see details](https://github.com/kcl-lang/kcl-openapi/pull/45)\\n+ Fix the issue of attribute description indentation in docstring, and automatically indent the internal line breaks of attribute descriptions. [See details](https://github.com/kcl-lang/kcl-openapi/pull/46)\\n+ Fix the generated reference path to be the full reference path based on the root directory of the package, [see details](https://github.com/kcl-lang/kcl-openapi/pull/51)\\n\\n### Package Management Tool\\n\\nIn the new version of KCL v0.5.0, we have provided a new KCL package management tool, which allows users to access the KCL modules in the community with a few commands.\\n\\n#### Managing KCL Programs through the kpm Tool\\n\\nBefore using kpm, it is necessary to ensure that you are currently working in a KCL package. You can use the command kpm init to create a standard KCL package.\\n\\n```shell\\nkpm init kubernetes_demo && cd kubernetes_demo && kpm add k8s\\n```\\n\\nWrite a KCL code to import the Kubernetes models (main.k).\\n\\n```python\\nimport k8s.api.apps.v1 as apps\\n\\napps.Deployment {\\n    metadata.name = \\"nginx-deployment\\"\\n    spec = {\\n        replicas = 3\\n        selector.matchLabels.app = \\"nginx\\"\\n        template.metadata.labels = selector.matchLabels\\n        template.spec.containers = [\\n            {\\n                name = selector.matchLabels.app\\n                image = \\"nginx:1.14.2\\"\\n                ports = [\\n                    {containerPort = 80}\\n                ]\\n            }\\n        ]\\n    }\\n}\\n```\\n\\nBy combining the `kpm run` and `kubectl` command lines, we can directly distribute resource configurations to the cluster.\\n\\n```shell\\n$ kpm run | kubectl apply -f -\\n\\ndeployment.apps/nginx-deployment configured\\n```\\n\\n#### OCI Registry\\n\\nThe kpm tool supports pushing KCL packages through OCI Registry. The default OCI Registry currently provided by kpm is [https://github.com/orgs/kcl-lang/packages](https://github.com/orgs/kcl-lang/packages).\\n\\nYou can browse the KCL package you need here. We currently provide the KCL package for k8s, which supports all versions of k8s from 1.14 to 1.27. Welcome to open [Issues](https://github.com/kcl-lang/kpm/issues) to co build KCL models.\\n\\nSee [here](https://kcl-lang.io/docs/user_docs/guides/package-management/overview) for more information about the **kpm** tool.\\n\\n## Integrations\\n\\n### CI Integrations\\n\\nIn the new version of KCL, we have provided an example scheme of **Github Actions as the CI integration**. We hope to implement the end-to-end application development process by using containers, Continuous Integration (CI) for configuration generation, and GitOps for Continuous Deployment (CD). The overall workflow is as follows:\\n\\n+ Develop application code and submit it to the GitHub repository to trigger CI (using Python Flask web application as an example).\\n\\n![app](/img/blog/2023-07-14-kcl-0.5.0-release/app.png)\\n\\n+ GitHub Actions generate container images from application code and push them to the `docker.io` container registry.\\n\\n![app-ci](/img/blog/2023-07-14-kcl-0.5.0-release/app-ci.png)\\n\\n+ GitHub Actions automatically synchronizes and updates the KCL manifest deployment file based on the version of the container image in the docker.io container registry.\\n\\n![auto-update](/img/blog/2023-07-14-kcl-0.5.0-release/auto-update.png)\\n\\nWe can obtain the deployment manifest source code for compilation and verification, and the following YAML output will be obtained\\n\\n```yaml\\napiVersion: apps/v1\\nkind: Deployment\\nmetadata:\\n  name: flask_demo\\n  labels:\\n    app: flask_demo\\nspec:\\n  replicas: 1\\n  selector:\\n    matchLabels:\\n      app: flask_demo\\n  template:\\n    metadata:\\n      labels:\\n        app: flask_demo\\n    spec:\\n      containers:\\n        - name: flask_demo\\n          image: \\"kcllang/flask_demo:6428cff4309afc8c1c40ad180bb9cfd82546be3e\\"\\n          ports:\\n            - protocol: TCP\\n              containerPort: 5000\\n---\\napiVersion: v1\\nkind: Service\\nmetadata:\\n  name: flask_demo\\n  labels:\\n    app: flask_demo\\nspec:\\n  type: NodePort\\n  selector:\\n    app: flask_demo\\n  ports:\\n    - port: 5000\\n      protocol: TCP\\n      targetPort: 5000\\n```\\n\\nFrom the above configuration, it can be seen that the image of the resource is indeed automatically updated to the newly constructed image content. In addition, we can also use the Argo CD KCL plugin to automatically synchronize data from the Git repository and deploy the application to the Kubernetes cluster.\\n\\nFor more details, please refer to [here](https://kcl-lang.io/docs/user_docs/guides/ci-integration/github-actions)\\n\\n### CD Integrations\\n\\nIn addition, we also provide **ArgoCD as an example solution for CD integration**. Through Github Action CI integration and ArgoCD KCL plugin, we can complete end-to-end GitOps workflow, improve application configuration automatic change and deployment efficiency. The following is an overview and synchronization of Kubernetes configuration using ArgoCD application. By using ArgoCD\'s ability, when application code changes, it is automatically updated and deployed synchronously.\\n\\n+ **Application Overview**\\n\\n![argocd-app](/img/blog/2023-07-14-kcl-0.5.0-release/argocd-app.png)\\n\\n+ **Configuration Synchronization**\\n\\n![argocd-sync](/img/blog/2023-07-14-kcl-0.5.0-release/argocd-sync.png)\\n\\nFor more details, please refer to [here](https://kcl-lang.io/docs/user_docs/guides/gitops/gitops-quick-start)\\n\\n### Kubernetes Configuration Management Tool Plugin\\n\\nIn KCL v0.5.0, we provide KCL plugin support for configuration management tools such as Kubectl, Helm, Kustomize, and KPT in the Kubernetes community through a unified programming interface. By writing a few lines of configuration code, we can non-invasive edit and validate existing Kustomize YAML and Helm Charts, such as modifying resource labels/annotations, injecting sidecar containers, and validate resources using KCL schema, defining your own abstract models and share them, etc.\\n\\nBelow is a detailed explanation of the integration of Kubectl tool with KCL as an example. You can click [here](https://github.com/kcl-lang/kubectl-kcl) to obtain the installation of Kubectl KCL plugin.\\n\\nFirst, execute the following command to obtain a configuration example\\n\\n```shell\\ngit clone https://github.com/kcl-lang/kubectl-kcl.git && cd ./kubectl-kcl/examples/\\n```\\n\\nThen execute the following command to show the configuration\\n\\n```shell\\n$ cat krm-kcl-abstration.yaml\\napiVersion: krm.kcl.dev/v1alpha1\\nkind: KCLRun\\nmetadata:\\n  name: web-service-abtraction\\nspec:\\n  params:\\n    name: app\\n    containers:\\n      ngnix:\\n        image: ngnix\\n        ports:\\n        - containerPort: 80\\n    service:\\n      ports:\\n      - port: 80\\n    labels:\\n      name: app\\n  source: oci://ghcr.io/kcl-lang/web-service\\n```\\n\\nIn the above configuration, we used a Kubernetes web service application abstract model that has been predetermined on OCI `oci://ghcr.io/kcl-lang/web-service` and configured the required configuration fields for the model through the `params` field. The original Kubernetes YAML output can be obtained and applied by executing the following command:\\n\\n```shell\\n$ kubectl kcl apply -f krm-kcl-abstration.yaml\\n\\ndeployment.apps/app created\\nservice/app created\\n```\\n \\nMore detailed introductions and use cases of Kubernetes configuration management tools can be found [here](https://github.com/kcl-lang/krm-kcl/tree/main/examples)\\n\\nAt present, the integration of Kubernetes configuration management tools supported by KCL is still in its early stages. If you have more ideas and requirements, welcome to open issues to discuss.\\n\\n## Other Updates and Bug Fixes\\n\\nSee [here](https://github.com/kcl-lang/kcl/compare/v0.4.6...v0.5.0) for more updates and bug fixes.\\n\\n## Documents\\n\\nThe versioning semantic option is added to the [KCL website](https://kcl-lang.io/). Currently, v0.4.3, v0.4.4, v0.4.5, v0.4.6 and v0.5.0 versions are supported.\\n\\n## Community\\n\\n+ Thank @harri2012 for his first contribution to the KCL IDE plugin \ud83d\ude4c\\n+ Thank @niconical for his contribution to the KCL command line basic code and CI/CD scripts \ud83d\ude4c\\n+ Thank @Ekko for his contribution to the integration of KCL cloud native tools \ud83d\ude4c\\n+ Congratulations to Junxing Zhu his successful selection into the GitLink Programming Summer Camp (GLCC) \\"Terraform/JsonSchema to KCL Schema\\" project \ud83c\udf89\\n+ Congratulations to Yiming Ren on her successful selection of the topic \\"IDE plug-in enhancement and language server integration\\" in the summer of open source \ud83c\udf89\\n+ We have relocated KCL 30+ repos as a whole to the new Github **kcl-lang** organization, keeping the project address in mind [https://github.com/kcl-lang](https://github.com/kcl-lang) \u2764\ufe0f\\n+ KCL\'s joining CNCF Landscape is a small encouragement and recognition from the cloud native community. The next step is to strive to join CNCF Sandbox and make more contributions to the cloud native community \ud83d\udcaa\\n\\n## Next\\n\\nIt is expected that in September 2023, we will release **KCL v0.6.0**. The expected key evolution includes:\\n\\n+ KCL language is further improved for convenience, the user interface is continuously optimized and experience is improved, user support and pain points are solved.\\n+ More IDE extensions, package management tools, Kubernetes scenario integration, feature support, and user experience improvement.\\n+ Provide more out-of-box KCL model support for cloud-native scenarios, mainly including containers, services, computing, storage, and networks.\\n+ More CI/CD integrations such as Jenkins, Gitlab CI, FluxCD, etc.\\n+ Support `helmfile` KCL plugins, directly generating, mutating, and validating Kubernetes resources through the KCL code.\\n+ Support for mutating and validating YAML by running KCL code through the admission controller at the Kubernetes runtime.\\n\\nFor more details, please refer to [KCL 2023 Roadmap](https://kcl-lang.io/docs/community/release-policy/roadmap) and [KCL v0.6.0 Milestone](https://github.com/kcl-lang/kcl/milestone/6).\\n\\nIf you have more ideas and needs, welcome to open [Issues](https://github.com/kcl-lang/kcl/issues) and join our community for communication as well \ud83d\ude4c \ud83d\ude4c \ud83d\ude4c\\n\\n## FAQ\\n\\nFor more information, see [KCL FAQ](https://kcl-lang.io/docs/user_docs/support/).\\n\\n## Additional Resources\\n\\nThank all KCL users for their valuable feedback and suggestions during this version release. For more resources, please refer to:\\n\\n+ [KCL Website](https://kcl-lang.io/)\\n+ [Kusion Website](https://kusionstack.io/)\\n+ [KCL Repo](https://github.com/kcl-lang/kcl)\\n+ [Kusion Repo](https://github.com/KusionStack/kusion)\\n+ [Konfig Repo](https://github.com/KusionStack/konfig)\\n\\nSee the [community](https://github.com/kcl-lang/community) for ways to join us. \ud83d\udc4f\ud83d\udc4f\ud83d\udc4f"},{"id":"/2023/07/10/kcl-LSP","metadata":{"permalink":"/blog/2023/07/10/kcl-LSP","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-07-10-kcl-LSP/index.md","source":"@site/blog/2023-07-10-kcl-LSP/index.md","title":"Rewrite KCL LSP in Rust","description":"The KCL v0.4.6 version has significant updates in language, toolchain, community integration and IDE extension support. In this blog, we\'ll be discussing the features of the KCL IDE extension and introducing the LSP, as well as talking about the design and implementation of the KCL LSP server and our plans and expectations for the future.","date":"2023-07-10T00:00:00.000Z","formattedDate":"July 10, 2023","tags":[],"readingTime":7.545,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"KCL v0.5.0 Release Blog","permalink":"/blog/2022-kcl-0.5.0-release-blog"},"nextItem":{"title":"KCL Introduction on WAIC 2023 Meeting","permalink":"/blog/2023-07-08-kcl-waic-meeting"}},"content":"The KCL v0.4.6 version has significant updates in language, toolchain, community integration and IDE extension support. In this blog, we\'ll be discussing the features of the KCL IDE extension and introducing the LSP, as well as talking about the design and implementation of the KCL LSP server and our plans and expectations for the future.\\n\\n## New Features\\n\\nIn this update, we have released a new KCL VSCode extension and rewritten the LSP server in Rust. We have provided common code assistance features in the IDE, such as highlight, goto definition, completion, outline, hover, diagnostics, and more.\\n\\n- **Syntax Highlight:**\\n  ![Highlight](/img/docs/tools/Ide/vs-code/Highlight.png)\\n- **Goto Definition:** Goto definition of schema, variable, schema attribute, and import pkg.\\n  ![Goto Definition](/img/docs/tools/Ide/vs-code/GotoDef.gif)\\n- **Completion:** Keywords completions and dot(`.`) completion.\\n  ![Completion](/img/docs/tools/Ide/vs-code/Completion.gif)\\n- **Outline:** Main definition(schema def) and variables in KCL file.\\n  ![Outline](/img/docs/tools/Ide/vs-code/Outline.gif)\\n- **Hover:** Identifier information (type and schema documentation).\\n  ![Hover](/img/docs/tools/Ide/vs-code/Hover.gif)\\n- **Diagnostics:** Warnings and errors in KCL file.\\n  ![Diagnostics](/img/docs/tools/Ide/vs-code/Diagnostics.gif)\\n\\nWelcome to [KCL VSCode extension](https://kcl-lang.io/docs/tools/Ide/vs-code/) to learn more. \ud83d\udc4f\ud83d\udc4f\ud83d\udc4f\\n\\n## What is LSP?\\n\\nIn this update, we have implemented the above features based on LSP. LSP stands for Language Server Protocol, which is a protocol for programming language tools that was introduced by Microsoft in 2016. It is easy to understand LSP with a picture on the VSCode website.\\n\\n![LSP](/img/blog/2023-07-10-kcl-LSP/lsp.png)\\n\\nBy LSP, IDE can communicate with the language server which runs on the backend through the JSON-RPC protocol. The language server can provide capabilities such as code analysis, completion, syntax highlighting, and goto definition. Based on LSP, developers can migrate between different editors and IDEs, reducing the development of language tools from M (number of languages) * N (number of editors/IDEs) to M + N.\\n\\n## Why rewrite it in Rust\uff1f\\n\\nThe KCL compiler and other tools were originally implemented in Python, and we rewrote its compiler in Rust for performance reasons. After that, we gradually rewrote other tools of KCL, such as testing and formatting tools. In this update, we also rewrote the LSP in consideration of performance issues.\\n\\nIn the past, when the Python version LSP server was processing some complex scenarios (over 200 files), for a request of goto definition, the server-side took more than about 6 seconds from receiving the request to calculating the result and responding.  It is almost unavailable. Since the implementation of the server side is mainly based on the lexical analysis and semantic analysis of the front-end and middle-end of the compiler. After we rewrite it in Rust, the performance of this part has been improved by 20 and 40 times, and the remarkable result is that the response time of the server has been greatly improved. Boost, for the same scenario, the response time is reduced to around 100 milliseconds. For some simple scenarios, the response time is only a few milliseconds, which makes the user feel indifferent.\\n\\n\\n## Design of KCL LSP\\n\\nThe KCL LSP is designed as follows\uff1a\\n![KCL-LSP](/img/blog/2023-07-10-kcl-LSP/kcl-LSP.png)\\n\\nThe main process can be divided into several stages:\\n\\n1. Initiate a connection and set the LSP capability. In IDE, when opening a specific file (e.g., *.k  for KCL), the IDE will run the local kcl_language_server binary. This binary is distributed with KCL and installed in KCL\'s bin directory. After the Server starts, it will start a standard IO Connection and wait for the initialization request sent by the IDE Client. After receiving the initialization request, the server will define the information and capabilities of the server and return it to the client to complete the initial connection of the LSP.\\n2. After the connection is established, the server will start a polling function to continuously receive LSP messages from the client, such as `Notification` (open/close/change/delete files, etc.) and `Request` (goto definition, hover, etc.), as well as messages from the server itself the Task. And uniformly encapsulated into an event (Event) and handed over to the next step for processing.\\n3. For different events, follow the steps below:\\n\\n```Rust\\n/// Handles an event from one of the many sources that the language server subscribes to.\\nfn handle_event(&mut self, event: Event) -> anyhow::Result<()> {\\n    // 1. Process the incoming event\\n    match event {\\n        Event::Task(task) => self.handle_task(task)?,\\n        Event::Lsp(msg) => match msg {\\n            lsp_server::Message::Request(req) => self.on_request(req, start_time)?,\\n            lsp_server::Message::Notification(not) => self.on_notification(not)?,\\n            _ => {}\\n        },\\n    };\\n\\n    // 2. Process changes\\n    let state_changed: bool = self.process_vfs_changes();\\n\\n    // 3. Handle Diagnostics\\n    if state_changed{\\n        let mut snapshot = self.snapshot();\\n        let task_sender = self.task_sender.clone();\\n        // Spawn the diagnostics in the threadpool\\n        self.thread_pool.execute(move || {\\n            handle_diagnostics(snapshot, task_sender)\uff1f;\\n        });\\n    }\\n\\n    Ok(())\\n}\\n```\\n\\n3.1 Task distribution: According to the task type, the Task is distributed to different sub-functions. In the sub-function, it will be further distributed to the final processing function based on the type of request or notification, such as processing file changes, processing goto definition requests, etc. These functions will analyze the semantic model (AST, symbol table, error information, etc.) compiled based on the front-end of the compiler, calculate and generate the Response (such as the target position of the goto definition request).\\n\\n3.2 Change processing: When the user modifies the code or changes the file, the corresponding Notification will be sent. In the previous step of processing, the changes are saved in the virtual file system (VFS). The server side will recompile according to the new source code and save the new semantic model for processing the next request.\\n\\n3.3 Diagnostics: the diagnostics here do not refer to LSP server, but to the grammatical and semantic errors and warnings when compiling KCL code. The IDE/editor does not have a request to get these errors, but the LSP server actively sends Diagnostics. Therefore, after the change, the error information is updated on the client side synchronously\\n\\n## Problems\\n\\n### 1. Why do we need a virtual file system?\\n\\nIn the original design, the use of a virtual file system was not considered. Each time we fetch the source code from the file system, compile and analyze it. For some \\"static\\" tasks, such as goto definition, you can save the code to the file system after changing, and then find some variables definitions. Cooperating with the automatic save of VS Code, there is no obvious gap in user experience. However, for tasks such as completion, the input of `.` on the IDE/editor will trigger a file change notification and a request for completion, but the code has not been saved in the file system. Therefore, the semantic model cannot be analyzed correctly. Therefore, we realized the virtual file system with the creation of Rust Analyzer\'s vfs and changed the compilation entry from the file path to the source code. After the client enters the code, the file change notification will first update the virtual file system, recompile the file, and then process the completion request.\\n\\n### 2. How to deal with incomplete code?\\n\\nAnother big problem we encountered was how to deal with incomplete code. Likewise, for \\"static\\" tasks, e.g., goto definition, the code can be assumed to be complete and correct. But for the request of completion, such as the following code, I hope to complete the function of the string after entering `.`.For the compilation process, the second line is an incomplete code that cannot be compiled into a normal AST tree.\\n\\n```\\ns: str = \\"hello kcl\\"\\nlen = s.\\n```\\n\\nTo this end, we have implemented a variety of syntactic and semantic error recovery in KCL compilation, ensuring that the compilation process can always produce a complete AST and symbol table. In this example, we added an empty AST node as a placeholder, so that the second line can generate a complete AST. When processing the completion request, it will complete the function name, schema attr or the schema name defined in pkg according to the type of `s` and other semantic information.\\n\\n> Rust Analyzer architecture:\\n> \\n> Architecture Invariant: parsing never fails, the parser produces (T, Vec&lt;Error&gt;) rather than Result&lt;T, Error&gt;.\\n\\n## Summary\\n\\nKCL\'s IDE extension has already implemented capabilities such as highlighting, goto definition, completion, outline, hovering, and diagnostics. These features improve the development efficiency of KCL users. However, as an IDE extension, its functionality is not complete enough. In the future, we will continue to improve its capabilities. Future work has the following aspects:\\n\\n- More capabilities: Provide more capabilities, such as code refactoring, error quick fix, code fmt, etc., to further improve capabilities and improve development efficiency\\n- More IDE Integration: At present, although KCL provides LSP, it only integrates with VS Code. In the future, KCL users will be provided with more choices based on the capabilities of LSP.\\n- Integration of AI: At present, ChatGPT is popular all over the Internet. We are also exploring the combination of AI\xd7KCL to provide a more intelligent R&D experience.\\n\\nIn summary, we will continue to improve and optimize KCL\'s IDE extension to make it more powerful and practical. Bring more convenient and efficient development experience to KCL users.\\nIf you have more ideas or needs, welcome to issue or discuss them in the KCL Github repo, and welcome to join our community for communication \ud83d\ude4c \ud83d\ude4c \ud83d\ude4c"},{"id":"2023-07-08-kcl-waic-meeting","metadata":{"permalink":"/blog/2023-07-08-kcl-waic-meeting","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-07-08-kcl-waic-meeting/index.md","source":"@site/blog/2023-07-08-kcl-waic-meeting/index.md","title":"KCL Introduction on WAIC 2023 Meeting","description":"KCL Talk Cover","date":"2023-07-08T00:00:00.000Z","formattedDate":"July 8, 2023","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Configuration","permalink":"/blog/tags/configuration"}],"readingTime":0.025,"hasTruncateMarker":false,"authors":[{"name":"Pengfei, Xu","title":"KCL Team Member"}],"frontMatter":{"slug":"2023-07-08-kcl-waic-meeting","title":"KCL Introduction on WAIC 2023 Meeting","authors":{"name":"Pengfei, Xu","title":"KCL Team Member"},"tags":["KCL","Configuration"]},"prevItem":{"title":"Rewrite KCL LSP in Rust","permalink":"/blog/2023/07/10/kcl-LSP"},"nextItem":{"title":"Talking about the SideCar design pattern in K8S - Part 2","permalink":"/blog/2023-06-29-k8s-sidecar-2"}},"content":"![KCL Talk Cover](/img/blog/2023-07-08-kcl-waic-meeting/talk-cover.jpg)\\n\\n[Download PDF](https://kcl-lang.github.io/talks/kcl-waic2023.pdf)"},{"id":"2023-06-29-k8s-sidecar-2","metadata":{"permalink":"/blog/2023-06-29-k8s-sidecar-2","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-06-29-k8s-sidecar-2/index.md","source":"@site/blog/2023-06-29-k8s-sidecar-2/index.md","title":"Talking about the SideCar design pattern in K8S - Part 2","description":"Introduction","date":"2023-06-29T00:00:00.000Z","formattedDate":"June 29, 2023","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"k8s","permalink":"/blog/tags/k-8-s"},{"label":"SideCar","permalink":"/blog/tags/side-car"}],"readingTime":2.435,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2023-06-29-k8s-sidecar-2","title":"Talking about the SideCar design pattern in K8S - Part 2","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["KCL","k8s","SideCar"]},"prevItem":{"title":"KCL Introduction on WAIC 2023 Meeting","permalink":"/blog/2023-07-08-kcl-waic-meeting"},"nextItem":{"title":"Talking about the Sidecar design pattern in K8S - Part 1","permalink":"/blog/2023-06-05-k8s-sidecar-1"}},"content":"## Introduction\\n\\nIn the previous blog [Exploring the Sidecar Design Pattern in K8s - Part 1](/blog/2023-06-05-k8s-sidecar-1/), we introduced the Sidecar design pattern using layman\'s terms. In this blog, we\'ll use KCL, a modern, type-safe configuration language, to showcase the description of Pod resources. In the subsequent blogs, we\'ll use KCL to explore the practical applications of the Sidecar pattern.\\n\\n### 1. OpenAPI Definition for Pods\\n\\nLet\'s go back to the simplest example of Nginx, where the YAML file follows a similar pattern:\\n\\n```yaml\\napiVersion: v1\\nkind: Pod\\nmetadata:\\n  name: web-app\\nspec:\\n  containers:\\n  - image: nginx\\n    name: main-container\\n    ports:\\n      - containerPort: 80\\n```\\n\\nHere, the Pod data follows the definition of the io.k8s.api.core.v1.Pod model in the Kubernetes specification. The complete OpenAPI definition can be found here. By analyzing it carefully, we can see that the apiVersion and kind information are commonly used default configurations. We need a more modern configuration language to simplify it.\\n\\n### 2. Defining Pod Resources with KCL\\n\\nKCL is a configuration policy language for the cloud-native domain. For more information, please refer to the [official website](https://kcl-lang.io/). Basic KCL configuration programs still follow the `K=V` format, which is similar to YAML. For example, we can rewrite the configuration of the Nginx container using the following KCL code:\\n\\n```python\\nimport k8s.api.core.v1 as k8core\\n\\nk8core.Pod {\\n    metadata.name = \\"web-app\\"\\n    spec.containers = [{\\n        name = \\"main-container\\"\\n        image = \\"nginx\\"\\n        ports = [{containerPort: 80}]\\n    }]\\n}\\n```\\n\\nHere, the `import` statement imports the `k8s/api/core/v1` package from the k8s package, and the `Pod` structure definition corresponds to the `Pod` model. The default values for apiVersion and kind have already been included, so we only need to add the `metadata.name` and `spec.containers` properties (KCL also provides syntax sugar for some multi-level nested properties). We can use the [kpm package management tool](https://kcl-lang.io/docs/user_docs/guides/package-management/installation/) to create a KCL program to define a Pod resource and execute the program to get the corresponding YAML:\\n\\n```shell\\n# 1. Initialize a kcl program package called hello.\\nkpm init hello\\n# 2. Edit the main.k file inside the hello package and add the KCL configuration code mentioned earlier.\\ncat <<EOF > hello/main.k\\nimport k8s.api.core.v1 as k8core\\nk8core.Pod {\\n    metadata.name = \\"web-app\\"\\n    spec.containers = [{\\n        name = \\"main-container\\"\\n        image = \\"nginx\\"\\n        ports = [{containerPort: 80}]\\n    }]\\n}\\nEOF\\n# 3. Navigate to the hello package, add the k8s dependency, and run the hello package.\\ncd hello && kpm add k8s && kpm run\\n```\\n\\nThe following YAML output can be obtained:\\n\\n```yaml\\napiVersion: v1\\nkind: Pod\\nmetadata:\\n  name: web-app\\nspec:\\n  containers:\\n    - image: nginx\\n      name: main-container\\n      ports:\\n        - containerPort: 80\\n```\\n\\n### 3. Conclusion\\n\\nIn this blog, we briefly introduced how to use KCL to build Pod configurations for more flexible and robust configurations. In the subsequent blogs, we\'ll use KCL to extract and abstract the best Sidecar pattern practices, including using KCL to abstract the Sidecar model and using KCL to inject Sidecars into existing upstream YAML configurations."},{"id":"2023-06-05-k8s-sidecar-1","metadata":{"permalink":"/blog/2023-06-05-k8s-sidecar-1","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-06-05-k8s-sidecar-1/index.md","source":"@site/blog/2023-06-05-k8s-sidecar-1/index.md","title":"Talking about the Sidecar design pattern in K8S - Part 1","description":"Introduction","date":"2023-06-05T00:00:00.000Z","formattedDate":"June 5, 2023","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"k8s","permalink":"/blog/tags/k-8-s"},{"label":"Sidecar","permalink":"/blog/tags/sidecar"}],"readingTime":5.265,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2023-06-05-k8s-sidecar-1","title":"Talking about the Sidecar design pattern in K8S - Part 1","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["KCL","k8s","Sidecar"]},"prevItem":{"title":"Talking about the SideCar design pattern in K8S - Part 2","permalink":"/blog/2023-06-29-k8s-sidecar-2"},"nextItem":{"title":"Differences between KCL and Helm","permalink":"/blog/2023-05-30-vs-helm"}},"content":"## Introduction\\n\\nIn `K8S`, there is a design pattern called `Sidecar`, The `Sidecar` pattern deploys application components into a separate process or container to provide isolation and encapsulation. And it also allows applications to be composed of heterogeneous components and technologies.\\n\\nThis pattern is named `Sidecar` because it resembles a Sidecar attached to a motorcycle. The Sidecar connects to a parent application and provides support functions for the application. The Sidecar also shares the same lifecycle as the parent application, being created and retired alongside the parent. The Sidecar pattern is sometimes referred to as the sidepick pattern and is a decomposition pattern.\\n\\nThis series of articles will show the usage of the `Sidecar` pattern and how to use the `Sidecar` pattern by KCL.\\n\\n## A Cloud-Native Minimalist Web Services\\n\\nAt first, we could start a web service in our kubernetes environment. Define a pod with only one `Nginx` service and start a web service on port 80 in the `pod.yaml` file below.\\n\\n```yaml\\napiVersion: v1\\nkind: Pod\\nmetadata:\\n  name: web-app\\nspec:\\n  containers:\\n  - image: nginx\\n    name: main-container\\n    ports:\\n      - containerPort: 80\\n```\\n\\n`Pod` is a foundational primitive in cloud native. `Pod` wraps multiple containers into a single logical unit, and the kubernetes runtime ensures that the containers in a `Pod` run on a single machine. So all containers in a `Pod` share lifecycles, disk volumes, network, etc. The `Sidecar` pattern is about adding other containers to a `Pod` to extend and augment the capabilities of the main container.\\n\\nThe `Pod` is then created via the kubectl, and then the `Pod` execution status is viewed via `kubectl get po`.\\n\\n```shell\\n$ kubectl create -f pod.yaml\\n$ kubectl get po\\nNAME READY STATUS RESTARTS AGE\\nweb-app 1/1 Running 0 45m\\n```\\n\\nYou can see that a `Pod` named `web-app` is up and running properly, containing the `Nginx` service. To configure port forwarding for external access, the port 3999 of the host corresponds to port 80 of the master container:\\n\\n```shell\\n$ kubectl port-forward web-app 3999:80\\nForwarding from 127.0.0.1:3999 ->80\\nForwarding from [::1]:3999 -> 80\\n```\\n\\nPort forwarding is a blocking procedure, keep the command line open. Then open the test page in your browser at\\n\\n![](/img/blog/2023-06-05-k8s-side-car/port-forward.png)\\n\\n## Expand the page content by Sidecar\\n\\nIn this section, we try to add the ability to customize web pages to the `Nginx` service via Sidecar without modifying the original `Nginx` container image. Before we start, remove the previously started `Pod`:\\n\\n```shell\\n$ kubectl delete po web-app\\npod \\"web-app\\" deleted\\n```\\n\\nThen add a second `Busybox` Sidecar container to the `Pod`, with the `pod.yaml` file as follows:\\n\\n```yaml\\napiVersion: v1\\nkind: Pod\\nmetadata:\\n  name: web-app\\nspec:\\n  containers:\\n  - image: nginx\\n    name: main-container\\n    ports:\\n      - containerPort: 80\\n\\n    # --- Here are the new additions ---\\n\\n    # andSidecar share file directories to be published via disk volumes\\n    volumeMounts:\\n    - name: var-logs\\n      mountPath: /usr/share/nginx/html\\n  \\n  # Sidecar Container\\n  - image: busybox\\n    command: [\\"/bin/sh\\"]\\n    args: [\\"-c\\", \\"while true; do echo $(date -u) \'Hi I am from Sidecar container\' > /var/log/index.html; sleep 5;done\\"]\\n    name: Sidecar-container\\n    volumeMounts: var-logs\\n      mountPath: /var/log\\n\\n  # All containers in Pod share disk volumes\\n  volumes:\\n  - name: var-logs\\n    emptyDir: {}\\n\\n```\\n\\nThe commands executed by the `Busybox` Sidecar container correspond to the following shell scripts:\\n\\n```bash\\nwhile true; do\\n\\techo $(date -u) \'Hi I am from Sidecar container\' > /var/log/index.html;\\n\\tsleep 5;\\ndone\\n```\\n\\nThe `Busybox` has only one function: it overwrites the `/var/log/index.html` file every 5 seconds, which happens to correspond to the home page file of the Nginx service.\\n\\nThen restart the Pod and remap the local host port to the container port.\\n\\n```shell\\n$ kubectl create -f pod.yaml \\npod/web-app created\\n$ kubectl port-forward web-app 3999:80\\nForwarding from 127.0.0.1:3999 -> 80\\nForwarding from [::1]:3999 -> 80\\n```\\n\\nUpon reopening your browser you will see the following page:\\n\\n![](/img/blog/2023-06-05-k8s-side-car/port-forward-1.png)\\n\\n## How Sidecar mode works\\n\\n`Busybox` is a `Sidecar` container that produces the home page data, while `Nginx` is the main container that consumes the home page data produced by `Busybox`; the two containers share space through the var-logs disk volume.\\n\\n![](/img/blog/2023-06-05-k8s-side-car/how-sidecar-work.png)\\n\\nIn the example, `Nginx` is still the main container, and the `Sidecar` container is BusyBox. we can also add more `Sidecar` containers for network, monitoring, logging, etc.\\n\\n![](/img/blog/2023-06-05-k8s-side-car/how-sidecar-work-1.png)\\n\\n## Advantages of Sidecar\\n\\nContainers have now become a popular packaging technology, where various teams can build, publish and run programs in a unified way, and even manage various resources through containers. So a container is more like a product with its own runtime, release cycle, documentation, API, etc. A good container/product is responsible for solving only one problem, and maintaining the KISS principle allows the container itself to be extremely reusable and replaceable.\\n\\nIt is reusability that makes the modern build process more agile and efficient. But reusable containers are generally single-function, and we often need to extend the functionality of containers, as well as the need for more collaboration between containers.\\n\\nThe Sidecar can be added lots of trailers without modifying the main motorcycle, and accordingly the `Sidecar` pattern can extend and enhance the existing main container functions without modifying the main container.\\n\\nThere is a rule in object-oriented programming that \\"combination is better than inheritance, use more combination and less inheritance\\", so `Sidecar` is also a recommended pattern to use. Because of the advantages of the Sidecar pattern, it has recently been used in a lot of cloud-native scenarios. For example, it can be used to encrypt communication between Pods through a service mesh or to act as a database proxy. Sidecar containers can be used for log forwarding (e.g., `fluentd`), Service Mesh (e.g., `Istio`, `Linkerd`), proxying (e.g., `Docker Ambassador`), health checking (to check if certain components are working properly), and other auxiliary tasks (such as copying files or downloading files).\\n\\n## Summary\\n\\nIn this article, we briefly introduce and demonstrate the `Sidecar` pattern, while comparing the relationship between `Sidecar` pattern and the combinatorial programming pattern in the context of traditional object-oriented programming ideas. the advantages of the `Sidecar` pattern are not only in the harmless enhancement of the main container, but also in the more flexible ability to dynamically adjust the main container capability.\\n\\nIn later articles, we will try to simplify writing `Sidecar` configurations by modern cloud-native configuration languages such as `KCL`. Extending existing configuration based on `Sidecar` by dynamically injecting and modifying it through `KCL`."},{"id":"2023-05-30-vs-helm","metadata":{"permalink":"/blog/2023-05-30-vs-helm","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-05-30-vs-helm/index.md","source":"@site/blog/2023-05-30-vs-helm/index.md","title":"Differences between KCL and Helm","description":"Introduction","date":"2023-05-30T00:00:00.000Z","formattedDate":"May 30, 2023","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Helm","permalink":"/blog/tags/helm"}],"readingTime":8.86,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2023-05-30-vs-helm","title":"Differences between KCL and Helm","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["KCL","Helm"]},"prevItem":{"title":"Talking about the Sidecar design pattern in K8S - Part 1","permalink":"/blog/2023-06-05-k8s-sidecar-1"},"nextItem":{"title":"Differences between KCL and Kustomize","permalink":"/blog/2023-05-20-vs-kustomize"}},"content":"## Introduction\\n\\n[Helm](https://helm.sh/) is a tool for generating deployable manifests for Kubernetes objects, which philosophically takes the task of generating the final manifests in two distinct forms. Helm is an imperative templating tool for managing Kubernetes packages called charts. Charts are a templated version of your yaml manifests with a subset of Go Templating mixed throughout, as well it is a package manager for kubernetes that can package, configure, and deploy/apply the helm charts onto kubernetes clusters.\\n\\nIn KCL, the user can directly write the configuration instead of template files with more tools and IDE plugin support that needs to be modified in the corresponding code in the corresponding place, eliminating the cost of reading basic YAML. At the same time, the user can reuse the configuration fragments by code, avoiding massive copying and pasting of YAML configuration. The information density is higher, and it is not easy to make mistakes through KCL.\\n\\nA classic example of helm chart configuration management is used to explain the differences between Helm and KCL in Kubernetes resource configuration management.\\n\\n## Helm\\n\\nHelm has the concepts of `values.yaml` and `template`. In general, the Helm chart project is generally a directory including a `Chart.yaml`.:\\n\\nWe can execute the following command line to obtain a typical Helm Chart project.\\n\\n+ Create a directory named `workload-helm` to hold the chart project\\n\\n```bash\\n# Create a directory to hold the chart project\\nmkdir workload-helm\\n# Create a workload-helm/Chart.yaml\\ncat <<EOF > workload-helm/Chart.yaml\\napiVersion: v2\\nappVersion: 0.3.0\\ndescription: A helm chart to provision standard workloads.\\nname: workload\\ntype: application\\nversion: 0.3.0\\nEOF\\n# Create a workload-helm/values.yaml\\ncat <<EOF > workload-helm/values.yaml\\nservice:\\n  type: ClusterIP\\n  ports:\\n    - name: www\\n      protocol: TCP\\n      port: 80\\n      targetPort: 80\\n\\ncontainers:\\n  my-container:\\n    image:\\n      name: busybox:latest\\n    command: [\\"/bin/echo\\"]\\n    args: \\n      - \\"-c\\"\\n      - \\"Hello World!\\"\\n    resources:\\n      limits:\\n        cpu: 100m\\n        memory: 128Mi\\n      requests:\\n        cpu: 100m\\n        memory: 128Mi\\nEOF\\n```\\n\\n+ Create a directory to hold templates\\n\\n```bash\\n# Create a directory to hold templates\\nmkdir workload-helm/templates\\n# Create a workload-helm/templates/helpers.tpl\\ncat <<EOF > workload-helm/templates/helpers.tpl\\n{{/*\\nExpand the name of the chart.\\n*/}}\\n{{- define \\"workload.name\\" -}}\\n{{- default .Release.Name .Values.nameOverride | trunc 63 | trimSuffix \\"-\\" }}\\n{{- end }}\\n{{/*\\nCreate a default fully qualified app name.\\nWe truncate at 63 chars because some Kubernetes name fields are limited to this (by the DNS naming spec).\\nIf release name contains chart name it will be used as a full name.\\n*/}}\\n{{- define \\"workload.fullname\\" -}}\\n{{- \\\\$name := default .Chart.Name .Values.nameOverride }}\\n{{- if contains \\\\$name .Release.Name }}\\n{{- .Release.Name | trunc 63 | trimSuffix \\"-\\" }}\\n{{- else }}\\n{{- printf \\"%s-%s\\" .Release.Name \\\\$name | trunc 63 | trimSuffix \\"-\\" }}\\n{{- end }}\\n{{- end }}\\n{{/*\\nCreate chart name and version as used by the chart label.\\n*/}}\\n{{- define \\"workload.chart\\" -}}\\n{{- printf \\"%s-%s\\" .Chart.Name .Chart.Version | replace \\"+\\" \\"_\\" | trunc 63 | trimSuffix \\"-\\" }}\\n{{- end }}\\n{{/*\\nCommon labels\\n*/}}\\n{{- define \\"workload.labels\\" -}}\\nhelm.sh/chart: {{ include \\"workload.chart\\" . }}\\n{{ include \\"workload.selectorLabels\\" . }}\\n{{- if .Chart.AppVersion }}\\napp.kubernetes.io/version: {{ .Chart.AppVersion | quote }}\\n{{- end }}\\napp.kubernetes.io/managed-by: {{ .Release.Service }}\\n{{- end }}\\n{{/*\\nSelector labels\\n*/}}\\n{{- define \\"workload.selectorLabels\\" -}}\\napp.kubernetes.io/name: {{ include \\"workload.name\\" . }}\\napp.kubernetes.io/instance: {{ .Release.Name }}\\n{{- end }}\\nEOF\\ncat <<EOF > workload-helm/templates/deployment.yaml\\napiVersion: apps/v1\\nkind: Deployment\\nmetadata:\\n  name: {{ include \\"workload.name\\" . }}\\n  labels:\\n    {{- include \\"workload.labels\\" . | nindent 4 }}\\nspec:\\n  selector:\\n    matchLabels:\\n      {{- include \\"workload.selectorLabels\\" . | nindent 6 }}\\n  template:\\n    metadata:\\n      labels:\\n        {{- include \\"workload.selectorLabels\\" . | nindent 8 }}\\n    spec:\\n      containers:\\n        {{- range \\\\$name, \\\\$container := .Values.containers }}\\n        - name: {{ \\\\$name }}\\n          image: \\"{{ $container.image.name }}\\"\\n          {{- with \\\\$container.command }}\\n          command:\\n            {{- toYaml \\\\$container.command | nindent 12 }}\\n          {{- end }}\\n          {{- with \\\\$container.args }}\\n          args:\\n            {{- toYaml \\\\$container.args | nindent 12 }}\\n          {{- end }}\\n          {{- with \\\\$container.env }}\\n          env:\\n            {{- toYaml \\\\$container.env | nindent 12 }}\\n          {{- end }}\\n          {{- with \\\\$container.volumeMounts }}\\n          volumeMounts:\\n            {{- toYaml \\\\$container.volumeMounts | nindent 12 }}\\n          {{- end }}\\n          {{- with \\\\$container.livenessProbe }}\\n          livenessProbe:\\n            {{- toYaml \\\\$container.livenessProbe | nindent 12 }}\\n          {{- end }}\\n          {{- with \\\\$container.readinessProbe }}\\n          readinessProbe:\\n            {{- toYaml \\\\$container.readinessProbe | nindent 12 }}\\n          {{- end }}\\n          {{- with \\\\$container.resources }}\\n          resources:\\n            {{- toYaml \\\\$container.resources | nindent 12 }}\\n          {{- end }}\\n        {{- end }}\\nEOF\\ncat <<EOF > workload-helm/templates/service.yaml\\n{{ if .Values.service }}\\napiVersion: v1\\nkind: Service\\nmetadata:\\n  name: {{ include \\"workload.name\\" . }}\\n  labels:\\n    {{- include \\"workload.labels\\" . | nindent 4 }}\\nspec:\\n  type: {{ .Values.service.type }}\\n  selector:\\n    {{- include \\"workload.selectorLabels\\" . | nindent 4 }}\\n  {{- with .Values.service.ports }}\\n  ports:\\n    {{- toYaml . | nindent 4 }}\\n  {{- end }}\\n{{- end }}\\nEOF\\n```\\n\\nThus, we can get a basic Helm chart directory\\n\\n```txt\\n.\\n\u251c\u2500\u2500 Chart.yaml\\n\u251c\u2500\u2500 templates\\n\u2502   \u251c\u2500\u2500 _helpers.tpl\\n\u2502   \u251c\u2500\u2500 deployment.yaml\\n\u2502   \u2514\u2500\u2500 service.yaml\\n\u2514\u2500\u2500 values.yaml\\n```\\n\\nWe can display the real deployment configuration of through the following command.\\n\\n```bash\\nhelm template workload-helm\\n```\\n\\nThe output YAML is\\n\\n```yaml\\n---\\n# Source: workload-helm/templates/service.yaml\\napiVersion: v1\\nkind: Service\\nmetadata:\\n  name: release-name\\n  labels:\\n    helm.sh/chart: workload-0.3.0\\n    app.kubernetes.io/name: release-name\\n    app.kubernetes.io/instance: release-name\\n    app.kubernetes.io/version: \\"0.3.0\\"\\n    app.kubernetes.io/managed-by: Helm\\nspec:\\n  type: ClusterIP\\n  selector:\\n    app.kubernetes.io/name: release-name\\n    app.kubernetes.io/instance: release-name\\n  ports:\\n    - name: www\\n      port: 80\\n      protocol: TCP\\n      targetPort: 80\\n---\\n# Source: workload-helm/templates/deployment.yaml\\napiVersion: apps/v1\\nkind: Deployment\\nmetadata:\\n  name: release-name\\n  labels:\\n    helm.sh/chart: workload-0.3.0\\n    app.kubernetes.io/name: release-name\\n    app.kubernetes.io/instance: release-name\\n    app.kubernetes.io/version: \\"0.3.0\\"\\n    app.kubernetes.io/managed-by: Helm\\nspec:\\n  selector:\\n    matchLabels:\\n      app.kubernetes.io/name: release-name\\n      app.kubernetes.io/instance: release-name\\n  template:\\n    metadata:\\n      labels:\\n        app.kubernetes.io/name: release-name\\n        app.kubernetes.io/instance: release-name\\n    spec:\\n      containers:\\n        - name: my-container\\n          image: \\"busybox:latest\\"\\n          command:\\n            - /bin/echo\\n          args:\\n            - -c\\n            - Hello World!\\n          resources:\\n            limits:\\n              cpu: 100m\\n              memory: 128Mi\\n            requests:\\n              cpu: 100m\\n              memory: 128Mi\\n```\\n\\n## KCL\\n\\nIn KCL, we provide the ability similar to Helm `values.yaml` to configure dynamic parameters through configuration files `kcl.yaml`.\\n\\nWe can execute the following command line to obtain a typical KCL project with the `kcl.yaml`.\\n\\n+ Create a directory named `workload-kcl` to hold the KCL project\\n\\n```bash\\n# Create a directory to hold the KCL project\\nmkdir workload-kcl\\n# Create a workload-kcl/kcl.yaml\\ncat <<EOF > workload-kcl/kcl.yaml\\nkcl_options:\\n  - key: containers\\n    value:\\n      my-container:\\n        image:\\n          name: busybox:latest\\n        command: [\\"/bin/echo\\"]\\n        args: \\n          - \\"-c\\"\\n          - \\"Hello World!\\"\\n        resources:\\n          limits:\\n            cpu: 100m\\n            memory: 128Mi\\n          requests:\\n            cpu: 100m\\n            memory: 128Mi\\n\\n  - key: service\\n    value:\\n      type: ClusterIP\\n      ports:\\n        - name: www\\n          protocol: TCP\\n          port: 80\\n          targetPort: 80\\nEOF\\n```\\n\\n+ Create KCL files to hold kubernetes resources.\\n\\n```bash\\n# Create a workload-kcl/deployment.k\\ncat <<EOF > workload-kcl/deployment.k\\napiVersion = \\"apps/v1\\"\\nkind = \\"Deployment\\"\\nmetadata = {\\n    name = \\"release-name\\"\\n    labels = {\\n        \\"app.kubernetes.io/name\\" = \\"release-name\\"\\n        \\"app.kubernetes.io/instance\\" = \\"release-name\\"\\n    }\\n}\\nspec = {\\n    selector.matchLabels = metadata.labels\\n    template.metadata.labels = metadata.labels\\n    template.spec.containers = [\\n        {\\n            name = name\\n            image = container.image.name\\n            command = container.command\\n            command = container.args\\n            env = container.env\\n            resources = container.resources\\n        } for name, container in option(\\"containers\\") or {}\\n    ]\\n}\\nEOF\\ncat <<EOF > workload-kcl/service.k\\napiVersion = \\"v1\\"\\nkind = \\"Service\\"\\nmetadata = {\\n    name = \\"release-name\\"\\n    labels = {\\n        \\"app.kubernetes.io/name\\" = \\"release-name\\"\\n        \\"app.kubernetes.io/instance\\" = \\"release-name\\"\\n    }\\n}\\nspec = {\\n    selector.matchLabels = metadata.labels\\n    type = option(\\"service\\", default={})?.type\\n    ports = option(\\"service\\", default={})?.ports\\n}\\nEOF\\n```\\n\\nIn the above KCL code, we declare the `apiVersion`, `kind`, `metadata`, `spec` and other attributes of Kubernetes `Deployment` and `Service` resources, and assign the corresponding contents respectively. In particular, we assign `metadata.labels` to `spec.selector.matchLabels` and `spec.template.metadata.labels`. It can be seen that the data structure defined by KCL is more compact than Helm template or YAML, and configuration reuse can be realized by defining local variables.\\n\\nIn KCL, we can dynamically receive external parameters through conditional statements and the `option` builtin function, and set different configuration values to generate resources.\\n\\nWe can get the `Deployment` and `Service` resources throw the following command:\\n\\n+ `Deployment`\\n\\n```shell\\nkcl workload-kcl/deployment.k -Y workload-kcl/kcl.yaml\\n```\\n\\nThe output is\\n\\n```yaml\\napiVersion: apps/v1\\nkind: Deployment\\nmetadata:\\n  name: release-name\\n  labels:\\n    app.kubernetes.io/name: release-name\\n    app.kubernetes.io/instance: release-name\\nspec:\\n  selector:\\n    matchLabels:\\n      app.kubernetes.io/name: release-name\\n      app.kubernetes.io/instance: release-name\\n  template:\\n    metadata:\\n      labels:\\n        app.kubernetes.io/name: release-name\\n        app.kubernetes.io/instance: release-name\\n    spec:\\n      containers:\\n      - name: my-container\\n        image: busybox:latest\\n        command:\\n        - -c\\n        - Hello World!\\n        resources:\\n          limits:\\n            cpu: 100m\\n            memory: 128Mi\\n          requests:\\n            cpu: 100m\\n            memory: 128Mi\\n```\\n\\n+ `Service`\\n\\n```shell\\nkcl workload-kcl/service.k -Y workload-kcl/kcl.yaml\\n```\\n\\nThe output is\\n\\n```yaml\\napiVersion: v1\\nkind: Service\\nmetadata:\\n  name: release-name\\n  labels:\\n    app.kubernetes.io/name: release-name\\n    app.kubernetes.io/instance: release-name\\nspec:\\n  selector:\\n    matchLabels:\\n      app.kubernetes.io/name: release-name\\n      app.kubernetes.io/instance: release-name\\n  type: ClusterIP\\n  ports:\\n  - name: www\\n    protocol: TCP\\n    port: 80\\n    targetPort: 80\\n```\\n\\nIn addition, we can overwrite the value in the `kcl.yaml` file with the `-D` parameter, such as executing the following command.\\n\\n```shell\\nkcl workload-kcl/service.k -Y workload-kcl/kcl.yaml -D service=None\\n```\\n\\nThe output is\\n\\n```yaml\\napiVersion: v1\\nkind: Service\\nmetadata:\\n  name: release-name\\n  labels:\\n    app.kubernetes.io/name: release-name\\n    app.kubernetes.io/instance: release-name\\nspec:\\n  selector:\\n    matchLabels:\\n      app.kubernetes.io/name: release-name\\n      app.kubernetes.io/instance: release-name\\n  type: null\\n  ports: null\\n```\\n\\n## Summary\\n\\nIt can be seen that, compared with Helm, KCL reduces the number of configuration files and code lines by means of code generation on the basis of configuration reuse and coverage, And like Helm, it is a pure client solution, which can move the configuration and policy verification to the left as far as possible without additional dependency or burden on the cluster, or even without a real Kubernetes cluster.\\n\\nHelm can define reusable templates in the `.tpl` file and support other templates to reference it. However, only defined templates can be reused. In a complex Helm chart project, we need to define a lot of additional basic templates. Compared with the cumbersome writing method of Helm, all contents in KCL are variables. No additional syntax is required to specify templates. Any variables can be referenced to each other.\\n\\nIn addition, there are a large number of `{{- include }}`, `nindent` and `toYaml` tag characters that have nothing to do with actual logic in Helm. You need to calculate spaces and indents at each reference. In KCL, there are fewer useless codes, and there is no need for too many `{{*}}` to mark code blocks. The information density is higher, and the indentation and space have been completely liberated.\\n\\nIn fact, KCL and Helm are not antagonistic. We can even use KCL to write HelmRelease templates and provide programmable extension capabilities for existing Helm chart to write YAML validators.\\n\\n## Future Plan\\n\\nWe also expect that KCL models and constraints can be managed as a package (this package has only KCL files). For example, the Kubernetes models and constraints can be used out of the box. Users can generate configurations or verify existing configurations, and can simply extend the models and constraints users want through KCL inheritance.\\n\\nAt this stage, you can use tools such as Git or [OCI Registry As Storage (ORAS)]( https://github.com/oras-project/oras) to manage KCL configuration versions.\\n\\n## More Documents\\n\\n+ KCL Github Repo: [https://github.com/kcl-lang/kcl](https://github.com/kcl-lang/kcl)\\n+ KCL Website: [https://kcl-lang.io](https://kcl-lang.io)"},{"id":"2023-05-20-vs-kustomize","metadata":{"permalink":"/blog/2023-05-20-vs-kustomize","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-05-20-vs-kustomize/index.md","source":"@site/blog/2023-05-20-vs-kustomize/index.md","title":"Differences between KCL and Kustomize","description":"Introduction","date":"2023-05-20T00:00:00.000Z","formattedDate":"May 20, 2023","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Kustomize","permalink":"/blog/tags/kustomize"}],"readingTime":5.885,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2023-05-20-vs-kustomize","title":"Differences between KCL and Kustomize","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["KCL","Kustomize"]},"prevItem":{"title":"Differences between KCL and Helm","permalink":"/blog/2023-05-30-vs-helm"},"nextItem":{"title":"See Goodbye to Old KCL Go SDK, the New One is Out!","permalink":"/blog/2023-new-version-feature-interpretation-kclvm-go-feature-overview"}},"content":"## Introduction\\n\\n[Kustomize](https://kustomize.io/) provides a solution to customize the basic configuration and differential configuration of Kubernetes resources without templates. The configuration can be merged or overwritten through file-level YAML configuration with multiple strategies. In Kustomize, users need to know more about the content and location to be changed, For basic YAML with complex recursion too deep, it may not be easy to match Kustomize files through selectors.\\n\\nIn KCL, the user can directly write the configuration that needs to be modified in the corresponding code in the corresponding place, eliminating the cost of reading basic YAML. At the same time, the user can reuse the configuration fragments by code, avoiding massive copying and pasting of YAML configuration. The information density is higher, and it is not easy to make mistakes through KCL.\\n\\nA classic example of Kustomize multi-environment configuration management is used to explain the differences between Kustomize and KCL in Kubernetes resource configuration management.\\n\\n## Kustomize\\n\\nKustomize has the concepts of `base` and `overlay`. In general, base and overlay are general a directory including a `kustomization.yaml` file. One base directory can be used by multiple overlay directories.\\n\\nWe can execute the following command line to obtain a typical Kustomize project\\n\\n+ Create a base directory and create a deployment resource\\n\\n```bash\\n# Create a directory to hold the base\\nmkdir base\\n# Create a base/deployment.yaml\\ncat <<EOF > base/deployment.yaml\\napiVersion: apps/v1\\nkind: Deployment\\nmetadata:\\n  name: ldap\\n  labels:\\n    app: ldap\\nspec:\\n  replicas: 1\\n  selector:\\n    matchLabels:\\n      app: ldap\\n  template:\\n    metadata:\\n      labels:\\n        app: ldap\\n    spec:\\n      containers:\\n        - name: ldap\\n          image: osixia/openldap:1.1.11\\n          args: [\\"--copy-service\\"]\\n          volumeMounts:\\n            - name: ldap-data\\n              mountPath: /var/lib/ldap\\n          ports:\\n            - containerPort: 389\\n              name: openldap\\n      volumes:\\n        - name: ldap-data\\n          emptyDir: {}\\nEOF\\n# Create a base/kustomization.yaml\\ncat <<EOF > base/kustomization.yaml\\nresources:\\n- deployment.yaml\\nEOF\\n```\\n\\n+ Create a directory to hold the prod overlay configuration.\\n\\n```bash\\n# Create a directory to hold the prod overlay\\nmkdir prod\\n# Create a prod/deployment.yaml\\ncat <<EOF > prod/deployment.yaml\\napiVersion: apps/v1\\nkind: Deployment\\nmetadata:\\n  name: ldap\\nspec:\\n  replicas: 6\\n  template:\\n    spec:\\n      volumes:\\n        - name: ldap-data\\n          emptyDir: null\\n          gcePersistentDisk:\\n            readOnly: true\\n            pdName: ldap-persistent-storage\\nEOF\\ncat <<EOF > prod/kustomization.yaml\\nresources:\\n  - ../base\\npatchesStrategicMerge:\\n  - deployment.yaml\\nEOF\\n```\\n\\nThus, we can get a basic Kustomize directory\\n\\n```txt\\n.\\n\u251c\u2500\u2500 base\\n\u2502   \u251c\u2500\u2500 deployment.yaml\\n\u2502   \u2514\u2500\u2500 kustomization.yaml\\n\u2514\u2500\u2500 prod\\n    \u251c\u2500\u2500 deployment.yaml\\n    \u2514\u2500\u2500 kustomization.yaml\\n```\\n\\nThe base directory stores the basic deployment configuration, and the prod environment stores the deployment configuration that needs to be overwritten. The `metadata.name` and other attributes such as `spec.template.spec.volumes[0].name` are used to indicate which resource to overwrite\\n\\nWe can display the real deployment configuration of the prod environment through the following command.\\n\\n```shell\\nkubectl kustomize ./prod\\n```\\n\\nThe output is\\n\\n```yaml\\napiVersion: apps/v1\\nkind: Deployment\\nmetadata:\\n  labels:\\n    app: ldap\\n  name: ldap\\nspec:\\n  replicas: 6\\n  selector:\\n    matchLabels:\\n      app: ldap\\n  template:\\n    metadata:\\n      labels:\\n        app: ldap\\n    spec:\\n      containers:\\n      - args:\\n        - --copy-service\\n        image: osixia/openldap:1.1.11\\n        name: ldap\\n        ports:\\n        - containerPort: 389\\n          name: openldap\\n        volumeMounts:\\n        - mountPath: /var/lib/ldap\\n          name: ldap-data\\n      volumes:\\n      - gcePersistentDisk:\\n          pdName: ldap-persistent-storage\\n          readOnly: true\\n        name: ldap-data\\n```\\n\\nWe can also directly apply the configuration to the cluster through the following command.\\n\\n```shell\\nkubectl apply -k ./prod\\n```\\n\\nThe output is\\n\\n```shell\\ndeployment.apps/ldap created\\n```\\n\\n## KCL\\n\\nWe can write the following KCL code and name it `main.k`.\\n\\n```python\\napiVersion = \\"apps/v1\\"\\nkind = \\"Deployment\\"\\nmetadata = {\\n    name = \\"ldap\\"\\n    labels.app = \\"ldap\\"\\n}\\nspec = {\\n    replicas = 1\\n    # When env is prod, override the `replicas` attribute with `6`\\n    if option(\\"env\\") == \\"prod\\": replicas = 6\\n    # Assign `metadata.labels` to `selector.matchLabels`\\n    selector.matchLabels = metadata.labels\\n    template.metadata.labels = metadata.labels\\n    template.spec.containers = [\\n        {\\n            name = metadata.name\\n            image = \\"osixia/openldap:1.1.11\\"\\n            args = [\\"--copy-service\\"]\\n            volumeMounts = [{ name = \\"ldap-data\\", mountPath = \\"/var/lib/ldap\\" }]\\n            ports = [{ containerPort = 80, name = \\"openldap\\" }]\\n        }\\n    ]\\n    template.spec.volumes = [\\n        {\\n            name = \\"ldap-data\\"\\n            emptyDir = {}\\n            # When env is prod\\n            # override the `emptyDir` attribute with `None`\\n            # patch a `gcePersistentDisk` attribute with the value `{readOnly = True, pdName = \\"ldap-persistent-storage\\"}`\\n            if option(\\"env\\") == \\"prod\\":\\n                emptyDir = None\\n                gcePersistentDisk = {\\n                    readOnly = True\\n                    pdName = \\"ldap-persistent-storage\\"\\n                }\\n        }\\n    ]\\n}\\n```\\n\\nIn the above KCL code, we declare the `apiVersion`, `kind`, `metadata`, `spec` and other attributes of a Kubernetes `Deployment` resource, and assign the corresponding contents respectively. In particular, we assign `metadata.labels` to `spec.selector.matchLabels` and `spec.template.metadata.labels`. It can be seen that the data structure defined by KCL is more compact than Kustomize or YAML, and configuration reuse can be realized by defining local variables.\\n\\nIn KCL, we can dynamically receive external parameters through conditional statements and the `option` builtin function, and set different configuration values for different environments to generate resources. For example, for the above code, we wrote a conditional statement and entered a dynamic parameter named `env`. When `env` is `prod`, we will overwrite the `replicas` attribute from `1` to `6`, and make some adjustments to the volume configuration named `ldap-data`, such as changing the `emptyDir` attribute to `None`, and adding the configuration value of `gcePersistentDisk`.\\n\\nWe can use the following command to view diff between different environment configurations\\n\\n```bash\\ndiff \\\\\\n  <(kcl main.k) \\\\\\n  <(kcl main.k -D env=prod) |\\\\\\n  more\\n```\\n\\nThe output is\\n\\n```diff\\n8c8\\n<   replicas: 1\\n---\\n>   replicas: 6\\n30c30,33\\n<         emptyDir: {}\\n---\\n>         emptyDir: null\\n>         gcePersistentDisk:\\n>           readOnly: true\\n>           pdName: ldap-persistent-storage\\n```\\n\\nIt can be seen that the diff between the production environment configuration and the base configuration mainly lies in the attributes of `replicas`, `emptyDir` and `gcePersistentDisk`, which is consistent with the expectation.\\n\\nIn addition, we can use the `-o` parameter of the KCL command line tool to output the compiled YAML to a file and view the diff between files\\n\\n```bash\\n# Generate base deployment\\nkcl main.k -o deployment.yaml\\n# Generate prod deployment\\nkcl main.k -o prod-deployment.yaml -D env=prod\\n# Diff prod deployment and base deployment\\ndiff prod-deployment.yaml deployment.yaml\\n```\\n\\nOf course, we can also use KCL tools together with kubectl and other tools to apply the configuration of the production environment to the cluster\\n\\n```shell\\nkcl main.k -D env=prod | kubectl apply -f -\\n```\\n\\nThe output is\\n\\n```shell\\ndeployment.apps/ldap created\\n```\\n\\nFinally, check the deployment status through kubectl\\n\\n```shell\\nkubectl get deploy\\n```\\n\\nThe output is\\n\\n```shell\\nNAME   READY   UP-TO-DATE   AVAILABLE   AGE\\nldap   0/6     6            0           15s\\n```\\n\\nIt can be seen from the results of the command that it is completely consistent with the deployment experience of using Kustomize configuration and kubectl apply directly, and there are no more side effects.\\n\\n## Summary\\n\\nThis article briefly introduces the quick start of writing complex multi-environment Kubernetes configuration with KCL and the comparison of Kustomize tool for Kubernetes multi-environment configuration management.\\n\\nIt can be seen that, compared with Kustomize, KCL reduces the number of configuration files and code lines by means of code generation on the basis of configuration reuse and coverage, And like Kustomize, it is a pure client solution, which can move the configuration and policy verification to the left as far as possible without additional dependency or burden on the cluster, or even without a real Kubernetes cluster."},{"id":"2023-new-version-feature-interpretation-kclvm-go-feature-overview","metadata":{"permalink":"/blog/2023-new-version-feature-interpretation-kclvm-go-feature-overview","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-04-27-new-version-feature-interpretation-kclvm-go-feature-overview/index.md","source":"@site/blog/2023-04-27-new-version-feature-interpretation-kclvm-go-feature-overview/index.md","title":"See Goodbye to Old KCL Go SDK, the New One is Out!","description":"What is KCL","date":"2023-04-27T00:00:00.000Z","formattedDate":"April 27, 2023","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"kclvm-go","permalink":"/blog/tags/kclvm-go"}],"readingTime":3.995,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2023-new-version-feature-interpretation-kclvm-go-feature-overview","title":"See Goodbye to Old KCL Go SDK, the New One is Out!","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["KCL","kclvm-go"]},"prevItem":{"title":"Differences between KCL and Kustomize","permalink":"/blog/2023-05-20-vs-kustomize"},"nextItem":{"title":"KCL v0.4.6 Release Blog","permalink":"/blog/2022-kcl-0.4.6-release-blog"}},"content":"## What is KCL\\n\\n[KCL](https://github.com/kcl-lang/kcl) is an open-source, constraint-based record and functional language. KCL improves the writing of numerous complex configurations, such as cloud-native scenarios, through its mature programming language technology and practice. It is dedicated to building better modularity, scalability, and stability around configurations, simpler logic writing, faster automation, and great built-in or API-driven integrations.\\n\\n## What is KCL Go SDK?\\n\\nkclvm is a runtime library for the KCL language that provides a programming interface for interacting with the KCL compiler. It is a client library that can be used to perform various operations on KCL source code such as execution and formatting. KCL Go SDK is a Go language wrapper for kclvm that provides an SDK for KCL language integration in cloud-native environments.\\n\\nThe current version of `KCL Go SDK` is built on top of the kclvm json2 RPC API, which means that it uses the same API as other language KCL clients to interact with KCL source code. The way it works is similar to other language KCL SDKs, but it provides a more user-friendly Go language style wrapper.\\n\\n## What problems does the new version of KCL Go SDK solve?\\n\\nKCL is closely related to the cloud-native domain as a configuration language, while on the other hand, Go has become the de facto standard programming language for cloud-native domains. In this context, the development of a Go SDK for the KCL compiler to directly interact with Go was necessary, which is the reason for the creation of `KCL Go SDK`.\\n\\nThe initial version of the KCL compiler and runtime were written in Python, and the runtime for the first version of the KCL language had a lot of room for improvement in terms of performance and security due to the performance issues and characteristics of the dynamic nature of the Python language. In light of security and efficiency considerations, later versions of the KCL compiler were written in the Rust programming language. As a result, the new version of `KCL Go SDK` is based on rust-implemented kclvm packaging, eliminating Python dependencies, simplifying installation, and optimizing the user experience.\\n\\n## Quickly experience KCL Go SDK via the command line\\n\\n`KCL Go SDK` provides a built-in command line tool named `kcl-go` ,which supports one-click installation through `go install`. The local Go version must be 1.18+ and the complete CGO toolchain is required.\\n\\nSimply run:\\n\\n```bash\\ngo install kusionstack.io/kclvm-go/cmds/kcl-go@latest\\n```\\n\\nCreate a new KCL source file hello.k\\n\\n```python\\napiVersion = \\"apps/v1\\"\\nkind = \\"Deployment\\"\\nmetadata = {\\n    name = \\"nginx\\"\\n    labels.app = \\"nginx\\"\\n}\\nspec = {\\n    replicas = 3\\n    selector.matchLabels = metadata.labels\\n    template.metadata.labels = metadata.labels\\n    template.spec.containers = [\\n        {\\n            name = metadata.name\\n            image = \\"${metadata.name}:1.14.2\\"\\n            ports = [{ containerPort = 80 }]\\n        }\\n    ]\\n}\\n```\\n\\nAnd then execute the KCL directly from the command line with:\\n\\n```shell\\nkcl-go run ./hello.k\\n```\\n\\nThe output is\\n\\n```yaml\\napiVersion: apps/v1\\nkind: Deployment\\nmetadata:\\n  name: nginx\\n  labels:\\n    app: nginx\\nspec:\\n  replicas: 3\\n  selector:\\n    matchLabels:\\n      app: nginx\\n  template:\\n    metadata:\\n      labels:\\n        app: nginx\\n    spec:\\n      containers:\\n        - name: nginx\\n          image: \\"nginx:1.14.2\\"\\n          ports:\\n            - containerPort: 80\\n```\\n\\n## How to integrate KCL with Go code?\\n\\nHere is an example of how to integrate KCL into your Go program. Using the hello.k file from the previous example, construct the following main.go code:\\n\\n```go\\npackage main\\n\\nimport (\\n\\t\\"fmt\\"\\n\\t\\"kusionstack.io/kclvm-go\\"\\n)\\n\\nfunc main() {\\n\\tresult := kclvm.MustRun(\\"./hello.k\\").GetRawYamlResult()\\n\\tfmt.Println(result)\\n}\\n```\\n\\n- `kclvm.MustRun(\\"./hello.k\\").GetRawYamlResult()` runs the corresponding KCL source file\\n- `fmt.Println(result)` prints the result of the run\\n\\nThe local environment requires Go version 1.18+ and a complete CGO toolchain. Add the `KCL Go SDK` dependency to this command line tool by running:\\n\\n```bash\\ngo get kusionstack.io/kclvm-go@main\\n```\\n\\nThe following command runs the Go program:\\n\\n```shell\\ngo run main.go\\n```\\n\\nThe output is\\n\\n```yaml\\napiVersion: apps/v1\\nkind: Deployment\\nmetadata:\\n  name: nginx\\n  labels:\\n    app: nginx\\nspec:\\n  replicas: 3\\n  selector:\\n    matchLabels:\\n      app: nginx\\n  template:\\n    metadata:\\n      labels:\\n        app: nginx\\n    spec:\\n      containers:\\n        - name: nginx\\n          image: \\"nginx:1.14.2\\"\\n          ports:\\n            - containerPort: 80\\n```\\n\\n## Conclusion\\n\\nThrough the version change, we have removed Python dependencies and switched to a more efficient Rust runtime. The article briefly demonstrates how to use the kcl-go command line tool to execute KCL source code and how to integrate KCL into your Go program.\\n\\nIn addition to compiling and running KCL source code, the KCL Go SDK provides a variety of features to facilitate KCL integration in Go, including:\\n\\n- KCL static error analysis (lint and format)\\n- KCL dependency analysis\\n- Go struct and KCL Schema mutual conversion\\n\\n## Additional Resources\\n\\nThank all KCL users for their valuable feedback and suggestions during this version release. For more resources, please refer to:\\n\\n- [KCL Website](https://kcl-lang.io/)\\n- [Kusion Website](https://kusionstack.io/)\\n- [KCL Repo](https://github.com/kcl-lang/kcl)\\n- [kcl-go Repo](https://github.com/kcl-lang/kcl-go)\\n- [Kusion Repo](https://github.com/KusionStack/kusion)\\n- [Konfig Repo](https://github.com/KusionStack/konfig)\\n\\nSee the [community](https://github.com/kcl-lang/community) for ways to join us. \ud83d\udc4f\ud83d\udc4f\ud83d\udc4f"},{"id":"2022-kcl-0.4.6-release-blog","metadata":{"permalink":"/blog/2022-kcl-0.4.6-release-blog","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-04-14-kcl-0.4.6-release/index.md","source":"@site/blog/2023-04-14-kcl-0.4.6-release/index.md","title":"KCL v0.4.6 Release Blog","description":"Introduction","date":"2023-04-14T00:00:00.000Z","formattedDate":"April 14, 2023","tags":[{"label":"Release Blog","permalink":"/blog/tags/release-blog"},{"label":"KCL","permalink":"/blog/tags/kcl"}],"readingTime":8.2,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2022-kcl-0.4.6-release-blog","title":"KCL v0.4.6 Release Blog","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["Release Blog","KCL"]},"prevItem":{"title":"See Goodbye to Old KCL Go SDK, the New One is Out!","permalink":"/blog/2023-new-version-feature-interpretation-kclvm-go-feature-overview"},"nextItem":{"title":"KCL Introduction on OS2ATC 2022 Meeting","permalink":"/blog/2023-03-26-kcl-os2atc-meeting"}},"content":"\x3c!-- KCL v0.4.6 is Coming - New IDE Extension, Helm/Kustomize/KPT Integrations--\x3e\\n\\n## Introduction\\n\\nThe KCL team is pleased to announce that KCL v0.4.6 is now available! This release has brought three key updates to everyone: **Language**, **Tools**, and **Integrations**.\\n\\n+ *Use KCL IDE extensions to improve KCL code writing experience and efficiency*\\n+ *Helm/Kustomize/KPT cloud-native community tool integrations*\\n+ *Improve the KCL multilingual SDK for easy application integration*\\n\\nYou can visit the [KCL release page](https://github.com/kcl-lang/kcl/releases/tag/v0.4.6) or the [KCL website](https://kcl-lang.io/) to get KCL binary download link and more detailed release information.\\n\\n[KCL](https://github.com/kcl-lang/kcl) is an open-source, constraint-based record and functional language. KCL improves the writing of numerous complex configurations, such as cloud-native scenarios, through its mature programming language technology and practice. It is dedicated to building better modularity, scalability, and stability around configurations, simpler logic writing, faster automation, and great built-in or API-driven integrations.\\n\\nThis blog will introduce the content of KCL v0.4.6 and recent developments in the KCL community to readers.\\n\\n## Language\\n\\n### Builtin Functions\\n\\nAdded KCL string `removeprefix` and `removesuffix` member functions to remove prefix and suffix substrings from strings\\n\\n```python\\ndata1 = \\"prefix-string\\".removeprefix(\\"prefix-\\") # \\"string\\" \\ndata2 = \\"string-suffix\\".removesuffix(\\"-suffix\\") # \\"string\\"\\n```\\n\\nSee [here](https://kcl-lang.io/docs/reference/model/builtin#string-builtin-member-functions) for more.\\n\\n### Compiler Information\\n\\nIn previous versions of KCL, running the KCL command-line tool once only displayed one error message and warning. In KCL v0.4.6, it supported the ability to display multiple errors and warnings in one compilation and improved error information to improve the efficiency of KCL code error troubleshooting, such as for the following KCL code (main.k).\\n\\n```python\\nmetadata = {\\n    labels = {key = \\"kcl\\n}\\n```\\n\\nExecute the following KCL command, then you can see the syntax errors including the unterminated string and the brace mismatch errors.\\n\\n```shell\\nkcl main.k\\n```\\n\\nThe output is\\n\\n```shell\\nerror[E1001]: InvalidSyntax\\n --\x3e main.k:2:21\\n  |\\n2 |     labels = {key = \\"kcl\\n  |                     ^ unterminated string\\n  |\\n\\nerror[E1001]: InvalidSyntax\\n --\x3e main.k:2:24\\n  |\\n2 |     labels = {key = \\"kcl\\n  |                        ^ expected \\"}\\"\\n  |\\n```\\n\\n### Top-level schema assign statement union operator\\n\\nIn previous versions of KCL, when writing the following KCL code, the two schema configurations with the same name were merged and output. In KCL v0.4.6, it was required to explicitly use the attribute merge operator instead of the attribute overlay operator.\\n\\n+ Before\\n\\n```python\\nschema Config:\\n    id?: int\\n    value?: str\\n\\nconfig = Config {\\n    id = 1\\n}\\nconfig = Config {\\n    value = \\"value\\"\\n}\\n```\\n\\n+ After\\n\\n```python\\nschema Config:\\n    id?: int\\n    value?: str\\n\\n# Use the union operator `:` instead of the override operator\\nconfig: Config {\\n    id = 1\\n}\\n# Use the union operator `:` instead of the override operator\\nconfig: Config {\\n    value = \\"value\\"\\n}\\n```\\n\\n### Path selector simplification\\n\\nWe use the path selector CLI parameter (-S) without filling in the package path, and can directly filter internal variables.\\n\\nFor the KCL code (main.k):\\n\\n```python\\nschema Person:\\n    name: str\\n    age: int\\n\\nperson = Person {\\n    name = \\"Alice\\"\\n    age = 18\\n}\\n```\\n\\nWe run the following command:\\n\\n```shell\\nkcl main.k -S person\\n```\\n\\nThe output is\\n\\n```yaml\\nname: Alice\\nage: 18\\n```\\n\\n### Bugfix\\n\\n#### Inline conditional configuration block syntax error\\n\\nBefore KCL v0.4.6, an unexpected syntax error will appear when writing the following KCL code. In the new version, we fixed similar issues.\\n\\n```python\\nenv = \\"prod\\"\\nconfig = {if env == \\"prod\\": labels = {\\"kubernetes.io/env\\" = env}}\\n```\\n\\n#### Schema required attribute check\\n\\nIn previous versions of KCL, for the following KCL code, there was an error where the `versions` attribute was not assigned as expected. In KCL v0.4.6, we fixed similar issues.\\n\\n```python\\nschema App:\\n    data?: [int]\\n    version: Version\\n\\nschema Version:\\n    versions: [str]\\n\\napp = App {\\n    version = Version {}\\n}\\n```\\n\\n## Tools\\n\\n### KCL VS Code Extension\\n\\nIn this version, we have released a new KCL VS Code extension and a language service server rewritten using the Rust language, which has improved performance by about 20 times compared to previous KCL IDE versions. We also support real-time display of KCL errors and warnings in the IDE, as well as new features such as KCL code completion.\\n\\n+ **Real-time display of KCL errors and warnings**\\n\\n![Diagnostics](/img/docs/tools/Ide/vs-code/Diagnostics.gif)\\n\\n+ **Go to Definition**\\n\\n![Goto Definition](/img/docs/tools/Ide/vs-code/GotoDef.gif)\\n\\n+ **Completion**\\n\\n![Completion](/img/docs/tools/Ide/vs-code/Completion.gif)\\n\\n+ **Hover**\\n\\n![Hover](/img/docs/tools/Ide/vs-code/Hover.gif)\\n\\nSee [here](https://kcl-lang.io/docs/tools/Ide/vs-code) for more.\\n\\n\\n\\n### Package Management Tools\\n\\nIn the new version of KCL v0.4.6, we have provided a new KCL package management tool with the alpha version, which allows users to access the KCL modules in the community with a few commands. For example, the KCL Kubernetes model can be imported through the following command.\\n\\n```shell\\nkpm init kubernetes_demo && kpm add -git https://github.com/awesome-kusion/konfig.git -tag v0.0.1\\n```\\n\\nWrite a KCL code to import the Kubernetes models (main.k).\\n\\n```python\\nimport konfig.base.pkg.kusion_kubernetes.api.apps.v1 as apps\\n\\napps.Deployment {\\n    metadata.name = \\"nginx-deployment\\"\\n    spec = {\\n        replicas = 3\\n        selector.matchLabels.app = \\"nginx\\"\\n        template.metadata.labels = selector.matchLabels\\n        template.spec.containers = [\\n            {\\n                name = selector.matchLabels.app\\n                image = \\"nginx:1.14.2\\"\\n                ports = [\\n                    {containerPort = 80}\\n                ]\\n            }\\n        ]\\n    }\\n}\\n```\\n\\nExecute the following command to run the KCL code to obtain an nginx deployment YAML output.\\n\\n```shell\\nkpm run\\n```\\n\\nThe output is\\n\\n```yaml\\napiVersion: apps/v1\\nkind: Deployment\\nmetadata:\\n  name: nginx-deployment\\nspec:\\n  replicas: 3\\n  selector:\\n    matchLabels:\\n      app: nginx\\n  template:\\n    metadata:\\n      labels:\\n        app: nginx\\n    spec:\\n      containers:\\n        - image: \\"nginx:1.14.2\\"\\n          name: nginx\\n          ports:\\n            - containerPort: 80\\n```\\n\\n+ See [here](https://kcl-lang.io/docs/user_docs/guides/package-management/overview) for more information about the **kpm** tool.\\n+ See [here](https://kcl-lang.io/docs/user_docs/guides/working-with-konfig/overview) for more information about the **konfig** model.\\n\\n## Integrations\\n\\n### Kubernetes Tool Integrations\\n\\nIn KCL v0.4.6, we provide KCL plugin support for configuration management tools such as Helm, Kustomize, and KPT in the Kubernetes community using a unified programming interface. Writing a few lines of KCL code can non-intrusively complete the mutation and validation of existing Kustomize YAML and Helm Charts.\\n\\nFor example, writing a small amount of KCL code to modify resource labels/annotations, injecting sidecar container configuration, and using KCL schema to verify resources.\\n\\nBelow is a detailed explanation of the integration of KCL using the Kustomize tool. There is no need to install any KCL-related binaries to use the Kustomize KCL plugin, just install the Kustomize tool locally.\\n\\nFirstly, execute the following command to obtain a Kustomize YAML configuration example:\\n\\n```shell\\ngit clone https://github.com/kcl-lang/kustomize-kcl.git &&cd ./kustomize-kcl/examples/set-annotation/\\n```\\n\\nThen execute the following command using KCL code to add only one `managed-by=kustomize-kcl` annotation for all `Deployment` resources\\n\\n```shell\\nsudo kustomize fn run ./local-resource/ --as-current-user --dry-run\\n```\\n\\nThe output YAML is:\\n\\n```yaml\\napiVersion: v1\\nkind: Service\\nmetadata:\\n  name: test\\n  annotations:\\n    config.kubernetes.io/path: example-use.yaml\\n    internal.config.kubernetes.io/path: example-use.yaml\\nspec:\\n  selector:\\n    app: MyApp\\n  ports:\\n  - protocol: TCP\\n    port: 80\\n    targetPort: 9376\\n---\\napiVersion: apps/v1\\nkind: Deployment\\nmetadata:\\n  name: nginx-deployment\\n  labels:\\n    app: nginx\\n  annotations:\\n    config.kubernetes.io/path: example-use.yaml\\n    internal.config.kubernetes.io/path: example-use.yaml\\n    # This annotation is added through the kcl code.\\n    managed-by: kustomize-kcl\\nspec:\\n  replicas: 3\\n  selector:\\n    matchLabels:\\n      app: nginx\\n  template:\\n    metadata:\\n      labels:\\n        app: nginx\\n    spec:\\n      containers:\\n      - name: nginx\\n        image: nginx:1.14.2\\n        ports:\\n        - containerPort: 80\\n```\\n\\nIn the YAML configuration mentioned above, we only wrote one line of KCL code to add a `managed-by=kustomize-kcl` annotation to all deployment resources.\\n\\n```python\\n[resource | {if resource.kind == \\"Deployment\\": metadata.annotations: {\\"managed-by\\" = \\"kcl\\"}} for resource in option(\\"resource_list\\").item]\\n```\\n\\nIn addition, we have provided commonly used container and service configuration mutation and validation KCL models for Kustomize/Helm/KPT tools and will continue to improve them.\\n\\n+ See [here](https://kcl-lang.io/docs/user_docs/guides/working-with-k8s/kustomize_kcl_plugin) for more information about the Kustomize KCL plugin.\\n+ See [here](https://kcl-lang.io/docs/user_docs/guides/working-with-k8s/helm_kcl_plugin) for more information about the Helm KCL Plugin.\\n+ See [here](https://kcl-lang.io/docs/user_docs/guides/working-with-k8s/kpt_kcl_sdk) for more information about the KPT KCL Plugin.\\n\\n### Multilingual SDK\\n\\nIn this new version, we have released a new kclvm-go SDK that integrates KCL into your Go application and provides rich APIs for interacting with KCL. You can click [here](https://kcl-lang.io/docs/next/reference/xlang-api/go-api) for detailed API documents. In addition, we have also updated the following features and bug fixes:\\n\\n+ Thank @jakezhu9 for fixing unexpected KCL formatting API unit testing errors in CI Pipeline for kclvm-go.\\n+ Thank @Ekko for contributing to the bidirectional conversion support of Go struct and KCL schema. Please refer to:\\n  + [Go struct -> KCL schema](https://github.com/kcl-lang/kcl-go/blob/main/pkg/tools/gen/genkcl.go#L23)\\n  + [KCL schema -> Go struct](https://github.com/kcl-lang/kcl-go/blob/main/pkg/tools/gen/gengo.go#L23)\\n+ Support for conversion from KCL schema to protobuf message, see [here](https://github.com/kcl-lang/kcl-go/blob/main/pkg/tools/gen/genpb.go#L25) for more.\\n+ Support APIs for obtaining schema types and instances from the KCL code, see [here](https://kcl-lang.io/docs/reference/xlang-api/go-api#func-getschematype) for more.\\n\\n## Other updates and bug fixes\\n\\n+ The KCL Python plugin function is not enabled by default. If you need to enable it, please refer to the [plugin document](https://kcl-lang.io/docs/reference/plugin/overview).\\n+ KCL playground supports code-sharing capabilities, which can be accessed by visiting the [KCL website](https://kcl-lang.io/) and clicking on the playground button to experience.\\n+ See [here](https://github.com/kcl-lang/kcl/milestone/3?closed=1) for more updates and bug fixes.\\n\\n## Documents\\n\\nThe versioning semantic option is added to the [KCL website](https://kcl-lang.io/). Currently, v0.4.3, v0.4.4, v0.4.5, and v0.4.6 versions are supported.\\n\\n## Next\\n\\nIt is expected that in the middle of 2023, we will release **KCL v0.5.0**. The expected key evolution includes:\\n\\n+ More IDE extensions, package management tools, Helm/Kustomize/KPT scenario integration, feature support, and user experience improvement.\\n+ Provide more out-of-box KCL model support for cloud-native scenarios, mainly including containers, services, computing, storage, and networks.\\n+ Support KCL Schema to directly generate Kubernetes CRD.\\n+ Support `kubectl` and `helmfile` KCL plugins, directly generating, mutating, and validating Kubernetes resources through the KCL code.\\n+ Support for mutating and validating YAML by running KCL code through the admission controller at the Kubernetes runtime.\\n+ More support for non-Kubernetes scenarios, such as data cleaning of AI models through the KCL schema and database schema integration support.\\n\\nFor more details, please refer to [KCL v0.5.0 Milestone](https://github.com/kcl-lang/kcl/milestone/5)\\n\\n## FAQ\\n\\nFor more information, see [KCL FAQ](https://kcl-lang.io/docs/user_docs/support/).\\n\\n## Additional Resources\\n\\nThank all KCL users for their valuable feedback and suggestions during this version release. For more resources, please refer to:\\n\\n+ [KCL Website](https://kcl-lang.io/)\\n+ [Kusion Website](https://kusionstack.io/)\\n+ [KCL Repo](https://github.com/kcl-lang/kcl)\\n+ [Kusion Repo](https://github.com/KusionStack/kusion)\\n+ [Konfig Repo](https://github.com/KusionStack/konfig)\\n\\nSee the [community](https://github.com/kcl-lang/community) for ways to join us. \ud83d\udc4f\ud83d\udc4f\ud83d\udc4f"},{"id":"2023-03-26-kcl-os2atc-meeting","metadata":{"permalink":"/blog/2023-03-26-kcl-os2atc-meeting","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-03-26-kcl-os2atc-meeting/index.md","source":"@site/blog/2023-03-26-kcl-os2atc-meeting/index.md","title":"KCL Introduction on OS2ATC 2022 Meeting","description":"KCL Talk Cover","date":"2023-03-26T00:00:00.000Z","formattedDate":"March 26, 2023","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Configuration","permalink":"/blog/tags/configuration"},{"label":"Policy","permalink":"/blog/tags/policy"}],"readingTime":0.025,"hasTruncateMarker":false,"authors":[{"name":"Pengfei, Xu","title":"KCL Team Member"}],"frontMatter":{"slug":"2023-03-26-kcl-os2atc-meeting","title":"KCL Introduction on OS2ATC 2022 Meeting","authors":{"name":"Pengfei, Xu","title":"KCL Team Member"},"tags":["KCL","Configuration","Policy"]},"prevItem":{"title":"KCL v0.4.6 Release Blog","permalink":"/blog/2022-kcl-0.4.6-release-blog"},"nextItem":{"title":"KCL v0.4.6-alpha.1 Release Blog","permalink":"/blog/2022-kcl-0.4.6-alpha.1-release-blog"}},"content":"![KCL Talk Cover](/img/blog/2023-03-26-kcl-os2atc-meeting/talk-cover.jpg)\\n\\n[Download PDF](https://kcl-lang.github.io/talks/kcl-os2atc2022.pdf)"},{"id":"2022-kcl-0.4.6-alpha.1-release-blog","metadata":{"permalink":"/blog/2022-kcl-0.4.6-alpha.1-release-blog","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-03-20-kcl-0.4.6-alpha.1-release/index.md","source":"@site/blog/2023-03-20-kcl-0.4.6-alpha.1-release/index.md","title":"KCL v0.4.6-alpha.1 Release Blog","description":"Introduction","date":"2023-03-20T00:00:00.000Z","formattedDate":"March 20, 2023","tags":[{"label":"Release Blog","permalink":"/blog/tags/release-blog"},{"label":"KCL","permalink":"/blog/tags/kcl"}],"readingTime":1.17,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2022-kcl-0.4.6-alpha.1-release-blog","title":"KCL v0.4.6-alpha.1 Release Blog","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["Release Blog","KCL"]},"prevItem":{"title":"KCL Introduction on OS2ATC 2022 Meeting","permalink":"/blog/2023-03-26-kcl-os2atc-meeting"},"nextItem":{"title":"The new playground of the KCL programming language is coming!","permalink":"/blog/2023-kcl-playground-0.4.5-release"}},"content":"## Introduction\\n\\nThe KCL team is pleased to announce that KCL v0.4.6-alpha.1 is now available!\\n\\nYou can visit the [KCL release page](https://github.com/kcl-lang/kcl/releases/tag/v0.4.6-alpha.1) or the [KCL website](https://kcl-lang.io/) to get KCL binary download link and more detailed release information.\\n\\n[KCL](https://github.com/kcl-lang/kcl) is an open-source, constraint-based record and functional language. KCL improves the writing of numerous complex configurations, such as cloud-native scenarios, through its mature programming language technology and practice. It is dedicated to building better modularity, scalability, and stability around configurations, simpler logic writing, faster automation, and great built-in or API-driven integrations.\\n\\n## Release Content\\n\\n+ Lexical error recovery including numbers, literal values, parentheses, etc\\n+ KCL IDE plug-in supports error and warning display, go-to-definition, and other capabilities.\\n+ Some compiler error reporting improvements\\n+ KCL Playground supports code sharing capabilities\\n+ [KPT Tool KCL SDK](https://github.com/kcl-lang/kcl/issues/434)\\n+ [Helm KCL Plugin](https://github.com/kcl-lang/kcl/issues/426)\\n\\n## Next\u200b\\n\\n+ KPM package management tool release\\n+ More KCL compiler syntax error recovery supports the release of new IDE plug-ins, with an expected performance improvement of 20 times\\n+ KCL integration of Kubernetes tools such as Helm and KPT release\\n\\n## FAQ\\n\\nFor more information, see [KCL FAQ](https://kcl-lang.io/docs/user_docs/support/).\\n\\n## Additional Resources\\n\\nThank all KCL users for their valuable feedback and suggestions during this version release. For more resources, please refer to:\\n\\n+ [KCL Website](https://kcl-lang.io/)\\n+ [Kusion Website](https://kusionstack.io/)\\n+ [KCL Repo](https://github.com/kcl-lang/kcl)\\n+ [Kusion Repo](https://github.com/KusionStack/kusion)\\n+ [Konfig Repo](https://github.com/KusionStack/konfig)\\n\\nSee the [community](https://github.com/kcl-lang/community) for ways to join us. \ud83d\udc4f\ud83d\udc4f\ud83d\udc4f"},{"id":"2023-kcl-playground-0.4.5-release","metadata":{"permalink":"/blog/2023-kcl-playground-0.4.5-release","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-03-17-kcl-playground-0.4.5-release/index.md","source":"@site/blog/2023-03-17-kcl-playground-0.4.5-release/index.md","title":"The new playground of the KCL programming language is coming!","description":"Introduction","date":"2023-03-17T00:00:00.000Z","formattedDate":"March 17, 2023","tags":[{"label":"Release Blog","permalink":"/blog/tags/release-blog"},{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Playground","permalink":"/blog/tags/playground"}],"readingTime":0.995,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2023-kcl-playground-0.4.5-release","title":"The new playground of the KCL programming language is coming!","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["Release Blog","KCL","Playground"]},"prevItem":{"title":"KCL v0.4.6-alpha.1 Release Blog","permalink":"/blog/2022-kcl-0.4.6-alpha.1-release-blog"},"nextItem":{"title":"KCL v0.4.5 Release Blog","permalink":"/blog/2022-kcl-0.4.5-release-blog"}},"content":"## Introduction\\n\\nThe KCL team is pleased to announce that the new playground of KCL v0.4.5 is now available!\\n\\n[KCL](https://github.com/kcl-lang/kcl) is an open-source, constraint-based record and functional language. KCL improves the complexity of writing numerous complex configurations, such as cloud-native scenarios, through its mature programming language technology and practice. It is dedicated to building better modularity, scalability, and stability around configurations, simpler logic writing, faster automation, and great built-in or API-driven integrations.\\n\\nYou can visit the [KCL website](https://kcl-lang.io/) and click the playground link and play. In this new version, we support the ability to automatically compile and run KCL code, format it, and share code. Welcome to writing and sharing KCL codes.\\n\\n![](/img/blog/2023-03-17-kcl-playground-0.4.5-release/kcl-website-playground.png)\\n\\n![](/img/blog/2023-03-17-kcl-playground-0.4.5-release/kcl-playground.png)\\n\\n## Next\u200b\\n\\nIt is expected that in the middle of April 2023, we will release a new KCL Playground including KCL version selection, reference to Github code, and other capabilities.\\n\\n## FAQ\\n\\nFor more information, see [KCL FAQ](https://kcl-lang.io/docs/user_docs/support/).\\n\\n## Additional Resources\\n\\nThank all KCL users for their valuable feedback and suggestions during this version release. For more resources, please refer to:\\n\\n+ [KCL Website](https://kcl-lang.io/)\\n+ [Kusion Website](https://kusionstack.io/)\\n+ [KCL Repo](https://github.com/kcl-lang/kcl)\\n+ [Kusion Repo](https://github.com/KusionStack/kusion)\\n+ [Konfig Repo](https://github.com/KusionStack/konfig)\\n\\nSee the [community](https://github.com/kcl-lang/community) for ways to join us. \ud83d\udc4f\ud83d\udc4f\ud83d\udc4f"},{"id":"2022-kcl-0.4.5-release-blog","metadata":{"permalink":"/blog/2022-kcl-0.4.5-release-blog","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-02-27-kcl-0.4.5-release-blog/index.md","source":"@site/blog/2023-02-27-kcl-0.4.5-release-blog/index.md","title":"KCL v0.4.5 Release Blog","description":"Introduction","date":"2023-02-27T00:00:00.000Z","formattedDate":"February 27, 2023","tags":[{"label":"Release Blog","permalink":"/blog/tags/release-blog"},{"label":"KCL","permalink":"/blog/tags/kcl"}],"readingTime":11.215,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2022-kcl-0.4.5-release-blog","title":"KCL v0.4.5 Release Blog","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["Release Blog","KCL"]},"prevItem":{"title":"The new playground of the KCL programming language is coming!","permalink":"/blog/2023-kcl-playground-0.4.5-release"},"nextItem":{"title":"KCL Introduction on OSDT 2022 Meeting","permalink":"/blog/2022-kcl-osdt-meeting"}},"content":"## Introduction\\n\\nThe KCL team is pleased to announce that KCL v0.4.5 is now available! This release is mainly aimed at improving the convenience and stability of KCL language writing, improving error information, and supporting more platforms including Windows version and more download methods. In KCL v0.4.5, users can eliminate more configuration templates by writing fewer KCL codes. In the new version, preliminary KCL Playground support is provided, which can be used to write and run KCL code online without installation. In addition, this release also includes many compiler error information optimization and bug fixes.\\n\\nYou can visit the [KCL release page](https://github.com/kcl-lang/kcl/releases/tag/v0.4.5) or the [KCL website](https://kcl-lang.io/) to get KCL binary download link and more detailed release information.\\n\\n[KCL](https://github.com/kcl-lang/kcl) is an open-source, constraint-based record and functional language. KCL improves the writing of numerous complex configurations, such as cloud-native scenarios, through its mature programming language technology and practice. It is dedicated to building better modularity, scalability, and stability around configurations, simpler logic writing, faster automation, and great built-in or API-driven integrations.\\n\\nThis blog will introduce the content of KCL v0.4.5 and recent developments in the KCL community to readers.\\n\\n## Features\\n\\n### Language Writing Convenience Improvement\\n\\n#### Lazy Validation of Non-null Attributes in the KCL Schema\\n\\nIn previous KCL versions, we have supported the lazy evaluation and validation capabilities of schema attribute cross-reference (including inheritance) and check expressions. In this version, we have supported more schema lazy evaluation capabilities such as the schema attribute non-null lazy validation. For example, for the following KCL codes:\\n\\n```python\\nschema Spec:\\n    id: int\\n    value: str\\n\\nschema Config:\\n    name?: str\\n    spec: Spec = Spec {  \\n        id = 1\\n    } # Before KCL v0.4.5, this statement will report an attribute non-null error. After v0.4.5, the schema non-null attribute lazy validation is supported\\n\\nconfig = Config {\\n    spec.value = \\"value\\"\\n}\\n```\\n\\nBefore KCL v0.4.5, directly executing the above code will throw an error that the `value` attribute of `spec` cannot be `None` at the `spec: Spec=Spec {` statement block of the `schema Config`, because only the `id` attribute of `spec` is assigned a value of `1`, and no value is assigned to the `value` attribute of `spec`.\\n\\nAfter KCL v0.4.5, we will avoid throwing this error after supporting the lazy non-null validation capability of the schema attribute. That is, when the `spec.value=\\"value\\"` and `spec.id=1` of the `config` attributes are merged, all the attributes of `config` will be checked recursively for non-null. At this time, all the values of the `spec` attribute are fully assigned (the value of the `id` attribute of `spec` is `1`, and the `value` attribute is `\\"value\\"`), the error that the required schema attribute is null will not be thrown.\\n\\nTherefore, after KCL v0.4.5 and executing the above KCL code, we will get the complete YAML output as follows:\\n\\n```yaml\\nconfig:\\n  spec:\\n    id: 1\\n    value: value\\n```\\n\\n#### Mutual Reference of Configuration Block Attributes\\n\\nIn versions before v0.4.5, KCL has not yet supported the mutual reference of attributes within the configuration block, resulting in the need to define additional configuration variables or templates for reference in some scenarios, resulting in more configuration templates and duplicate codes, such as the KCL code shown below:\\n\\n```python\\nname = \\"app-name\\"\\ndata = {\\n    name = name\\n    metadata.name = name  # `metadata.name` cannot directly reference the `name` attribute inside the `data` configuration.\\n}\\n```\\n\\nThe `metadata.name` attribute of the `data` configuration block cannot directly reference the `name` attribute inside the `data`. We need to define an additional global variable `name` for reference.\\n\\nAfter KCL v0.4.5, we support the feature of mutual reference of configuration block attributes, which can be used to eliminate more configuration templates, such as the KCL code shown below:\\n\\n```python\\ndata = {\\n    name = \\"app-name\\"\\n    metadata.name = name  # Directly reference the name attribute of the `data` configuration\\n}\\n```\\n\\nThe `metadata.name` attribute of the `data` configuration block can directly reference the `name` attribute inside the `data` without defining additional global variables.\\n\\nThe following YAML output can be obtained by executing the above KCL code:\\n\\n```yaml\\ndata:\\n  name: app-name\\n  metadata:\\n    name: app-name\\n```\\n\\nHere is a more complex example:\\n\\n```python\\nname = \\"global-name\\"\\nmetadata = {\\n    name = \\"metadata-name\\"\\n    labels = {\\n        \\"app.kubernetes.io/name\\" = name  # Directly reference `metadata.name`\\n        \\"app.kubernetes.io/instance\\" = name  # Directly reference `metadata.name`\\n    }\\n}\\ndata = {\\n    name = name  # Reference the global variable `name`\\n    metadata = metadata  # Reference global variables `metadata`\\n    spec.template.metadata.name = metadata.name  # Reference `metadata` variables inside `data`.\\n}\\n```\\n\\nThe following YAML output can be obtained by executing the above code:\\n\\n```yaml\\nname: global-name\\nmetadata:\\n  name: metadata-name\\n  labels:\\n    app.kubernetes.io/name: metadata-name\\n    app.kubernetes.io/instance: metadata-name\\ndata:\\n  name: global-name\\n  metadata:\\n    name: metadata-name\\n    labels:\\n      app.kubernetes.io/name: metadata-name\\n      app.kubernetes.io/instance: metadata-name\\n  spec:\\n    template:\\n      metadata:\\n        name: metadata-name\\n```\\n\\n> \u26a0\ufe0f Note: The current KCL version does not support the backward reference of the internal attributes of the configuration block and the direct reference of global variables by skipping the internal scope. The referenced attributes need to be written in front of the configuration reference.\\n\\n### New Language Features\\n\\n#### Index Formatting of String Format Member function\\n\\nAfter KCL v0.4.5, KCL supports the use of the index tag style format `<format_ele_index>[<index_or_key>]` in the `{}` format block for KCL variables of list and dictionary types similar to the Python language.\\n\\n+ `<format_ele_index>` indicates the index that is needed to serialize list and dictionary-type elements.\\n+ `<index_or_key>` indicates the list sub-element index or dictionary sub-element key value of the corresponding list and dictionary type element.\\n\\nFor example, for the following KCL code\\n\\n```python\\n# 0[0] means taking the 0th element of [\\"Hello\\", \\"World\\"]: \\"Hello\\"\\n# 0[1] means taking the 1th element of [\\"Hello\\", \\"World\\"]: \\"\\"World\\"\\nlistIndexFormat = \\"{0[0]}{0[1]}\\".format([\\"Hello\\", \\"World\\"])\\n# 0[0] means taking the 0th element of [\\"0\\", \\"1\\"]: \\"0\\"\\n# 1[Hello] means taking {\\"Hello\\": \\"World\\"} dictionary element whose key value is Hello: \\"World\\"\\ndictIndexFormat = \\"0{0[0]}, 1{0[1]}, Hello{1[Hello]}\\".format([\\"0\\", \\"1\\"], {\\"Hello\\": \\"World\\"})\\n```\\n\\nThe following YAML output can be obtained by executing the above code:\\n\\n```yaml\\nlistIndexFormat: HelloWorld\\ndictIndexFormat: \\"00, 11, HelloWorld\\"\\n```\\n\\n### KCL Playground\\n\\nIn this update, we have updated the version of the KCL playground and support the automatic compilation and formatting of KCL code. You can visit the [KCL website](https://kcl-lang.io/) and click the playground button to experience it.\\n\\n![](/img/blog/2023-02-27-kcl-0.4.5-release-blog/kcl-website-playground.png)\\n\\n![](/img/blog/2023-02-27-kcl-0.4.5-release-blog/kcl-playground.png)\\n\\nIn the subsequent KCL versions, we will continue to update the KCL playground to support more capabilities, such as KCL version selection and code sharing.\\n\\n### More Platforms and Download Methods for KCL\\n\\n#### Windows\\n\\nKCL Windows binary version can now be downloaded from [Github](https://github.com/kcl-lang/kcl/releases/) manually. After the download, add `{install_location}\\\\kclvm\\\\bin` to the environment variable `PATH`.\\n\\n```powershell\\n$env:PATH += \\";{install-location}\\\\kclvm\\\\bin;\\"\\n```\\n\\nIn addition, you can also install KCL through the Powershell script shown below:\\n\\n```powershell\\npowershell -Command \\"iwr -useb https://kcl-lang.io/script/install.ps1 | iex\\"\\n```\\n\\nWe will support more Windows package management download methods in the future, such as `Scoop`.\\n\\n#### More Download Methods\\n\\nIn this version update, we support more KCL download methods, including scripts, Python, Go, Homebrew, and Docker one-click installation. For more details, please refer to [KCL Download and Installation](https://kcl-lang.io/docs/user_docs/getting-started/install), we will support more KCL installation methods in the future.\\n\\n> \u26a0\ufe0f Note: For all the above operating systems and installation methods, if you want to use [KCL Python plug-in](https://kcl-lang.io/docs/reference/plugin/overview), you need to ensure that Python 3.7+ is installed and add the python3 command to your PATH environment variable.\\n\\n## Bugfix\\n\\n### The configuration merge order is incorrect when the right value of a non-configured expression exists\\n\\n```python\\nschema Resource:\\n    cpu: int\\n    memory: str\\n\\nschema Config:\\n    resource: Resource\\n\\nr = Resource {\\n    cpu = 4\\n    memory = \\"8Gi\\"\\n}\\n\\nconfig: Config {\\n    resource: Resource {\\n        cpu = 2\\n        memory = \\"4Gi\\"\\n    }\\n}\\n\\nconfig: Config {\\n    resource: r\\n}\\n```\\n\\nBefore KCL v0.4.5, executing the above code (main.k) will get unexpected configuration values because the KCL compiler incorrectly optimized the following form of equivalent merge configuration blocks:\\n\\n```python3\\nconfig: Config {\\n    resource: r\\n    resource: Resource {\\n        cpu = 2\\n        memory = \\"4Gi\\"\\n    }\\n}\\n```\\n\\nAfter KCL v0.4.5, the incorrect configuration of the merge order is corrected. You can execute `main.k` and obtain the expected YAML output:\\n\\n```yaml\\nr:\\n  cpu: 4\\n  memory: 8Gi\\nconfig:\\n  resource:\\n    cpu: 4\\n    memory: 8Gi\\n```\\n\\nFor more information, see [KCL Issue #422](https://github.com/kcl-lang/kcl/issues/422).\\n\\n### Configure if expression type mismatch error optimization\\n\\n```python\\nconfig: {\\"A\\"|\\"B\\": int} = {\\n    if True:\\n        A = \\"2\\"\\n}\\n```\\n\\nBefore KCL v0.4.5, for the configuration if expression, executing the above code will get the expected configuration value, resulting in the type unsoundness problem, because the KCL compiler incorrectly checks that the value `\\"2\\"` of the `A` attribute does not match the declared type `int`. After the KCL v0.4.5, this problem has been corrected. You can execute the above code to obtain the expected type mismatch error:\\n\\n```stderr\\nKCL Compile Error[E2G22] : The type got is inconsistent with the type expected\\n---\x3e File main.k:1:1\\n1 |config: {\\"A\\"|\\"B\\": int} = {\\n 1 ^  -> got {str(A):str(2)}\\nexpect {str(A)|str(B):int}, got {str(A):str(2)}\\n```\\n\\nFor more information, see [KCL Issue #389](https://github.com/kcl-lang/kcl/issues/389).\\n\\n### Rule statement validation does not work\\n\\nIn previous KCL versions, when the following rule code is used (main.k), the constraint code of `ServiceCheckRule` will not take effect.\\n\\n```python\\nprotocol KubeResourceProtocol:\\n    svc: Service\\n\\nschema Service:\\n    name: str\\n\\nrule ServiceCheckRule for KubeResourceProtocol:\\n    svc.name != \\"name\\"\\n\\nsvc = Service {\\n    name = \\"name\\"\\n}\\n\\nServiceCheckRule {\\n    svc = svc\\n}\\n```\\n\\nAfter the improvement, we execute the above code and get an accurate validation failure error:\\n\\n```stderr\\nKCL Runtime Error[E3B17] : Schema check is failed to check condition\\n---\x3e File main.k:14\\n14 |ServiceCheckRule { -> Instance check failed\\n    ---\x3e File main.k:8\\n    8 |    svc.name != \\"name\\" -> Check failed on the condition\\nCheck failed on check conditions\\n```\\n\\n### Configuration block attribute type inference optimization\\n\\n```python\\nschema Id:\\n    id?: int = 1\\n\\nschema Config:\\n    data?: {\\"A\\"|\\"B\\": Id}\\n\\nc = Config {\\n    data = {\\n        A = Id()  # Before v0.4.5, we will get a type mismatch error here.\\n        B = Id()\\n    }\\n}\\n```\\n\\nBefore KCL v0.4.5, executing the above code would result in an unexpected type mismatch, because the KCL compiler incorrectly deduced the type of the `c.data.A` attribute to the `str` type, resulting in a mismatch error with the string literal union type `\\"A\\"|\\"B\\"`. After KCL v0.4.5 was updated, this problem was corrected, and the expected YAML output could be obtained by executing the above code:\\n\\n```yaml\\nc:\\n  data:\\n    A:\\n      id: 1\\n    B:\\n      id: 1\\n```\\n\\n### Assignment statement uses schema type annotation error optimization\\n\\n```python\\nschema Foo:\\n    foo: int\\n\\nschema Bar:\\n    bar: int\\n\\nfoo: Foo = Bar {  # Before v0.4.5, we will get a runtime type mismatch error here\\n    bar: 1\\n}\\n```\\n\\nBefore KCL v0.4.5, executing the above code will result in a runtime type mismatch error. After the version is updated, this type mismatch error will be optimized to compile time, and the error will be moved to the left to find this type of error earlier.\\n\\n### Error on KCL module type with the ?. operator\\n\\n```python\\nimport math\\n\\ndata = math?.log(10)  # Before v0.4.5, we will get an unexpected \'math is not defined\' error here\\n```\\n\\nBefore KCL v0.4.5, executing the above code will result in an unexpected undefined variable error because the KCL compiler does not correctly handle the `math` module type and the `?.` operators are used in combination. After KCL v0.4.5, such issues are fixed.\\n\\n## Other Updates and Issues\\n\\nFor more updates and bug fixes, see [here](https://github.com/kcl-lang/kcl/milestone/3)\\n\\n## Documents\\n\\nThe versioning semantic option is added to the [KCL website](https://kcl-lang.io/). Currently, v0.4.3, v0.4.4, and v0.4.5 versions are supported.\\n\\n![](/img/blog/2023-02-27-kcl-0.4.5-release-blog/kcl-website-doc-version.png)\\n\\n## Community\\n\\n+ Two external contributors @thinkrapido and @Rishav1707 have participated in the KCL community, thank them for their enthusiasm and active participation in contributing.\\n+ Thank @Rishav1707 for establishing the Rust version of [kcl-loader-rs](https://github.com/i-think-rapido/kcl-loader-rs) sub-project based on KCL, which supports the automatic generation of Rust structure according to the schema and configuration definition in the KCL file and the deserialization function from KCL value to Rust structure value.\\n\\n## Next\\n\\nIt is expected that in the middle of April 2023, we will release **KCL v0.4.6**. The expected key evolution includes:\\n\\n+ KCL language is further improved for convenience, the user interface is continuously optimized and experience is improved, user support and pain points are solved.\\n+ A new version of the KCL language server and [VSCode language plug-in](https://github.com/kcl-lang/vscode-kcl), the performance is expected to increase by **20 times**, and it is expected to support core basic capabilities such as code warning and error wavy line prompt, jump, reference search, etc.\\n+ Continuously improve the language ability for the pain points of Kubernetes Manifests configuration management scenarios. For example, design and provide the [Helm](https://github.com/helm/helm) KCL Schema plug-in and provide the KCL SDK for the [kpt](https://github.com/GoogleContainerTools/kpt) tool.\\n+ [KCL package management tool called KPM](https://github.com/kcl-lang/kpm) release. It is expected to support Git repo code dependency configuration and update, code download, and other basic capabilities.\\n+ [KCL Playground](https://github.com/kcl-lang/kcl-playground): Support code sharing and KCL version selection.\\n+ [KCL Go SDK](https://github.com/kcl-lang/kcl-go): More capability support such as supporting the bidirectional conversion of the KCL schema and Go structure\\n+ [KCL Python SDK](https://github.com/kcl-lang/kclvm-py): More capability support.\\n\\nFor more details, please refer to [KCL v0.4.6 Milestone](https://github.com/kcl-lang/kcl/milestone/4)\\n\\n## FAQ\\n\\nFor more information, see [KCL FAQ](https://kcl-lang.io/docs/user_docs/support/).\\n\\n## Additional Resources\\n\\nThank all KCL users for their valuable feedback and suggestions during this version release. For more resources, please refer to:\\n\\n+ [KCL Website](https://kcl-lang.io/)\\n+ [Kusion Website](https://kusionstack.io/)\\n+ [KCL Repo](https://github.com/kcl-lang/kcl)\\n+ [Kusion Repo](https://github.com/KusionStack/kusion)\\n+ [Konfig Repo](https://github.com/KusionStack/konfig)\\n\\nSee the [community](https://github.com/kcl-lang/community) for ways to join us. \ud83d\udc4f\ud83d\udc4f\ud83d\udc4f"},{"id":"2022-kcl-osdt-meeting","metadata":{"permalink":"/blog/2022-kcl-osdt-meeting","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2022-12-10-kcl-osdt-meeting/index.md","source":"@site/blog/2022-12-10-kcl-osdt-meeting/index.md","title":"KCL Introduction on OSDT 2022 Meeting","description":"KCL Talk Cover","date":"2022-12-10T00:00:00.000Z","formattedDate":"December 10, 2022","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Configuration","permalink":"/blog/tags/configuration"},{"label":"Policy","permalink":"/blog/tags/policy"}],"readingTime":0.025,"hasTruncateMarker":false,"authors":[{"name":"Pengfei, Xu","title":"KCL Team Member"}],"frontMatter":{"slug":"2022-kcl-osdt-meeting","title":"KCL Introduction on OSDT 2022 Meeting","authors":{"name":"Pengfei, Xu","title":"KCL Team Member"},"tags":["KCL","Configuration","Policy"]},"prevItem":{"title":"KCL v0.4.5 Release Blog","permalink":"/blog/2022-kcl-0.4.5-release-blog"},"nextItem":{"title":"KCL v0.4.4 Release Blog","permalink":"/blog/2022-kcl-0.4.4-release-blog"}},"content":"![KCL Talk Cover](/img/blog/2022-12-10-kcl-osdt-meeting/talk-cover.jpg)\\n\\n[Download PDF](https://kcl-lang.github.io/talks/kcl-osdt2022.pdf)"},{"id":"2022-kcl-0.4.4-release-blog","metadata":{"permalink":"/blog/2022-kcl-0.4.4-release-blog","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2022-12-06-kcl-0.4.4-release-blog/index.md","source":"@site/blog/2022-12-06-kcl-0.4.4-release-blog/index.md","title":"KCL v0.4.4 Release Blog","description":"The KCL team is pleased to announce that v0.4.4 is now available! This release mainly adds the ability to customize YAML manifests output for KCL. Users can customize the style of YAML output by writing code and calling system functions without understanding the complex schema settings semantics. In addition, this release provides the latest KCL Python SDK, which can be used for Python users to directly integrate KCL. At the same time, we have greatly reduced the size of the KCL installation package. The average installation package size has been reduced to one-fifth of that of the previous version. It also includes a number of compiler error message optimization and bug fix. You can visit the KCL release page to get more detailed release information and KCL binary download link.","date":"2022-12-06T00:00:00.000Z","formattedDate":"December 6, 2022","tags":[{"label":"Release Blog","permalink":"/blog/tags/release-blog"},{"label":"KCL","permalink":"/blog/tags/kcl"}],"readingTime":6.975,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2022-kcl-0.4.4-release-blog","title":"KCL v0.4.4 Release Blog","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["Release Blog","KCL"]},"prevItem":{"title":"KCL Introduction on OSDT 2022 Meeting","permalink":"/blog/2022-kcl-osdt-meeting"},"nextItem":{"title":"40x Faster! We rewrote our project with Rust","permalink":"/blog/2022-kcl-rewrite-with-rust"}},"content":"The KCL team is pleased to announce that v0.4.4 is now available! This release mainly adds the ability to customize YAML manifests output for KCL. Users can customize the style of YAML output by writing code and calling system functions without understanding the complex schema settings semantics. In addition, this release provides the latest [KCL Python SDK](https://github.com/kcl-lang/kclvm-py), which can be used for Python users to directly integrate KCL. At the same time, we have greatly reduced the size of the KCL installation package. The average installation package size has been reduced to one-fifth of that of the previous version. It also includes a number of compiler error message optimization and bug fix. You can visit the [KCL release page](https://github.com/kcl-lang/kcl/releases/tag/v0.4.4-alpha.2) to get more detailed release information and KCL binary download link.\\n\\n## Background\\n\\nKCL is an open-source constraint-based record and functional language. KCL improves the writing of a large number of complex configurations through mature programming language technology and practice, and is committed to building better modularity, scalability and stability around configuration, simpler logic writing, fast automation and good ecological extensionality.\\n\\nThis blog will introduce the recent developments of KCL community to readers.\\n\\n## Features\\n\\n### Customize YAML Manifest Output\\n\\nIn previous KCL versions, the style of YAML output is hard coded in the KCL compiler, and users can set the `__settings__` meta attribute with different values to determine the YAML output style, which brings high complexity. Therefore, in version 0.4.4, we provide a system module function for developers to easily customize the YAML output style. The signature of this function is as follows:\\n\\n```python\\nmanifests.yaml_stream(values: [any], opts: {str:} = {\\n    sort_keys = False\\n    ignore_private = True\\n    ignore_none = False\\n    sep = \\"---\\"\\n})\\n```\\n\\nThis function is used to serialize the KCL object list into YAML output with the `---` separator. It has two parameters:\\n\\n+ `values` - A list of KCL objects\\n+ `opts` - The YAML serialization options\\n  + `sort_keys`: Whether to sort the serialized results in the dictionary order of attribute names (the default is `False`).\\n  + `ignore_private`: Whether to ignore the attribute output whose name starts with the character `_` (the default value is `True`).\\n  + `ignore_none`: Whether to ignore the attribute with the value of\' None \'(the default value is `False`).\\n  + `sep`: Set the separator between multiple YAML documents (the default value is `\\"---\\"`).\\n\\nHere\'s an example:\\n\\n```python\\nimport manifests\\n\\nschema Deployment:\\n    apiVersion: str = \\"v1\\"\\n    kind: str = \\"Deployment\\"\\n    metadata: {str:} = {\\n        name = \\"deploy\\"\\n    }\\n    spec: {str:} = {\\n        replica = 2\\n    }\\n\\nschema Service:\\n    apiVersion: str = \\"v1\\"\\n    kind: str = \\"Service\\"\\n    metadata: {str:} = {\\n         name = \\"svc\\"\\n    }\\n    spec: {str:} = {}    \\n        \\ndeployments = [Deployment {}, Deployment {}]\\nservices = [Service {}, Service {}]\\n\\nmanifests.yaml_stream(deployments + services)\\n```\\n\\nFirst, we use the `import` keyword to import the `manifests` module and define two deployment resources and two service resources. When we want to output these four resources in YAML stream format with `---` as the separator, we can put them into a KCL list and use the `manifests.yaml_stream` function pass it to the `values` parameter (if there is no special requirement, the `opts` parameter can generally use the default value). Finally, the YAML output is:\\n\\n```yaml\\napiVersion: v1\\nkind: Deployment\\nmetadata:\\n  name: deploy\\nspec:\\n  replica: 2\\n---\\napiVersion: v1\\nkind: Deployment\\nmetadata:\\n  name: deploy\\nspec:\\n  replica: 2\\n---\\napiVersion: v1\\nkind: Service\\nmetadata:\\n  name: svc\\n---\\napiVersion: v1\\nkind: Service\\nmetadata:\\n  name: svc\\n```\\n\\n> Note: The feature of schema `__settings__` meta attribute setting YAML output style can still be used in v0.4.4. We will remove this feature in KCL v0.4.6 after the next two minor versions are released.\\n\\nFor more information, see [https://github.com/kcl-lang/kcl/issues/94](https://github.com/kcl-lang/kcl/issues/94).\\n\\n### Python SDK\\n\\nIn addition to the existing [KCL Go SDK](https://github.com/kcl-lang/kcl-go), this release also adds the KCL Python SDK. Using the Python SDK requires that you have a local Python version higher than 3.7.3 and a local pip package management tool. You can use the following command to install and obtain helpful information.\\n\\n```bash\\npython3 -m pip install kclvm --user && python3 -m kclvm --help\\n```\\n\\n#### Command Line Tool\\n\\nPrepare a KCL file named `main.k`\\n\\n```python\\nname = \\"kcl\\"\\nage = 1\\n\\nschema Person:\\n    name: str = \\"kcl\\"\\n    age: int = 1\\n\\nx0 = Person {}\\nx1 = Person {\\n    age = 101\\n}\\n```\\n\\nExecute the following command and get the output:\\n\\n```shell\\npython3 -m kclvm hello.k\\n```\\n\\nThe expect output is\\n\\n```yaml\\nname: kcl\\nage: 1\\nx0:\\n  name: kcl\\n  age: 1\\nx1:\\n  name: kcl\\n  age: 101\\n```\\n\\n#### API\\n\\nIn addition, we can also execute KCL files through Python code.\\n\\nPrepare a KCL file named `main.py`\\n\\n```python\\nimport kclvm.program.exec as kclvm_exec\\nimport kclvm.vm.planner as planner\\n\\nprint(planner.plan(kclvm_exec.Run([\\"hello.k\\"]).filter_by_path_selector()))\\n```\\n\\nExecute the following command and get the output:\\n\\n```shell\\npython3 main.py\\n```\\n\\nThe expect output is\\n\\n```yaml\\nname: kcl\\nage: 1\\nx0:\\n  name: kcl\\n  age: 1\\nx1:\\n  name: kcl\\n  age: 101\\n```\\n\\nYou can see that the same output can be obtained through command line tools and APIs.\\n\\nAt present, the KCL Python SDK is still in the early preview version. The KCL team will continue to update and provide more functions in the future. For more information, see [https://github.com/kcl-lang/kclvm-py](https://github.com/kcl-lang/kclvm-py)\\n\\n## Installation Size Optimization\\n\\nIn the new KCL version, we split the built-in Python 3 of KCL, reducing the average size of the KCL binary compression package from 200M to 35M. Users can download and use KCL faster, and the Python plugin becomes an option. If you want to enable the KCL Python plugin, an additional requirement is that you have Python and pip package management tools that are higher than 3.7.3. For more details, please see [https://github.com/kcl-lang/kcl-plugin](https://github.com/kcl-lang/kcl-plugin)\\n\\n## Bugfix\\n\\n### Function Call Error Information Optimization\\n\\nIn version 0.4.4, KCL optimizes the output of error messages when the number of function arguments does not match, and supports the display of function names and the number of argument mismatches\\n\\n```python\\nschema Foo[x: int]:\\n    bar?: int = x\\n\\nf = lambda x {\\n    x + 1\\n}\\n\\nfoo = Foo(1,2,3)  # Error: \\"Foo\\" takes 1 positional argument but 3 were given\\nf(1,2)  # Error: \\"f\\" takes 1 positional argument but 2 were given\\n```\\n\\nFor more information, see [https://github.com/kcl-lang/kcl/issues/299](https://github.com/kcl-lang/kcl/issues/299)\\n\\n### Formatting Error of Interpolated Three Quote String\\n\\nIn previous KCL versions, formatting the following code would incorrectly convert the three quotation marks with string interpolation into single quotation marks and cause compilation errors. In version 0.4.4, we have fixed the issue.\\n\\n```python\\n# Before KCL v0.4.4, variable \\"bar\\" will be formatted as:\\n#\\n# foo = 1\\n# bar = \\"\\n# ${foo}\\n# \\"\\nfoo = 1\\nbar = \\"\\"\\"\\n${foo}\\n\\"\\"\\"\\n```\\n\\nFor more information, see [https://github.com/kcl-lang/kcl/issues/294](https://github.com/kcl-lang/kcl/issues/294)\\n\\n### Formatting Error of Config If Block\\n\\nIn previous KCL versions, formatting the following code would lead to incorrect indent levels. In version 0.4.4, we have fixed the issue.\\n\\n```python\\n# Before KCL v0.4.4, variable \\"foo\\" will be formatted as:\\n#\\n# foo = [\\n#     if True:\\n#         {key = \\"value\\"}\\n#     {key = \\"value\\"}\\n# ]\\nfoo = [\\n    if True:\\n        {key = \\"value\\"}\\n        {key = \\"value\\"}\\n]\\n```\\n\\n### String Literal Type Check Error\\n\\nIn previous KCL versions, formatting the following code would lead to incorrect indent levels. In version 0.4.4, we have fixed the issue.\\n\\n```python\\n# Before KCL v0.4.4, we will get a unexpected type mismatch error.\\nfoo: {\\"A\\"|\\"B\\": int} = {A = 1}\\n```\\n\\n### Other Issues\\n\\nFor more issues, see [https://github.com/kcl-lang/kcl/milestone/2?closed=1](https://github.com/kcl-lang/kcl/milestone/2?closed=1)\\n\\n## Documents\\n\\n[KCL website](https://kcl-lang.github.io/) preliminary establishment and improvement of Kubernetes scenarios [related documents](https://kcl-lang.github.io/docs/user_docs/guides/working-with-k8s/).\\n\\nFor more information, see [https://kcl-lang.github.io/](https://kcl-lang.github.io/)\\n\\n## Community\\n\\nThree external contributors @my-vegetable-has-exploded, @possible-fqz, @orangebees have participated in the KCL community, thank them for their enthusiasm and active participation in contributing.\\n\\n## Next\\n\\nIt is estimated that by the end of January 2023, we will release KCL v0.4.5, and the key evolution is expected to include\\n\\n+ Continuous optimization of the KCL user interface, improvement of experience and user pain points.\\n+ More scenarios and ecology integration, such as Kubernetes and CI/CD Pipeline scenarios.\\n+ KCL Windows version support.\\n+ KCL package management tool `kpm` release.\\n+ The new version of KCL playground.\\n\\nFor more information, see [KCL v0.4.5 Milestone](https://github.com/kcl-lang/kcl/milestone/3).\\n\\n## FAQ\\n\\nFor more information, see [https://kcl-lang.github.io/docs/user_docs/support/](https://kcl-lang.github.io/docs/user_docs/support/).\\n\\n## Additional Resources\\n\\n+ [KCL Website](https://kcl-lang.io/)\\n+ [Kusion Website](https://kusionstack.io/)\\n+ [KCL Repo](https://github.com/kcl-lang/kcl)\\n+ [Kusion Repo](https://github.com/KusionStack/kusion)\\n+ [Konfig Repo](https://github.com/KusionStack/konfig)\\n\\nSee the [community](https://github.com/kcl-lang/community) for ways to join us. \ud83d\udc4f\ud83d\udc4f\ud83d\udc4f"},{"id":"2022-kcl-rewrite-with-rust","metadata":{"permalink":"/blog/2022-kcl-rewrite-with-rust","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2022-11-29-kcl-rewrite-with-rust/index.md","source":"@site/blog/2022-11-29-kcl-rewrite-with-rust/index.md","title":"40x Faster! We rewrote our project with Rust","description":"Introduction","date":"2022-11-29T00:00:00.000Z","formattedDate":"November 29, 2022","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Rust","permalink":"/blog/tags/rust"},{"label":"Performance","permalink":"/blog/tags/performance"},{"label":"Programming Language","permalink":"/blog/tags/programming-language"},{"label":"Compiler","permalink":"/blog/tags/compiler"}],"readingTime":9.745,"hasTruncateMarker":false,"authors":[{"name":"Pengfei, Xu","title":"KCL Team Member"}],"frontMatter":{"slug":"2022-kcl-rewrite-with-rust","title":"40x Faster! We rewrote our project with Rust","authors":{"name":"Pengfei, Xu","title":"KCL Team Member"},"tags":["KCL","Rust","Performance","Programming Language","Compiler"]},"prevItem":{"title":"KCL v0.4.4 Release Blog","permalink":"/blog/2022-kcl-0.4.4-release-blog"},"nextItem":{"title":"KCL Introduction on SETTA 2022 Meeting","permalink":"/blog/2022-kcl-setta-meeting"}},"content":"## Introduction\\n\\nRust has quietly become one of the most popular programming languages. As an popular emerging system language, Rust has many great characteristics, such as its memory security mechanism, performance close to that of C/C++, an excellent development community and helpful documentation, tool chains and IDEs. In this blog, we will introduce the process of using Rust for a rewrite and gradually implementing the production environment, as well as the reasons for choosing Rust, any issues we have encountered, and the results of the rewrite.\\n\\nThe project we are using Rust to develop is called [KCL](https://github.com/kcl-lang/kcl). KCL is an open-source, constraint-based record and functional programming language. It leverages mature programming language technology and practice to facilitate the writing of many complex configurations. KCL is designed to improve modularity, scalability, and stability around configuration, simplify logic writing, speed up automation and create a thriving extension ecosystem. To learn more about specific KCL usage scenarios, please refer to the [KCL website](https://kcl-lang.github.io/). This blog will not go into too much detail about that.\\n\\nKCL was written in Python before. After carefully evaluating the user experience, performance and stability, we decided to rewrite KCL in Rust, and the following benefits were obtained:\\n\\n+ Rust\'s powerful compilation checks and error handling led to fewer bugs.\\n+ There was a 66% improvement in end-to-end compilation and execution performance.\\n+ The language front-end parser performance improved by up to 20 times.\\n+ The language semantic analyzer performance improved by up to 40 times.\\n+ The average memory usage of the language compiler during compilation was roughly half of the original Python version.\\n\\n## What problems have we encountered\\n\\nThe compiler, build system or runtime uses Rust to do similar things in technology like projects of the same type in the community [deno](https://github.com/denoland/deno), [swc](https://github.com/swc-project/swc), [turbopack](https://github.com/vercel/turbo), [rustc](https://github.com/rust-lang/rust). We used Rust to completely build the front, middle and runtime of the compiler, and achieved some results, but we did not do this about a year ago.\\n\\nA year ago, we used Python to build the entire KCL compiler implementation, which initially ran well due to Python\u2019s ease of use, rich ecosystem, and the team\'s high research and development efficiency. However, as the codebase and number of engineers grew, code maintenance became increasingly difficult. To counter this, we enforced the usage of Python type annotations and employed stricter linting tools, as well as achieving >90% code test coverage. Yet, runtime errors such as empty Python objects and missing attributes remained, and refactoring had to be done with caution.\\n\\nAs KCL users are mostly developers, any mishaps in the language or compiler internals were unacceptable, leading to a range of issues with user experience. Furthermore, programs written in Python had slow startup times, and their performance did not meet the efficiency demands of automating the online compilation and execution. Therefore, a compiler written in Python was unable to adequately meet use requirements.\\n\\nConsequently, we decided to rewrite KCL in Rust to not only improve user experience, but to also benefit from Rust\u2019s powerful compilation checks and error handling. This led to a 66% improvement in end-to-end compilation and execution performance, as well as a 20- and 40-fold improvement in the language front-end and semantic analyser performance, respectively. The average memory usage of the compiler during compilation was also roughly halved.\\n\\n## Why use Rust\\n\\nWe chose Rust for the following reasons:\\n\\n+ We implemented a simple programming language stack virtual machine in Python, Go, and Rust and conducted a performance comparison, Rust was adopted under comprehensive consideration as Go and Rust had similar performance whereas Python had a large performance gap. The details of the stack virtual machine code implemented by the three languages are here: [https://github.com/Peefy/StackMachine](https://github.com/Peefy/StackMachine).\\n+ Rust has been widely utilized for compilers or runtimes of programming languages, especially in front-end infrastructure projects, and is present in various fields such as infrastructure, database, search engine, network, cloud-native, UI, and embedded systems, ensuring its feasibility and stability.\\n+ Considering that the subsequent project development will involve the direction of blockchain and smart contract, and a large number of blockchain and smart contract projects in the community are written by Rust.\\n+ Rust provides better performance and stability, making the system easier to maintain and more robust, while allowing developers to expose C APIs through FFI for multilingual use and expansion.\\n+ Rust\'s friendly support for Web Assembly (WASM) is extremely beneficial for the development of blockchain and smart contract projects.\\n\\nBased on the above reasons, we chose Rust instead of Go. In the whole rewriting process, we found that Rust\'s comprehensive quality is impressive because it not only provides high performance but also a sufficient abstraction, although there is some cost in certain language features such as lifetime. Nevertheless, its ecology is not as rich as other languages.\\n\\n## What are the difficulties in using Rust\\n\\nAlthough we decided to rewrite the entire KCL project with Rust, most team members have no experience in writing a certain project with Rust, and I has only learned [The Rust Programming Language](https://doc.rust-lang.org/book/). I vaguely remember that I gave up when I learned about intelligent pointers such as `Rc` and `RefCell`. At that time, I didn\'t expect that there would be anything similar to C++ in Rust.\\n\\nThe risk of utilizing Rust is mainly the expense of learning the language, which is evidently discussed in a multitude of Rust blogs. Seeing that the overall structure of the KCL project had not been altered considerably, and some modules\' designs and their code had been greatly improved for Rust, the entire rewrite was accomplished through a process of mastering Rust whilst practicing. When we set out to use Rust to create the whole project, time was spent on knowledge querying, compilation and debugging. As the project advanced, however, the main challenges that arose from utilizing Rust were mainly the transformation of our mindsets, as well as the efficiency of development.\\n\\n### Mental transformation\\n\\nFirst of all, the syntax and semantics of Rust well absorb and integrate the concepts related to the type system in functional programming, such as the Abstract Algebraic Type (ADT). In addition, there is no concept related to \\"inheritance\\" in Rust. If you can\'t understand it well, even ordinary structure definitions in other languages may take a lot of time in Rust. For example, the following Python code may be defined like this in Rust.\\n\\n+ Python\\n\\n```python\\nfrom dataclasses import dataclass\\n\\nclass KCLObject:\\n    pass\\n\\n@dataclass\\nclass KCLIntObject(KCLObject):\\n    value: int\\n\\n@dataclass\\nclass KCLFloatObject(KCLObject):\\n    value: float\\n```\\n\\n+ Rust\\n\\n```rust\\nenum KCLObject {\\n    Int(u64),\\n    Float(f64),\\n}\\n```\\n\\nOf course, more time is spent fighting against the error reports of the Rust compiler itself. The Rust compiler will often cause developers to \\"run into a wall\\", such as borrowing check errors. Especially for the KCL compiler, its core structure is the Abstract Syntax Tree (AST), which is a recursive and nested tree structure.\\n\\nIt is sometimes difficult to give consideration to the relationship between variable variability and borrowing check in Rust, Just like the scope structure `Scope` defined in KCL compiler, for scenarios with circular references, it is used to display the interdependence of data that needs to be aware of, while making extensive use of intelligent pointer structures commonly used in Rust such as `Rc`, `RefCell` and `Weak`.\\n\\n```rust\\n/// A Scope maintains a set of objects and links to its containing\\n/// (parent) and contained (children) scopes. Objects may be inserted\\n/// and looked up by name. The zero value for Scope is a ready-to-use\\n/// empty scope.\\n#[derive(Clone, Debug)]\\npub struct Scope {\\n    /// The parent scope.\\n    pub parent: Option<Weak<RefCell<Scope>>>,\\n    /// The child scope list.\\n    pub children: Vec<Rc<RefCell<Scope>>>,\\n    /// The scope object mapping with its name.\\n    pub elems: IndexMap<String, Rc<RefCell<ScopeObject>>>,\\n    /// The scope start position.\\n    pub start: Position,\\n    /// The scope end position.\\n    pub end: Position,\\n    /// The scope kind.\\n    pub kind: ScopeKind,\\n}\\n```\\n\\n### Development efficiency\\n\\nThe efficiency of utilizing Rust may appear low at first, but it will become substantially high upon gaining familiarity with it. Initially, if the team members have not been exposed to concepts such as functional programming and related coding practices, the development speed will be much slower than that of languages such as Python, Go, and Java. Nevertheless, once they become familiarized with the conventional methods and best practices of the Rust standard library, as well as the common fixes for Rust compiler errors, the development efficiency will be dramatically boosted, and they will be able to compose high-quality, safe, and efficient code naturally.\\n\\nFor instance, I ran into a Rust lifetime error in the following code. After troubleshooting for a lengthy duration, it became apparent that the lifetime inconsistency was due to neglecting to label lifetime parameters. Additionally, Rust\u2019s lifetime is combined with concepts such as type system, scope, ownership, and borrowing inspection, resulting in a higher cost and complexity of understanding, with error reporting information often not as clear-cut as type errors. The lifetime inconsistency error reporting information can sometimes be somewhat inflexible, which may lead to a costly troubleshooting procedure. Of course, efficiency will be improved with increasing familiarity with the pertinent concepts.\\n\\n```rust\\nstruct Data<\'a> {\\n    b: &\'a u8,\\n}\\n\\n// func2 omit lifecycle parameters, and func2 does not.\\n// The lifecycle of func2 will be deduced as \'_ by the Rust compiler by default,\\n// which may lead to lifetime mismatch error.\\nimpl<\'a> Data<\'a> {\\n    fn func1(&self) -> Data<\'a> {Data { b: &0 }}\\n    fn func2(&self) -> Data {Data { b: &0 }}\\n}\\n```\\n\\n## Rewrite revenue ratio using Rust\\n\\nAfter spending several months using Rust to completely rewrite and steadily deploy the KCL project into a production environment, we have looked back on the whole process and found it highly rewarding.\\n\\nFrom a technical point of view, the rewrite process not only trained us to quickly learn a new programming language and its associated knowledge, but it also enabled us to put them into practice. The whole rewrite process also made us reflect on the unrational design of the KCL compiler and modify it accordingly. For a programming language, this is a long-cycle project. We have learned that such a compiler system should be more stable, and secure, with legible code, fewer bugs, and better performance.\\n\\nAlthough not all modules achieved a 40-fold improvement in performance (due to memory deep copy operations being the main bottleneck of some modules, such as the KCL runtime), I still think it is particularly beneficial. With enough experience in Rust, mental and development efficiency are no longer limiting factors.\\n\\nOverall, although our team encountered obstacles while using Rust to rewrite the KCL project, we eventually succeeded. We have acquired invaluable knowledge and experience in the process, which will be immensely beneficial in the future.\\n\\n## Conclusion\\n\\nI personally think that the most important thing after using Rust to rewrite the project is whether I have learned a new programming language or whether Rust is very popular and we have written many fancy codes using Rust. The stability, startup-time, and automation-efficiency of the KCL compiler and language is significantly improved. Furthermore, with Rust\'s non-GC, high-performance, improved error handling, memory management, and lack of abstraction, the performance of KCL improves substantially as compared to other languages in similar fields. In short, the users of KCL are the biggest beneficiaries of the improvements made possible by Rust.\\n\\nIf you are interested in the KCL project, wish to use KCL for your personal use cases, or want to use Rust to participate in an open-source project, welcome to visit [https://github.com/kcl-lang/community](https://github.com/kcl-lang/community) to join our community to participate in discussion and co construction \ud83d\udc4f\ud83d\udc4f\ud83d\udc4f\u3002\\n\\n## Reference\\n\\n+ https://github.com/kcl-lang/kcl\\n+ https://github.com/Peefy/StackMachine\\n+ https://doc.rust-lang.org/book/\\n+ https://github.com/sunface/rust-course\\n+ https://www.influxdata.com/blog/rust-can-be-difficult-to-learn-and-frustrating-but-its-also-the-most-exciting-thing-in-software-development-in-a-long-time/"},{"id":"2022-kcl-setta-meeting","metadata":{"permalink":"/blog/2022-kcl-setta-meeting","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2022-10-27-kcl-setta-meeting/index.md","source":"@site/blog/2022-10-27-kcl-setta-meeting/index.md","title":"KCL Introduction on SETTA 2022 Meeting","description":"KCL Talk Cover","date":"2022-10-27T00:00:00.000Z","formattedDate":"October 27, 2022","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Configuration","permalink":"/blog/tags/configuration"}],"readingTime":0.025,"hasTruncateMarker":false,"authors":[{"name":"Pengfei, Xu","title":"KCL Team Member"}],"frontMatter":{"slug":"2022-kcl-setta-meeting","title":"KCL Introduction on SETTA 2022 Meeting","authors":{"name":"Pengfei, Xu","title":"KCL Team Member"},"tags":["KCL","Configuration"]},"prevItem":{"title":"40x Faster! We rewrote our project with Rust","permalink":"/blog/2022-kcl-rewrite-with-rust"},"nextItem":{"title":"KCL papers were accepted by SETTA 2022","permalink":"/blog/2022-kcl-setta-paper"}},"content":"![KCL Talk Cover](/img/blog/2022-10-27-kcl-setta-meeting/talk-cover.jpg)\\n\\n[Download PDF](https://kcl-lang.github.io/talks/kcl-setta2022.pdf)"},{"id":"2022-kcl-setta-paper","metadata":{"permalink":"/blog/2022-kcl-setta-paper","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2022-10-13-kcl-setta-paper/index.md","source":"@site/blog/2022-10-13-kcl-setta-paper/index.md","title":"KCL papers were accepted by SETTA 2022","description":"Recently, the KCL paper written by the team members was accepted by SETTA 2022 International Conference.","date":"2022-10-13T00:00:00.000Z","formattedDate":"October 13, 2022","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Configuration","permalink":"/blog/tags/configuration"}],"readingTime":1.03,"hasTruncateMarker":false,"authors":[{"name":"Pengfei, Xu","title":"KCL Team Member"}],"frontMatter":{"slug":"2022-kcl-setta-paper","title":"KCL papers were accepted by SETTA 2022","authors":{"name":"Pengfei, Xu","title":"KCL Team Member"},"tags":["KCL","Configuration"]},"prevItem":{"title":"KCL Introduction on SETTA 2022 Meeting","permalink":"/blog/2022-kcl-setta-meeting"},"nextItem":{"title":"The Landscape of Declarative Configuration","permalink":"/blog/2022-declarative-config-overview"}},"content":"Recently, the KCL paper written by the team members was accepted by SETTA 2022 International Conference.\\n\\n![](/img/docs/events/2022/kcl_paper_setta.png)\\n\\nThe purpose of the Symposium on Dependable Software Engineering (SETTA) symposium is to bring international researchers together to exchange research results and ideas on bridging the gap between formal methods and software engineering. This is for instance reflected by the challenges in applying formal techniques and tools to engineering large-scale systems such as Cyber-Physical Systems (CPS), Internet-of-Things (IoT), Enterprise Systems, Cloud-Based Systems, and so forth.\\n\\nThe title of the paper \\"KCL: A Declarative Language for Large scale Configuration and Policy Management\\". The core contribution of this paper is to propose the KCL declarative language, development mechanism, and consistent workflow. Through the language model and constraint capabilities, we can improve the large-scale efficiency and liberate multi-team collaborative productivity of operational development and operation systematically while ensuring stability for large-scale configuration and policy management.\\n\\nIn addition, SETTA 2022 will hold an online conference from October 27 to October 28 (Beijing time), at which time the details of KCL papers will be shared and welcome to join [KCL Community](https://github.com/kcl-lang/community). For details of SETTA 2022 meeting agenda, please refer to [https://lcs.ios.ac.cn/setta2022/program.php](https://lcs.ios.ac.cn/setta2022/program.php)\\n\\nNote: KCL has been open-source in Github. Visit [https://github.com/kcl-lang/kcl](https://github.com/kcl-lang/kcl) for more information."},{"id":"2022-declarative-config-overview","metadata":{"permalink":"/blog/2022-declarative-config-overview","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2022-09-15-declarative-config-overview/index.md","source":"@site/blog/2022-09-15-declarative-config-overview/index.md","title":"The Landscape of Declarative Configuration","description":"The blog is only used to clarify the landscape of declarative configuration, KCL core concept and features, as well as the comparison with other configuration languages.","date":"2022-09-15T00:00:00.000Z","formattedDate":"September 15, 2022","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Configuration","permalink":"/blog/tags/configuration"}],"readingTime":26.95,"hasTruncateMarker":false,"authors":[{"name":"Pengfei, Xu","title":"KCL Team Member"}],"frontMatter":{"slug":"2022-declarative-config-overview","title":"The Landscape of Declarative Configuration","authors":{"name":"Pengfei, Xu","title":"KCL Team Member"},"tags":["KCL","Configuration"]},"prevItem":{"title":"KCL papers were accepted by SETTA 2022","permalink":"/blog/2022-kcl-setta-paper"},"nextItem":{"title":"KCL Introduction on GIAC 2021 Meeting","permalink":"/blog/2021-kcl-intro"}},"content":"The blog is only used to clarify the landscape of declarative configuration, [KCL](https://github.com/kcl-lang/kcl) core concept and features, as well as the comparison with other configuration languages.\\n\\n## 1. The Landscape of Declarative Configuration\\n\\n### 1.1 Importance of Configuration\\n\\n- There are thousands of configuration updates every day because the software development and the configuration itself are gradually evolving, which has a high demand for large-scale efficiency.\\n  - **The configuration is updated more frequently**: The evolving business requirements, infrastructure requirements and other factors mean that the system needs to change constantly, and the configuration provides a low-cost way to change the system functions.\\n  - **The configuration scale is getting larger**: A configuration is often distributed to different cloud sites, different tenants, different environments, etc.\\n  - **Wide configuration scenarios**: Application, database, network, monitoring, etc.\\n  - **Various configuration formats**: JSON, YAML, XML, TOML, various configuration templates such as Java Velocity, Go Template, etc.\\n- The stability of the configuration is crucial. One of the main reasons for system errors is that a large number of engineers frequently update the configuration. Table 1 shows several system error events caused by configuration.\\n\\n| Time | Event |\\n| --- | --- |\\n| 2021.07 | The Bilibili website in China went down because SLB Lua configuration code fell into an infinite loop with calculation errors |\\n| 2021.10 | KT Company in South Korea suffers major network interruption nationwide due to wrong routing configuration |\\n\\nTable 1 System error events caused by configuration.\\n\\n### 1.2 Classification of Declarative Configuration\\n\\nThe cloud-native era has brought about rapid technological development, with a large number of declarative configurations. As shown in Fig. 1, declarative configuration can be generally divided into the following ways.\\n\\n![](/img/blog/2022-09-15-declarative-config-overview/01-declarative-config.png)\\n\\nFig. 1: Classification of declarative configuration.\\n\\n#### 1.2.1 Structured K-V\\n\\nStructured K-V meets the minimum data declaration requirements (int, string, list, dict, etc.). Declarative API meets the development demands of X as Data with the rapid development and application of cloud-native technology. Machine-readable and writable, human-readable.\\n\\n- Pros.\\n  - Simple syntax, easy to write and read.\\n  - Rich multilingual APIs.\\n  - Various path tools for data query, such as XPath, JsonPath, etc.\\n- Cons.\\n  - Too much redundant information: when the configuration scale is large, it is difficult to maintain the configuration, because important configuration information is hidden in a large number of irrelevant repetitive data details.\\n  - Lack of functionality: constraint, complex logic, test, debug, abstraction, etc.\\n  - [Kustomize](https://kustomize.io/)\'s patches are basically by fixing several patch merge strategies\\n\\nRepresentative technologies of structured KV include:\\n\\n- JSON/YAML: It is very convenient for reading and automation, and has different languages API support.\\n- [Kustomize](https://kustomize.io/): It provides a solution to customize the Kubernetes resource base configuration and differential configuration without **template** and **DSL**. It does not solve the constraint problem itself, but needs to cooperate with a large number of additional tools to check constraints, such as [Kube-linter](https://github.com/stackrox/kube-linter)\u3001[Checkov](https://github.com/bridgecrewio/checkov). Fig. 2shows the typical working mode of Kustomize.\\n\\n![](/img/blog/2022-09-15-declarative-config-overview/02-kustomize.png)\\n\\nFig. 2: Typical working mode of Kustomize.\\n\\n#### 1.2.3 Templated K-V\\n\\nThe Templated KV has the capability of static configuration data and dynamic parameters, and can output different static configuration data with one template+dynamic parameters. The advantages and disadvantages are as follows:\\n\\n- Pros.\\n  - Simple configuration logic and loop support.\\n  - External dynamic parameter support.\\n- Cons.\\n  - It is easy to fall into the trap that all configurations are template parameters.\\n  - When the configuration scale becomes larger, it is difficult for developers and tools to maintain and analyze them.\\n\\nRepresentative technologies of templated KV include:\\n\\n- [Helm](https://helm.sh/): The package management tool of Kubernetesresources, which manages the configuration of Kubernetes resources through the configuration template. Fig. 3 shows a Helm Jenkins Package ConfigMap configuration template. It can be seen that these templates are very short with simple logic. A series of resource configurations suitable forKubernetes basic components are installed through package management and additional configuration parameters. Compared with the simply templatedK-V, Helm provides template storage, reference and semantic version management capabilities. Compared with Kustomize, Helm is more suitable for managing external Charts but is not good at multi-environment and multi-tenant configuration management.\\n- Other configuration templates: Java Velocity, Go Template and other text template engines are very suitable for HTML writing templates. However,when used in configuration scenarios, they are difficult for developers and tools to maintain and analyze.\\n\\n![](/img/blog/2022-09-15-declarative-config-overview/03-helm.png)\\n\\nFig. 3: Helm Jenkins Package ConfigMap configuration template.\\n\\n#### 1.2.3 Programmable K-V\\n\\n`Configuration as Code (CaC)` uses code to generate configuration, just like engineers only need to write advanced GPL code, rather than manually writing error-prone and difficult-to-understand server binary code.\\n\\n- Configuration changes are treated as seriously as code changes, and unit tests and integration tests can also be executed.\\n- Code modularization is a key reason why maintaining configuration code is easier than manually editing configuration files such as JSON/YAML.\\n\\n- Capability\\n  - Necessary programming language abilities (variable definitions, logical judgments, loops, assertions, etc.).\\n  - Necessary template capability, which supports the definition of data templates and the use of templates to obtain new configuration data.\\n  - Code modularity: structure definition and package management.\\n  - Machine-readable and writable, human-readable and writable.\\n- Pros.\\n  - Necessary programming ability.\\n  - Code modularization and abstraction.\\n  - Configuration template and override ability.\\n- Cons.\\n  - Insufficient type check.\\n  - Insufficient constraint capacity.\\n  - Many runtime errors.\\n\\nRepresentative technologies of programmable KV include:\\n\\n- [GCL](https://github.com/rix0rrr/gcl): A declarative configuration programming language implemented in Python provides the necessary language capabilities to support template abstraction. However, the compiler itself is written in Python, and the language itself is interpreted and executed. For large template instances (such as Kubernetes models), the performance is poor.\\n- [HCL](https://github.com/hashicorp/hcl): A Go implementation structured configuration language. The native syntax of HCL is inspired by libucl and nginx configurations. It is used to create a structured configuration language that is friendly to humans and machines, mainly for DevOps tools, server configurations, and resource configurations as a [Terraform language](https://www.terraform.io/language).\\n- [Jsonnet](https://github.com/google/jsonnet): A data template language implemented in C++, suitable for application and tool developers, can generate configuration data and organize, simplify and manage large configurations without side effects.\\n\\n#### 1.2.4 Typed K-V\\n\\n- Capability\\n  - Based on programmable K-V, typed K-V has more capabilities of type constraints.\\n- Pros.\\n  - The configuration merge is completely idempotent, which naturally prevents configuration conflicts.\\n  - Rich constraint syntax for writing configuration.\\n  - Abstract the type and value constraints into the same form, which is simple to write.\\n  - Configuration order independent.\\n- Cons.\\n  - The concepts of graph merging and idempotent merging are complex, and the understanding cost is high.\\n  - The mixed definition of type and value improves the degree of abstraction and the cost of understanding. All constraints are checked at runtime, and there is a performance bottleneck for the large-scale configuration code.\\n  - It is difficult to implement multi-tenant and multi-environment scenarios that want to configure coverage and modification.\\n  - For constrained scenarios with conditions, the user interface for writing hybrid definitions of definition and verification is unfriendly.\\n\\nRepresentative technologies of typed KV include:\\n\\n- [CUE](https://github.com/cue-lang/cue): The core problem CUE solves is \\"type checking\\", which is mainly used in configuration constraint verification scenarios and simple cloud native configuration scenarios.\\n\\n#### 1.2.5 Modeled K-V\\n\\n- Pros.\\n  - High-level language modeling capability as the core description\\n    - Modeling\\n    - Immutability\\n    - Constraints\\n  - High scalability through automatic merge mechanism of isolated config blocks.\\n  - Writing and testing methods like a high-level programming language.\\n  - Machine-readable and writable, human-readable and writable.\\n- Cons.\\n  - The expansion of new models and ecological construction requires certain R&D costs\\n\\nRepresentative technologies of modeled KV include:\\n\\n- [KCL](https://github.com/kcl-lang/kcl): A declarative configuration and policy programming language implemented by Rust, which improves the writing of a large number of complex configurations through mature programming language technology and practice, and is committed to building better modularity, scalability and stability around configuration, simpler logic writing, fast automation and good ecological extensionally. Fig. 4 shows a typical scenario of KCL writing application delivery configuration code.\\n\\n![](/img/blog/2022-09-15-declarative-config-overview/04-kcl-app-code.png)\\n\\nFig. 4: A typical scenario of KCL writing application delivery configuration code.\\n\\n### 1.3 Guidelines and Best Practices for Different Declarative Configurations\\n\\n- Configuration scale: For small-scale configuration scenarios, we can use YAML/JSON and other configurations, such as the simple configuration of the application itself and CI/CD configuration. In addition, for the requirements of multi-environment and multi-tenant in small-scale configuration scenarios, Kustomize\'s overlay capability can be used to implement operations such as merging and covering simple configurations.\\n\\n- The necessity of model abstraction and constraint: For large-scale configuration scenarios, especially for those with urgent needs for configuration model and O&M feature R&D and precipitation of multi-tenant and multi-environment, the K-V method of coding, typing and modeling can be used.\\n\\nIn addition, consider the use scenarios of different declarative configurations:\\n\\n- YAML is recommended if you need to write structured static K-V or use Kubernetes\' native tools.\\n- HCL is recommended if you want to use programming language convenience to remove boilerplate with good human readability, or if you are already a Terraform user.\\n- CUE is recommended if you want to use a type system to improve stability and maintain scalable configurations.\\n- KCL is recommended if you want types and modelings like a modern language, scalable configurations, in-house pure functions and rules, and production-ready performance and automation.\\n\\nDifferent from other languages of the same type in the community, KCL is a static strongly typed compilation language for application developers and adopts modern language design and technology.\\n\\n> Note that this blog will not discuss the general language used for writing configuration. The general language is usually overkill, that is, it goes far beyond the problems that need to be solved. There are various security problems in the general language, such as the ability boundary problem (starting local threads, accessing IO, network, code infinitive looping and other security risks). For example, in the music field, there are special notes to express music, which is convenient for learning and communication, It can not be expressed clearly in general language.\\n>\\n> In addition, because of its various styles of the general language, which has the cost of unified maintenance, management and automation. The general language is usually used to write the client runtime, which is a continuation of the server runtime. It is not suitable for writing configurations that are independent of the runtime, and it is compiled into binary and started from the process finally. Besides, the stability and scalability are not easy to control. However, the configuration language often be used to write data, which is combined with simple logic, and it describes the expected final result, which is then consumed by the compiler or engine.\\n\\n## 2. KCL Core Features and Use Cases\\n\\nThe core features of KCL are its **modeling** and **constraint** capabilities, and the basic functions of KCL revolve around the two core features. In addition, KCL follows the user-centric configuration concept to design its basic functions, which can be understood from two aspects:\\n\\n- **Domain model-centric configuration view**: With the rich features of KCL language and [KCL OpenAPI](https://kcl-lang.io/docs/tools/cli/openapi/) tools, we can directly integrate a wide range of well-designed models in the community into KCL (such as the K8s resource model). We can also design and implement our own KCL models or libraries according to different scenarios, forming a complete set of domain models for other configuration end users to use.\\n- **End user-centric configuration view**: With KCL\'s code encapsulation, abstraction and reuse capabilities, the model architecture can be further abstracted and simplified (for example, the K8s resource model is abstracted into an application-centered server model) to **minimize the end user configuration input**, simplify the user\'s configuration interface, and facilitate manual or automatic API modification.\\n\\nNo matter what configuration view is centered on, for configuration code, there are requirements for configuration data constraints, such as type constraints, required/optional constraints on configuration attributes, range constraints, and immutability constraints. This is also one of the core issues KCL is committed to solving. KCL mainly contains the core features shown in Fig. 5.\\n\\n![](/img/blog/2022-09-15-declarative-config-overview/05-kcl-core-feature.png)\\n\\nFig. 5: KCL core features.\\n\\n- **Easy-to-use**: Originated from high-level languages \u200b\u200bsuch as Python and Golang, incorporating functional language features with low side effects.\\n- **Well-designed**: Independent Spec-driven syntax, semantics, runtime and system modules design.\\n- **Quick modeling**: [Schema](https://kcl-lang.io/docs/reference/lang/tour#schema)-centric configuration types and modular abstraction.\\n- **Rich capabilities**: Configuration with type, logic and policy based on [Config](https://kcl-lang.io/docs/reference/lang/tour#config-operations), [Schema](https://kcl-lang.io/docs/reference/lang/tour#schema), [Lambda](https://kcl-lang.io/docs/reference/lang/tour#function), [Rule](https://kcl-lang.io/docs/reference/lang/tour#rule).\\n- **Stability**: Configuration stability built on [static type system](https://kcl-lang.io/docs/reference/lang/tour/#type-system), [constraints](https://kcl-lang.io/docs/reference/lang/tour/#validation), and [rules](https://kcl-lang.io/docs/reference/lang/tour#rule).\\n- **Scalability**: High scalability through [automatic merge mechanism](https://kcl-lang.io/docs/reference/lang/tour/#-operators-1) of isolated config blocks.\\n- **Fast automation**: Gradient automation scheme of [CRUD APIs](https://kcl-lang.io/docs/reference/lang/tour/#kcl-cli-variable-override), [multilingual SDKs](https://kcl-lang.io/docs/reference/xlang-api/overview), [language plugin](https://github.com/kcl-lang/kcl-plugin)\\n- **High performance**: High compile time and runtime performance using Rust & C and [LLVM](https://llvm.org/), and support compilation to native code and [WASM](https://webassembly.org/).\\n- **API affinity**: Native support API ecological specifications such as [OpenAPI](https://github.com/kcl-lang/kcl-openapi), Kubernetes CRD, Kubernetes YAML spec.\\n- **Development friendly**: Friendly development experiences with rich [language tools](https://kcl-lang.io/docs/tools/cli/kcl/) (Format, Lint, Test, Vet, Doc, etc.) and [IDE plugins](https://github.com/kcl-lang/vscode-kcl).\\n- **Safety & maintainable**: Domain-oriented, no system-level functions such as native threads and IO, low noise and security risk, easy maintenance and governance.\\n- **Rich multi-language SDK**: [Go](https://kcl-lang.io/docs/reference/xlang-api/go-api), [Python](https://kcl-lang.io/docs/reference/xlang-api/python-api) and [REST APIs](https://kcl-lang.io/docs/reference/xlang-api/rest-api) meet different scenarios and application use prelude.\\n- **Production-ready**: Widely used in production practice of platform engineering and automation at Ant Group.\\n\\n![](/img/blog/2022-09-15-declarative-config-overview/06-kcl-code-design.png)\\n\\nFig. 6: KCL core design.\\n\\nFor more language design and capabilities, see [KCL Documents](https://kcl-lang.io/docs/reference/lang/tour). Although KCL is not a general language, it has corresponding application scenarios. As shown in Fig. 6, developers can write **config**, **schema**, **function** and **rule** through KCL, where config is used to define data, schema is used to describe the model definition of data, rule is used to validate data, and schema and rule can also be combined to use models and constraints that fully describe data, In addition, we can also use the lambda pure function in KCL to organize data code, encapsulate common code, and call it directly when needed.\\n\\nFor use cases, KCL can perform structured K-V data validation complex configuration model definition and abstraction, strong constraint verification to avoid configuration errors, automation integration and engineering expansion. These features and use cases are described below.\\n\\n### 2.1 Validation of Structured Data\\n\\nAs shown in Fig 7, KCL supports format validation of JSON/YAML data. As a configuration language, KCL covers almost all features of OpenAPI in terms of validation. In KCL, the configuration data can be constrained by a structure definition. At the same time, it supports user-defined constraint rules through check blocks, and writing validation expressions in the schema to verify and constrain the attributes defined in the schema. The check expression can be used to clearly and simply verify whether the input JSON/YAML meets the corresponding schema structure definition and check constraints.\\n\\n![](/img/blog/2022-09-15-declarative-config-overview/07-kcl-validation.png)\\n\\nFig. 7: Validation of structured data in KCL.\\n\\nBased on this, KCL provides the corresponding [Validation Tool](https://kcl-lang.io/docs/tools/cli/kcl/vet) to validate JSON/YAML data directly. In addition, based on this capability, we can build a K-V validation visualization product as shown in Fig. 8.\\n\\n![](/img/blog/2022-09-15-declarative-config-overview/08-kcl-validation-ui.png)\\n\\nFig. 8: A K-V validation visualization product based on KCL.\\n\\n### 2.2 Definition and Abstraction of Complex Configuration Model\\n\\nAs shown in Fig 9, with the help of the [KCL OpenAPI](https://kcl-lang.io/docs/tools/cli/openapi/) tool, we can directly integrate a wide range of well-designed models.\\n\\n![](/img/blog/2022-09-15-declarative-config-overview/09-kcl-modeling.png)\\n\\nFig. 9: General way of KCL complex configuration modeling.\\n\\nAs shown in Figure 10, [Konfig](https://github.com/KusionStack/konfig) is used to manage all KCL configuration codes, the business configuration code and basic configuration code are stored in a mono repo, which facilitates the version dependency management between codes, and the automatic system processing is relatively simple. It is sufficient to locate the directory and files of the unique code base. The codes are interconnected, managed uniformly, and easy to find, modify, and maintain. Besides, the unified CI/CD process can be used for configuration management.\\n\\n![](/img/blog/2022-09-15-declarative-config-overview/10-kcl-konfig.png)\\n\\nFig. 10: Using KCL\'s language capabilities to integrate domain models and user models.\\n\\n### 2.3 Strong Constraint to Avoid Errors\\n\\nAs shown in Fig. 11, configuration errors can be avoided through strong constraint-checking methods in KCL.\\n\\n![](/img/blog/2022-09-15-declarative-config-overview/11-kcl-constraint.png)\\n\\nFig. 11: Strong constraint checking methods in KCL.\\n\\n- The KCL language\'s type system is designed to be static. Type and value definitions are separated. Type derivation and type checking at compile time are supported. Static types can not only analyze most type errors at compile time in advance, but also reduce the performance loss of dynamic type checking at runtime. In addition, the attributes of the KCL schema are forced to be not null, which can effectively avoid configuration omissions.\\n- When KCL configurations to be exported are declared, their types and values cannot change. This static feature ensures that the configuration will not be tampered with at will.\\n- KCL supports further ensuring stability through the built-in validation rules of the structure. For example, Fig. 12 shows that the KCL code defines the constraints for `containerPort`, `services`, and `volumes` in `App`.\\n\\n![](/img/blog/2022-09-15-declarative-config-overview/12-kcl-app-schema.png)\\n\\nFig. 12: KCL code validation with constraint rules.\\n\\n### 2.4 Isolated Configuration Block Merging\\n\\nKCL provides the ability to write isolated configuration blocks and automatically merge them, and supports idempotent merge, patch merge, and other strategies. Multiple configurations in idempotent merging need to meet the exchange law, and developers need to manually handle configuration conflicts between base and different environments. The patch merging includes overlay, deletion and addition. KCL simplifies the collaborative development on the user side and reduces the coupling between configurations through multiple merging strategies.\\n\\n![](/img/blog/2022-09-15-declarative-config-overview/13-kcl-isolated-config.png)\\n\\nFig. 13: Multi-environment scenario configuration block writing.\\n\\n### 2.5 Automation\\n\\nKCL provides many automation-related capabilities, mainly including tools and multilingual APIs. Via `package_identifier : key_identifier` mode, KCL supports the indexing of any configured key value, thus completing the addition, deletion, modification and query of any key value. For example, Fig 14. shows that we can directly execute the following command to modify the image. The code diff before and after modification is also shown in Fig. 14.\\n\\n![](/img/blog/2022-09-15-declarative-config-overview/14-kcl-image-update.png)\\n\\nFig. 14: Automatic modification of application configuration image via KCL CLI/API.\\n\\nIn addition, the automation capability of KCL can be realized and integrated into CI/CD as shown in Fig. 15.\\n\\n![](/img/blog/2022-09-15-declarative-config-overview/15-kcl-automation.png)\\n\\nFig. 15: Typical KCL automation integration.\\n\\n## 3. Comparison between KCL and Other Declarative Configurations\\n\\n### 3.1 vs. JSON/YAML\\n\\nYAML/JSON configurations are suitable for small-scale configuration scenarios. For large-scale cloud native configuration scenarios that need frequent modifications, they are more suitable for KCL. The main difference involved is the difference between configuration data abstraction and deployment:\\n\\nThe advantages of using KCL for configuration are: for static data, the advantage of abstracting one layer means that the overall system has **deployment flexibility**. Different configuration environments, tenants, and runtime may have different requirements for static data, and even different organizations may have different specifications and product requirements. KCL can be used to expose the most needed and frequently modified configurations to users.\\n\\n### 3.2 vs. Kustomize\\n\\nThe core capability of Kustomize is its file-level overlay capability. However, there is a problem with multiple overlay chains, because finding the statement of a specific attribute value does not guarantee that it is the final value, because another specific value that appears elsewhere can override it. For complex scenarios, retrieval of the inheritance chain of Kustomize files is often not as convenient as retrieval of the inheritance chain of KCL code, The specified configuration file overwrite order needs to be carefully considered. In addition, Kustomize cannot solve the problems of YAML configuration writing, constraint verification, model abstraction and development, and is more suitable for simple configuration scenarios.\\n\\nIn KCL, the configuration merge operation can be fine-grained to each configuration attribute in the code, and the merge strategy can be flexibly set, not limited to the overall resource, and the dependency between configurations can be statically analyzed through the import statement of KCL.\\n\\n### 3.3 vs. HCL\\n\\n#### 3.3.1 Features\\n\\n|  | HCL | KCL |\\n| --- | --- | --- |\\n| Modeling | The user interface is not directly perceived through the Terraform provider Schema definition. In addition, the user interface is cumbersome when writing complex object and required/optional field definitions. | Modeling through KCL schema, and achieve high model abstraction through language level engineering and some object-oriented features. |\\n| Constraint | The dynamic parameters are constrained by the condition field of the variable. The constraints of the resource itself need to be defined by provider schema or combined with Sentinel/Rego and other policy languages. The integrity of the language itself cannot be self closed, and its implementation methods are not unified | Define structures and constraints in a unified way. |\\n| Scalability | Terraform HCL overrides by file. The mode is fixed and the capability is limited. | KCL can customize the configuration block writing method and multiple strategies to meet the requirements of complex multi-tenant and multi-environment configuration scenarios. |\\n| Code writing | The user interface is complicated when writing complex object definitions and required/optional field definitions. | Complex structure definitions and constraint are easy to write without using other GPLs or tools. |\\n\\n#### 3.3.2 Examples\\n\\n**Terraform HCL variable vs. KCL schema**\\n\\n- HCL\\n\\n```python\\nvariable \\"subnet_delegations\\" {\\n  type = list(object({\\n    name               = string\\n    service_delegation = object({\\n      name    = string\\n      actions = list(string)\\n    })\\n  }))\\n  default     = null\\n  validation {\\n    condition = var.subnet_delegations == null ? true : alltrue([for d in var.subnet_delegations : (d != null)])\\n  }\\n  validation {\\n    condition = var.subnet_delegations == null ? true : alltrue([for n in var.subnet_delegations.*.name : (n != null)])\\n  }\\n  validation {\\n    condition = var.subnet_delegations == null ? true : alltrue([for d in var.subnet_delegations.*.service_delegation : (d != null)])\\n  }\\n  validation {\\n    condition = var.subnet_delegations == null ? true : alltrue([for n in var.subnet_delegations.*.service_delegation.name : (n != null)])\\n  }\\n}\\n```\\n\\n- KCL\\n\\n```python\\nschema SubnetDelegation:\\n    name: str\\n    service_delegation: ServiceDelegation\\n\\nschema ServiceDelegation:\\n    name: str  # Required attributes\\n    actions?: [str]  # Optional attributes\\n\\nsubnet_delegations: [SubnetDelegation] = option(\\"subnet_delegations\\")\\n```\\n\\n**Terraform HCL Function vs. KCL Lambda**\\n\\n- As shown in [https://www.terraform.io/language/functions](https://www.terraform.io/language/functions) and [https://github.com/hashicorp/terraform/issues/27696](https://github.com/hashicorp/terraform/issues/27696)\uff0cTerraform HCL provides rich built-in functions, but it does not support users to define functions in Terraform (or need to write complex Go providers to simulate local user-defined functions); KCL not only supports users to use the lambda keyword to directly define functions in KCL code, but also supports the use of Python, Go and other languages to write [plugins](https://kcl-lang.io/docs/reference/plugin/overview).\\n\\n- Defining functions and calling them in KCL\\n\\n```python\\nadd_func = lambda x: int, y: int -> int {\\n    x + y\\n}\\ntwo = add_func(1, 1)  # 2\\n```\\n\\n**Remove null values in HCL vs. Remove null values in KCL**\\n\\n- HCL\\n\\n```python\\nvariable \\"conf\\" {\\n  type = object({\\n    description = string\\n    name        = string\\n    namespace   = string\\n    params = list(object({\\n      default     = optional(string)\\n      description = string\\n      name        = string\\n      type        = string\\n    }))\\n    resources = optional(object({\\n      inputs = optional(list(object({\\n        name = string\\n        type = string\\n      })))\\n      outputs = optional(list(object({\\n        name = string\\n        type = string\\n      })))\\n    }))\\n    results = optional(list(object({\\n      name        = string\\n      description = string\\n    })))\\n    steps = list(object({\\n      args    = optional(list(string))\\n      command = optional(list(string))\\n      env = optional(list(object({\\n        name  = string\\n        value = string\\n      })))\\n      image = string\\n      name  = string\\n      resources = optional(object({\\n        limits = optional(object({\\n          cpu    = string\\n          memory = string\\n        }))\\n        requests = optional(object({\\n          cpu    = string\\n          memory = string\\n        }))\\n      }))\\n      script     = optional(string)\\n      workingDir = string\\n    }))\\n  })\\n}\\n\\nlocals {\\n  conf = merge(\\n    defaults(var.conf, {}),\\n    { for k, v in var.conf : k => v if v != null },\\n    { resources = { for k, v in var.conf.resources : k => v if v != null } },\\n    { steps = [for step in var.conf.steps : merge(\\n      { resources = {} },\\n      { for k, v in step : k => v if v != null },\\n    )] },\\n  )\\n}\\n```\\n\\n- KCL (using `-n` flag)\\n\\n```python\\nschema Param:\\n    default?: str\\n    name: str\\n\\nschema Resource:\\n    cpu: str\\n    memory: str\\n\\nschema Step:\\n    args?: [str]\\n    command?: [str]\\n    env?: {str:str}\\n    image: str\\n    name: str\\n    resources?: {\\"limits\\" | \\"requests\\": Resource}\\n    script?: str\\n    workingDir: str\\n\\nschema K8sManifest:\\n    name: str\\n    namespace: str\\n    params: [Param]\\n    results?: [str]\\n    steps: [Step]\\n\\nconf: K8sManifest = option(\\"conf\\")\\n```\\n\\nTo sum up, in KCL, its types and constraints are defined in a declarative way through schema. It can be seen that compared with Terraform HCL, KCL constraints can be written more simply when the same functions are implemented (validation and condition fields do not need to be written repeatedly like Terraform), In addition, it provides the ability to set fields as optional (unlike the Terraform configuration field, which can be null by default).\\n\\n### 3.4 vs. CUE\\n\\n#### 3.4.1 Features\\n\\n|  | CUE | KCL |\\n| --- | --- | --- |\\n| Modeling | Modeling through struct, no inheritance and other features, can achieve high abstraction when there is no conflict between model definitions. Because CUE performs all constraint checks at runtime, there may be performance bottlenecks in large-scale modeling scenarios. | Modeling is conducted through KCL schema, and high model abstraction can be achieved through language level engineering and some object-oriented features (such as single inheritance). KCL is a statically compiled language with low overhead for large-scale modeling scenarios. |\\n| Constraint | CUE combines types and values into one concept. It simplifies the writing of constraints through various syntax. For example, generic types and enumerations are not required. Summing types and null value merging are the same thing. | KCL provides a richer check declarative constraint syntax, which makes it easier to write. For some configuration field combination constraints, it is simpler to write (compared with CUE, KCL provides more if guard combination constraints, all/any/map/filter and other collection constraint writing methods, which makes it easier to write) |\\n| Scalability | CUE supports configuration merging but it is completely idempotent. It may not meet the requirements of complex multi-tenant and multi- environment configuration scenarios | KCL can customize the configuration block writing method and multiple strategies to meet the requirements of complex multi-tenant and multi-environment configuration scenarios. |\\n| Code writing | For complex loop and constraint scenarios, it is complex to write, and it is cumbersome to write scenarios that require accurate configuration modifications. | Complex structure definition, loop, and conditional constraint scenarios are easy to write. |\\n\\n#### 3.4.2 Examples\\n\\n**CUE constraint vs. KCL constraint**\\n\\nCUE (run `cue export base.cue prod.cue`)\\n\\n- base.cue\\n\\n```cue\\n// base.cue\\nimport \\"list\\"\\n\\n#App: {\\n    domainType: \\"Standard\\" | \\"Customized\\" | \\"Global\\",\\n    containerPort: >=1 & <=65535,\\n    volumes: [...#Volume],\\n    services: [...#Service],\\n}\\n\\n#Service: {\\n    clusterIP: string,\\n    type: string,\\n\\n    if type == \\"ClusterIP\\" {\\n        clusterIP: \\"None\\"\\n    }\\n}\\n\\n#Volume: {\\n    container: string | *\\"*\\"  // The default value of `container` is \\"*\\"\\n    mountPath: string,\\n    _check: false & list.Contains([\\"/\\", \\"/boot\\", \\"/home\\", \\"dev\\", \\"/etc\\", \\"/root\\"], mountPath),\\n}\\n\\napp: #App & {\\n    domainType: \\"Standard\\",\\n    containerPort: 80,\\n    volumes: [\\n        {\\n            mountPath: \\"/tmp\\"\\n        }\\n    ],\\n    services: [\\n        {\\n            clusterIP: \\"None\\",\\n            type: \\"ClusterIP\\"\\n        }\\n    ]\\n}\\n\\n```\\n\\n- prod.cue\\n\\n```python\\n// prod.cue\\napp: #App & {\\n    containerPort: 8080,  // error: app.containerPort: conflicting values 8080 and 80:\\n}\\n```\\n\\nKCL (run `kcl base.k prod.k`)\\n\\n- base.k\\n\\n```python\\n# base.k\\nschema App:\\n    domainType: \\"Standard\\" | \\"Customized\\" | \\"Global\\"\\n    containerPort: int\\n    volumes: [Volume]\\n    services: [Service]\\n\\n    check:\\n        1 <= containerPort <= 65535\\n\\nschema Service:\\n    clusterIP: str\\n    $type: str\\n\\n    check:\\n        clusterIP == \\"None\\" if $type == \\"ClusterIP\\"\\n\\nschema Volume:\\n    container: str = \\"*\\"  # The default value of `container` is \\"*\\"\\n    mountPath: str\\n\\n    check:\\n        mountPath not in [\\"/\\", \\"/boot\\", \\"/home\\", \\"dev\\", \\"/etc\\", \\"/root\\"]\\n\\napp: App {\\n    domainType = \\"Standard\\"\\n    containerPort = 80\\n    volumes = [\\n        {\\n            mountPath = \\"/tmp\\"\\n        }\\n    ]\\n    services = [\\n        {\\n            clusterIP = \\"None\\"\\n            $type = \\"ClusterIP\\"\\n        }\\n    ]\\n}\\n\\n```\\n\\n- prod.k\\n\\n```python\\n# prod.k\\napp: App {\\n    # Using `=` attribute operator to modify the `containerPort` of the base `app`.\\n    containerPort = 8080\\n    # Using `+=` attribute operator to add volumes of the base `app`.\\n    # Here, it means to add one volume in the prod environment.\\n    volumes += [\\n        {\\n            mountPath = \\"/tmp2\\"\\n        }\\n    ]\\n}\\n```\\n\\nIn addition, due to the idempotent merge feature of CUE, it is not easy to use an overlay configuration similar to Kustomize to override the additional capability in scenarios, such as the above CUE code will report a conflict error.\\n\\n### 3.5 Performance\\n\\nKCL performs better than CUE/Jsonnet/HCL and other languages in scenarios with large code size or high computation load (CUE and other languages are limited by the runtime constraint checking overhead, while KCL is a statically compiled language).\\n\\n- CUE (test.cue)\\n\\n```cue\\nimport \\"list\\"\\n\\ntemp: {\\n        for i, _ in list.Range(0, 10000, 1) {\\n                \\"a\\\\(i)\\": list.Max([1, 2])\\n        }\\n}\\n```\\n\\n- KCL (test.k)\\n\\n```python\\na = lambda x: int, y: int -> int {\\n    max([x, y])\\n}\\ntemp = {\\"a${i}\\": a(1, 2) for i in range(10000)}\\n```\\n\\n- Jsonnet (test.jsonnet)\\n\\n```jsonnet\\nlocal a(x, y) = std.max(x, y);\\n{\\n    temp: {[\\"a%d\\" % i]: a(1, 2) for i in std.range(0, 10000)},\\n}\\n```\\n\\n- Terraform HCL (test.tf. Since the terraform `range` function only supports up to 1024 iterators, the `range(10000)` is divided into 10 sub ranges)\\n\\n```python\\noutput \\"r1\\" {\\n  value = {for s in range(0, 1000) : format(\\"a%d\\", s) => max(1, 2)}\\n}\\noutput \\"r2\\" {\\n  value = {for s in range(1000, 2000) : format(\\"a%d\\", s) => max(1, 2)}\\n}\\noutput \\"r3\\" {\\n  value = {for s in range(1000, 2000) : format(\\"a%d\\", s) => max(1, 2)}\\n}\\noutput \\"r4\\" {\\n  value = {for s in range(2000, 3000) : format(\\"a%d\\", s) => max(1, 2)}\\n}\\noutput \\"r5\\" {\\n  value = {for s in range(3000, 4000) : format(\\"a%d\\", s) => max(1, 2)}\\n}\\noutput \\"r6\\" {\\n  value = {for s in range(5000, 6000) : format(\\"a%d\\", s) => max(1, 2)}\\n}\\noutput \\"r7\\" {\\n  value = {for s in range(6000, 7000) : format(\\"a%d\\", s) => max(1, 2)}\\n}\\noutput \\"r8\\" {\\n  value = {for s in range(7000, 8000) : format(\\"a%d\\", s) => max(1, 2)}\\n}\\noutput \\"r9\\" {\\n  value = {for s in range(8000, 9000) : format(\\"a%d\\", s) => max(1, 2)}\\n}\\noutput \\"r10\\" {\\n  value = {for s in range(9000, 10000) : format(\\"a%d\\", s) => max(1, 2)}\\n}\\n```\\n\\n- Running time (considering the actual resource cost of the production environment, this test is subject to the single core).\\n\\n| Environment | KCL v0.4.3 Running time (including compilation+runtime) | CUE v0.4.3 Running time (including compilation+runtime) | Jsonnet v0.18.0 Running time (including compilation+runtime)  | HCL in Terraform v1.3.0 Running time (including compilation+runtime) |\\n| --- | --- | --- | --- | --- |\\n| OS: macOS 10.15.7; CPU: Intel(R) Core(TM) i7-8850H CPU @ 2.60GHz; Memory: 32 GB 2400 MHz DDR4; no NUMA | 440 ms (kcl test.k) | 6290 ms (cue export test.cue) | 3340 ms (jsonnet test.jsonnet) | 1774 ms (terraform plan -parallelism=1) |\\n\\n#### Another Complex Case\\n\\nUsing KCL and CUE to write Kubernetes configuration.\\n\\n- CUE (test.cue)\\n\\n```cue\\npackage templates\\n\\nimport (\\n apps \\"k8s.io/api/apps/v1\\"\\n)\\n\\ndeployment: apps.#Deployment\\n\\ndeployment: {\\n apiVersion: \\"apps/v1\\"\\n kind:       \\"Deployment\\"\\n metadata: {\\n  name:   \\"me\\"\\n  labels: me: \\"me\\"\\n }\\n}\\n```\\n\\n- KCL (test.k)\\n\\n```python\\nimport kubernetes.api.apps.v1\\n\\ndeployment = v1.Deployment {\\n    metadata.name = \\"me\\"\\n    metadata.labels.name = \\"me\\"\\n}\\n```\\n\\n| Environment | KCL v0.4.3 Running time (including compilation+runtime) | CUE v0.4.3 Running time (including compilation+runtime) |\\n| --- | --- | --- |\\n| OS: macOS 10.15.7; CPU: Intel(R) Core(TM) i7-8850H CPU @ 2.60GHz; Memory: 32 GB 2400 MHz DDR4; no NUMA | 140 ms (kcl test.k) | 350 ms (cue export test.cue) |\\n\\n## 4. Summary\\n\\nThe blog gives a landscape overview of declarative configuration technology, focusing on the KCL concept, core features, usage cases and comparison with other configuration languages, hoping to help you understand declarative configuration technology and KCL language. For more information about the concept, background and design of KCL, please visit the [KCL website](https://kcl-lang.io/)\\n\\n## 5. Reference\\n\\n- KusionStack Cloud Native Configuration Practice Blog: [https://kusionstack.io/blog/2021-kusion-intro](https://kusionstack.io/blog/2021-kusion-intro)\\n- Terraform Language: [https://www.terraform.io/language](https://www.terraform.io/language)\\n- Terraform Provider Kubernetes: [https://github.com/hashicorp/terraform-provider-kubernetes](https://github.com/hashicorp/terraform-provider-kubernetes)\\n- Terraform Provider AWS: [https://github.com/hashicorp/terraform-provider-aws](https://github.com/hashicorp/terraform-provider-aws)\\n- Pulumi: [https://www.pulumi.com/docs/](https://www.pulumi.com/docs/)\\n- Pulumi vs. Terraform: [https://www.pulumi.com/docs/intro/vs/terraform/](https://www.pulumi.com/docs/intro/vs/terraform/)\\n- Google SRE Work Book Configuration Design: [https://sre.google/workbook/configuration-design/](https://sre.google/workbook/configuration-design/)\\n- Google Borg Paper: [https://storage.googleapis.com/pub-tools-public-publication-data/pdf/43438.pdf](https://storage.googleapis.com/pub-tools-public-publication-data/pdf/43438.pdf)\\n- Holistic Configuration Management at Facebook: [https://sigops.org/s/conferences/sosp/2015/current/2015-Monterey/printable/008-tang.pdf](https://sigops.org/s/conferences/sosp/2015/current/2015-Monterey/printable/008-tang.pdf)\\n- JSON Spec: [https://www.json.org/json-en.html](https://www.json.org/json-en.html)\\n- YAML Spec: [https://yaml.org/spec/](https://yaml.org/spec/)\\n- GCL: [https://github.com/rix0rrr/gcl](https://github.com/rix0rrr/gcl)\\n- HCL: [https://github.com/hashicorp/hcl](https://github.com/hashicorp/hcl)\\n- CUE: [https://github.com/cue-lang/cue](https://github.com/cue-lang/cue)\\n- Jsonnet: [https://github.com/google/jsonnet](https://github.com/google/jsonnet)\\n- Dhall: [https://github.com/dhall-lang/dhall-lang](https://github.com/dhall-lang/dhall-lang)\\n- Thrift: [https://github.com/Thriftpy/thriftpy2](https://github.com/Thriftpy/thriftpy2)\\n- Kustomize: [https://kustomize.io/](https://kustomize.io/)\\n- Kube-linter: [https://github.com/stackrox/kube-linter](https://github.com/stackrox/kube-linter)\\n- Checkov: [https://github.com/bridgecrewio/checkov](https://github.com/bridgecrewio/checkov)\\n- KCL Documents: [https://kcl-lang.io/docs/reference/lang/tour](https://kcl-lang.io/docs/reference/lang/tour)\\n- How Terraform Works: A Visual Intro: [https://betterprogramming.pub/how-terraform-works-a-visual-intro-6328cddbe067](https://betterprogramming.pub/how-terraform-works-a-visual-intro-6328cddbe067) \\n- How Terraform Works: Modules Illustrated: [https://awstip.com/terraform-modules-illustrate-26cbc48be83a](https://awstip.com/terraform-modules-illustrate-26cbc48be83a)\\n- Helm: [https://helm.sh/](https://helm.sh/)\\n- Helm vs. Kustomize: [https://harness.io/blog/helm-vs-kustomize](https://harness.io/blog/helm-vs-kustomize)\\n- KubeVela: [https://kubevela.io/docs/](https://kubevela.io/docs/)"},{"id":"2021-kcl-intro","metadata":{"permalink":"/blog/2021-kcl-intro","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2021-08-03-kcl-giac-metting/index.md","source":"@site/blog/2021-08-03-kcl-giac-metting/index.md","title":"KCL Introduction on GIAC 2021 Meeting","description":"This blog introduces the birth background, language characteristics, practical exploration and future development of KCL.","date":"2021-08-03T00:00:00.000Z","formattedDate":"August 3, 2021","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"}],"readingTime":0.125,"hasTruncateMarker":false,"authors":[{"name":"Shushan, Chai","title":"KCL Team Member"}],"frontMatter":{"slug":"2021-kcl-intro","title":"KCL Introduction on GIAC 2021 Meeting","authors":{"name":"Shushan, Chai","title":"KCL Team Member"},"tags":["KCL"]},"prevItem":{"title":"The Landscape of Declarative Configuration","permalink":"/blog/2022-declarative-config-overview"}},"content":"This blog introduces the birth background, language characteristics, practical exploration and future development of KCL.\\n\\n- Introduction\uff1ahttps://giac.msup.com.cn/course?id=15307\\n- Content\uff1ahttps://segmentfault.com/a/1190000040455559\\n- [PDF (Chinese)](https://gw.alipayobjects.com/os/bmw-prod/2cb0c283-5f24-485e-b635-b6efac887eba.pdf)\\n\\n[![KCL Talk Cover](/img/blog/2021-08-03-kcl-intro/talk-cover.png)](https://gw.alipayobjects.com/os/bmw-prod/2cb0c283-5f24-485e-b635-b6efac887eba.pdf)"}]}')}}]);