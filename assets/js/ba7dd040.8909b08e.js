"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[85088],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>k});var a=t(67294);function l(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){l(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,l=function(e,n){if(null==e)return{};var t,a,l={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(l[t]=e[t]);return l}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(l[t]=e[t])}return l}var s=a.createContext({}),p=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},u=function(e){var n=p(e.components);return a.createElement(s.Provider,{value:n},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},c=a.forwardRef((function(e,n){var t=e.components,l=e.mdxType,i=e.originalType,s=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),d=p(t),c=l,k=d["".concat(s,".").concat(c)]||d[c]||m[c]||i;return t?a.createElement(k,r(r({ref:n},u),{},{components:t})):a.createElement(k,r({ref:n},u))}));function k(e,n){var t=arguments,l=n&&n.mdxType;if("string"==typeof e||l){var i=t.length,r=new Array(i);r[0]=c;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o[d]="string"==typeof e?e:l,r[1]=o;for(var p=2;p<i;p++)r[p]=t[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}c.displayName="MDXCreateElement"},73469:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>r,default:()=>m,frontMatter:()=>i,metadata:()=>o,toc:()=>p});var a=t(87462),l=(t(67294),t(3905));const i={title:"KCL Tour",sidebar_position:1},r=void 0,o={unversionedId:"reference/lang/tour",id:"version-0.5.1/reference/lang/tour",title:"KCL Tour",description:"This page shows how to use major KCL features, from variables and operators to schemas and libraries, with the assumption that you have already known how to program in another language. KCL is mainly inspired by Python, and knowing Python is very helpful for learning KCL.",source:"@site/versioned_docs/version-0.5.1/reference/lang/tour.md",sourceDirName:"reference/lang",slug:"/reference/lang/tour",permalink:"/docs/0.5.1/reference/lang/tour",draft:!1,editUrl:"https://github.com/kcl-lang/kcl-lang.io/tree/main/versioned_docs/version-0.5.1/reference/lang/tour.md",tags:[],version:"0.5.1",lastUpdatedBy:"peefy",lastUpdatedAt:1690883666,formattedLastUpdatedAt:"Aug 1, 2023",sidebarPosition:1,frontMatter:{title:"KCL Tour",sidebar_position:1},sidebar:"reference",next:{title:"Code Lab",permalink:"/docs/0.5.1/reference/lang/codelab/"}},s={},p=[{value:"Important Concepts",id:"important-concepts",level:3},{value:"Keywords",id:"keywords",level:3},{value:"Identifiers",id:"identifiers",level:3},{value:"Identifier Prefix",id:"identifier-prefix",level:4},{value:"Variables",id:"variables",level:3},{value:"Built-in Types",id:"built-in-types",level:3},{value:"Number",id:"number",level:4},{value:"Units",id:"units",level:5},{value:"String",id:"string",level:4},{value:"Raw String",id:"raw-string",level:5},{value:"Boolean",id:"boolean",level:4},{value:"List",id:"list",level:4},{value:"Dict",id:"dict",level:4},{value:"None",id:"none",level:4},{value:"Undefined",id:"undefined",level:4},{value:"Operators",id:"operators",level:3},{value:"Arithmetic Operators",id:"arithmetic-operators",level:4},{value:"Equality and Relational Operators",id:"equality-and-relational-operators",level:4},{value:"Logical Operators",id:"logical-operators",level:4},{value:"Bitwise and Shift Operators",id:"bitwise-and-shift-operators",level:4},{value:"Assignment Operators",id:"assignment-operators",level:4},{value:"Identity Operators",id:"identity-operators",level:4},{value:"Membership Operators",id:"membership-operators",level:4},{value:"Comprehension",id:"comprehension",level:4},{value:"Other Operators",id:"other-operators",level:4},{value:"Expressions",id:"expressions",level:3},{value:"Conditional Expressions",id:"conditional-expressions",level:4},{value:"Index Expressions",id:"index-expressions",level:4},{value:"Slice Expressions",id:"slice-expressions",level:4},{value:"Function Invocations",id:"function-invocations",level:4},{value:"Selector Expressions",id:"selector-expressions",level:4},{value:"Quantifier Expressions",id:"quantifier-expressions",level:4},{value:"Control Flow Statements",id:"control-flow-statements",level:3},{value:"If and Else",id:"if-and-else",level:4},{value:"Assert",id:"assert",level:3},{value:"Function",id:"function",level:3},{value:"Type System",id:"type-system",level:3},{value:"Type Annotation",id:"type-annotation",level:4},{value:"Type Inference",id:"type-inference",level:4},{value:"Type Alias",id:"type-alias",level:4},{value:"Type Guards",id:"type-guards",level:4},{value:"Schema",id:"schema",level:3},{value:"Overview",id:"overview",level:4},{value:"Basic",id:"basic",level:4},{value:"Attribute",id:"attribute",level:5},{value:"Optional Attribute",id:"optional-attribute",level:6},{value:"Irrelevant Order Calculation",id:"irrelevant-order-calculation",level:5},{value:"Schema Context",id:"schema-context",level:5},{value:"Validation",id:"validation",level:5},{value:"Documents",id:"documents",level:5},{value:"Config",id:"config",level:5},{value:"Advanced",id:"advanced",level:4},{value:"Protocol &amp; Mixin",id:"protocol--mixin",level:5},{value:"Index Signature",id:"index-signature",level:5},{value:"Inheritance",id:"inheritance",level:5},{value:"Schema Function",id:"schema-function",level:5},{value:"Decorators",id:"decorators",level:5},{value:"Members",id:"members",level:5},{value:"Config Operations",id:"config-operations",level:3},{value:"Config Unification",id:"config-unification",level:4},{value:"| Operators",id:"-operators",level:5},{value:": Operators",id:"-operators-1",level:5},{value:"Config Override",id:"config-override",level:4},{value:"= Operators",id:"-operators-2",level:5},{value:"Insert",id:"insert",level:4},{value:"+= Operators",id:"-operators-3",level:5},{value:"Notice",id:"notice",level:4},{value:"Rule",id:"rule",level:3},{value:"Module",id:"module",level:3},{value:"Relative Path Import",id:"relative-path-import",level:4},{value:"Absolute Path Import",id:"absolute-path-import",level:4},{value:"Top-Level Argument",id:"top-level-argument",level:3},{value:"Arguments with Setting Files",id:"arguments-with-setting-files",level:4},{value:"Option Functions",id:"option-functions",level:4},{value:"Multi-file Compilation",id:"multi-file-compilation",level:3},{value:"KCL CLI Path Selector",id:"kcl-cli-path-selector",level:3},{value:"Examples",id:"examples",level:4},{value:"KCL CLI Variable Override",id:"kcl-cli-variable-override",level:3},{value:"Examples",id:"examples-1",level:4},{value:"Override Update Sample",id:"override-update-sample",level:5},{value:"Override Delete Sample",id:"override-delete-sample",level:5},{value:"Summary",id:"summary",level:3}],u={toc:p},d="wrapper";function m(e){let{components:n,...t}=e;return(0,l.kt)(d,(0,a.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,l.kt)("p",null,"This page shows how to use major KCL features, from variables and operators to schemas and libraries, with the assumption that you have already known how to program in another language. KCL is mainly inspired by Python, and knowing Python is very helpful for learning KCL."),(0,l.kt)("h3",{id:"important-concepts"},"Important Concepts"),(0,l.kt)("p",null,"As we learn about the KCL language, keep these facts and concepts in mind:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"KCL is a configuration and policy language. It provides simplified and self-contained language design and library support for writing configurations and policies. It cannot be used for application development or other purposes supported by General Purpose Language (GPL)."),(0,l.kt)("li",{parentName:"ul"},"KCL absorbs classic ",(0,l.kt)("strong",{parentName:"li"},"OOP")," elements and provides simple, developer-friendly and reliable configuration writing practice with ",(0,l.kt)("strong",{parentName:"li"},"type"),", ",(0,l.kt)("strong",{parentName:"li"},"reusing"),", and ",(0,l.kt)("strong",{parentName:"li"},"union"),"."),(0,l.kt)("li",{parentName:"ul"},"KCL prefers ",(0,l.kt)("strong",{parentName:"li"},"immutability")," and recommend to add up incremental updates through the ",(0,l.kt)("strong",{parentName:"li"},"union"),". Immutability reduces side effects like unpredictable issues."),(0,l.kt)("li",{parentName:"ul"},"KCL ",(0,l.kt)("strong",{parentName:"li"},"schema")," struct defines strict attributes, static types, and it also supports validation expressions. The ",(0,l.kt)("strong",{parentName:"li"},"schema")," struct is mainly composed of typed attributes, the schema context and the check block."),(0,l.kt)("li",{parentName:"ul"},"KCL ",(0,l.kt)("strong",{parentName:"li"},"config")," is a ",(0,l.kt)("strong",{parentName:"li"},"json"),"-like expression, by which we can reuse a full definition of the schema. KCL provides support for definition and configuration by separating schema and config."),(0,l.kt)("li",{parentName:"ul"},"KCL ",(0,l.kt)("strong",{parentName:"li"},"rule")," is a structure for writing rule constraint expressions, which can be used for data verification and policy writing."),(0,l.kt)("li",{parentName:"ul"},"KCL code files are managed as packages(directories) and modules(files). The schema types in the same package are visible to each other; the data cross packages need to be imported through the ",(0,l.kt)("strong",{parentName:"li"},"import statement"),". The package-level variables can be exported, but they are immutable for other packages."),(0,l.kt)("li",{parentName:"ul"},"The KCL syntax definition mainly uses declarative expressions, and only provides a small number of necessary and imperative statements, such as import, if .. else, assert, assignment and schema."),(0,l.kt)("li",{parentName:"ul"},"No main function, each ",(0,l.kt)("inlineCode",{parentName:"li"},".k")," file could be executed as a separate configuration."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Built-in functions")," and ",(0,l.kt)("strong",{parentName:"li"},"plugins")," are supported to simplify coding.")),(0,l.kt)("h3",{id:"keywords"},"Keywords"),(0,l.kt)("p",null,"The following table lists the words that the KCL language treats specially."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-txt"},"True       False      None        Undefined   import\nand        or         in          is          not\nas         if         else        elif        for\nschema     mixin      protocol    check       assert\nall        any        map         filter      lambda\nrule\n")),(0,l.kt)("h3",{id:"identifiers"},"Identifiers"),(0,l.kt)("p",null,"In KCL, an identifier is a name, may with selectors, that identifies a value."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Identifiers consist of letters, numbers, underscores or the prefix ",(0,l.kt)("inlineCode",{parentName:"li"},"$"),"."),(0,l.kt)("li",{parentName:"ul"},"Identifiers cannot be repeated with keywords unless they have a ",(0,l.kt)("inlineCode",{parentName:"li"},"$")," prefix."),(0,l.kt)("li",{parentName:"ul"},"Identifiers must not contain any embedded spaces or symbols."),(0,l.kt)("li",{parentName:"ul"},"Letters and underscores can be used anywhere in the identifier."),(0,l.kt)("li",{parentName:"ul"},"Numbers cannot be placed in the first place of the identifier."),(0,l.kt)("li",{parentName:"ul"},"The ",(0,l.kt)("inlineCode",{parentName:"li"},"$")," character can only be placed in the first position of the identifier.")),(0,l.kt)("p",null,"Examples:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"x\na\nb1\nb_2\n_c\n$if\n")),(0,l.kt)("p",null,"To simplify the definition of the qualified identifier, such as ",(0,l.kt)("inlineCode",{parentName:"p"},"pkg.type"),", we additionally define ",(0,l.kt)("inlineCode",{parentName:"p"},"qualified identifier"),":"),(0,l.kt)("p",null,"Examples:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"pkg.a\n")),(0,l.kt)("p",null,"The package name in ",(0,l.kt)("inlineCode",{parentName:"p"},"qualified identifier")," must be imported."),(0,l.kt)("h4",{id:"identifier-prefix"},"Identifier Prefix"),(0,l.kt)("p",null,"Use the ",(0,l.kt)("inlineCode",{parentName:"p"},"$")," character prefix to define keyword identifiers."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'$if = 1\n$else = "s"\n')),(0,l.kt)("p",null,"Please note: whether the non-keyword identifier is prefixed with ",(0,l.kt)("inlineCode",{parentName:"p"},"$")," has the same effect."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"_a = 1\n$_a = 2  # equal to `_a = 2`\n")),(0,l.kt)("h3",{id:"variables"},"Variables"),(0,l.kt)("p",null,"Here\u2019s an example of how to create a variable and initialize it:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'name = "Foo"  # Declare a variable named `name` and its value is a string literal "Foo"\n')),(0,l.kt)("p",null,"It corresponds to the following YAML output:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},"name: Foo\n")),(0,l.kt)("p",null,"In KCL, we can export variables as config data by defining package-level variables. To make it direct, clear, and maintainable. Exported variables are immutable so that once we declare it, we can't modify it. For example, assume we have a config file named ",(0,l.kt)("inlineCode",{parentName:"p"},"example.k"),", the variable ",(0,l.kt)("inlineCode",{parentName:"p"},"name")," can't be modified after the declaration, just like the standard imperative language."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'name = "Foo"  # exported\n\n...\n\nname = "Bar"  # error: a exported declaration variable can only be set once.\n')),(0,l.kt)("p",null,"As a complement, we can define a non-exported variable in module level which is mutable, which won't show up in YAML output:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'_name = "Foo"  # _ variables are not output to YAML and are mutable\n_name = "Bar"\n')),(0,l.kt)("p",null,"Please note that the variable name cannot be one of ",(0,l.kt)("inlineCode",{parentName:"p"},"True"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"False"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"None"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"Undefined")," because of ambiguity."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"False = 1  # Error\nTrue = False  # Error\nNone = Undefined  # Error\nUndefined = None  # Error\n")),(0,l.kt)("h3",{id:"built-in-types"},"Built-in Types"),(0,l.kt)("p",null,"The KCL language has special support for the following types:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"number"),(0,l.kt)("li",{parentName:"ul"},"string"),(0,l.kt)("li",{parentName:"ul"},"boolean"),(0,l.kt)("li",{parentName:"ul"},"list"),(0,l.kt)("li",{parentName:"ul"},"dict")),(0,l.kt)("h4",{id:"number"},"Number"),(0,l.kt)("p",null,"KCL number comes into two flavors:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Int"),": 64 bits signed integer values. Values can be from -9223372036854775808~9223372036854775807."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Float"),": 64-bit floating-point numbers, as specified by the IEEE 754 standard. We do not recommend using the float type in the configuration, we can use a string instead and parse it during runtime processing.")),(0,l.kt)("p",null,"Both int and float support basic operators such as ",(0,l.kt)("inlineCode",{parentName:"p"},"+"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"-"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"/"),", and ",(0,l.kt)("inlineCode",{parentName:"p"},"*"),", while complex operations, such as ",(0,l.kt)("inlineCode",{parentName:"p"},"abs()"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"ceil()"),", and ",(0,l.kt)("inlineCode",{parentName:"p"},"floor()"),", are supported through the built-in math library."),(0,l.kt)("p",null,"Integers are numbers without a decimal point. Here are some examples of defining integer literals:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'a = 1\nb = -1\nc = 0x10 # hexadecimal literal\nd = 0o10 # octal literal\ne = 010  # octal literal\nf = 0b10 # binary literal\ng = int("10") # int constructor\n')),(0,l.kt)("p",null,"If a number includes a decimal point, it is a float number. Here are some examples of defining float literals:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'a = 1.10\nb = 1.0\nc = -35.59\nd = 32.3e+18\nf = -90.\nh = 70.2E-12\ni = float("112") # float constructor\n')),(0,l.kt)("p",null,"Built-in math libraries can be used with numbers:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"import math\n\nassert abs(-40) == 40\nassert round(70.23456) == 70\nassert min(80, 100, 1000) == 80\nassert max(80, 100, 1000) == 1000\nassert sum([0,1,2]) == 3\nassert math.ceil(100.12) == 101.0\nassert math.floor(100.12) == 100.0\nassert math.pow(100, 2) == 10000.0\n")),(0,l.kt)("p",null,"In addition, please note that the KCL number is 64-bit by default. We can perform a stricter 32-bit range check by adding the ",(0,l.kt)("inlineCode",{parentName:"p"},"-r")," parameter to the KCL command-line tool."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"kcl main.k -r -d\n")),(0,l.kt)("p",null,"Please note that the value range check is only enabled in ",(0,l.kt)("inlineCode",{parentName:"p"},"debug")," mode"),(0,l.kt)("h5",{id:"units"},"Units"),(0,l.kt)("p",null,"In KCL, we can add a unit suffix to an integer denomination to indicate that it does not affect its true value as follows."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"General integer or fixed-point number form: ",(0,l.kt)("inlineCode",{parentName:"li"},"P"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"T"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"G"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"M"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"K"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"k"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"m"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"u"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"n")),(0,l.kt)("li",{parentName:"ul"},"Corresponding power of 2: ",(0,l.kt)("inlineCode",{parentName:"li"},"Pi"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"Ti"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"Gi"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"Mi"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"Ki"))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"# SI\nn = 1n  # 1e-09\nu = 1u  # 1e-06\nm = 1m  # 1e-03\nk = 1k  # 1000\nK = 1K  # 1000\nM = 1M  # 1000000\nG = 1G  # 1000000000\nT = 1T  # 100000000000\nP = 1P  # 1000000000000000\n# IEC\nKi = 1Ki  # 1024\nMi = 1Mi  # 1024 ** 2\nGi = 1Gi  # 1024 ** 3\nTi = 1Ti  # 1024 ** 4\nPi = 1Pi  # 1024 ** 5\n")),(0,l.kt)("p",null,"Besides, And we can also use the unit constants defined in the ",(0,l.kt)("inlineCode",{parentName:"p"},"units")," module as follows:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"import units\n\nn = 1 * units.n  # 1e-09\nu = 1 * units.u  # 1e-06\nm = 1 * units.m  # 1e-03\nk = 1 * units.k  # 1000\nK = 1 * units.K  # 1000\nM = 1 * units.M  # 1000000\nG = 1 * units.G  # 1000000000\nT = 1 * units.T  # 1000000000000\nP = 1 * units.P  # 1000000000000000\n# IEC\nKi = 1 * units.Ki  # 1024\nMi = 1 * units.Mi  # 1024 ** 2\nGi = 1 * units.Gi  # 1024 ** 3\nTi = 1 * units.Ti  # 1024 ** 4\nPi = 1 * units.Pi  # 1024 ** 5\n")),(0,l.kt)("p",null,"We can also use the methods in the ",(0,l.kt)("inlineCode",{parentName:"p"},"units")," module to convert between integers and unit strings."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'import units\n# SI\nK = units.to_K(1000)   # "1K"\nM = units.to_M(1000000)   # "1M"\nG = units.to_G(1000000000)   # "1G"\nT = units.to_T(1000000000000)   # "1T"\nP = units.to_P(1000000000000000)  # "1P"\n# IEC\nKi = units.to_Ki(1024)  # "1Ki"\nMi = units.to_Mi(1024 ** 2)  # "1Mi"\nGi = units.to_Gi(1024 ** 3)  # "1Gi"\nTi = units.to_Ti(1024 ** 4)  # "1Ti"\nPi = units.to_Pi(1024 ** 5)  # "1Pi"\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'import units\n# SI\nK = units.to_K(int("1M"))   # "1000K"\nM = units.to_M(int("1G"))   # "1000M"\nG = units.to_G(int("1T"))   # "1000G"\nT = units.to_T(int("1P"))   # "1000T"\nP = units.to_P(int("10P"))  # "10P"\n# IEC\nKi = units.to_Ki(int("1Mi"))   # "1024Ki"\nMi = units.to_Mi(int("1Gi"))   # "1024Mi"\nGi = units.to_Gi(int("1Ti"))   # "1024Gi"\nTi = units.to_Ti(int("1Pi"))   # "1024Ti"\nPi = units.to_Pi(int("10Pi"))  # "10Pi"\n')),(0,l.kt)("p",null,"The unit value type is defined in the units module, and the unit value type does not allow any four calculations."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"import units\n\ntype NumberMultiplier = units.NumberMultiplier\n\nx0: NumberMultiplier = 1M  # Ok\nx1: NumberMultiplier = x0  # Ok\nx2 = x0 + x1  # Error: unsupported operand type(s) for +: 'number_multiplier(1M)' and 'number_multiplier(1M)'\n")),(0,l.kt)("p",null,"We can use the ",(0,l.kt)("inlineCode",{parentName:"p"},"int()"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"float()")," function and ",(0,l.kt)("inlineCode",{parentName:"p"},"str()")," function to convert the numeric unit type to the normal integer type and string type."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'a: int = int(1Ki)  # 1024\nb: float = float(1Ki)  # 1024.0\nc: str = str(1Mi)  # "1Mi"\n')),(0,l.kt)("h4",{id:"string"},"String"),(0,l.kt)("p",null,"The string is an immutable sequence of Unicode characters. We can use either single or double quotes to create a string:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"'allows embedded \"double\" quotes'  # Single quotes\n\"allows embedded 'single' quotes\"  # Double quotes\n'''Three single quotes''', \"\"\"Three double quotes\"\"\"  # Triple quoted\n")),(0,l.kt)("p",null,"Triple quoted strings may span multiple lines."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'"""This is a long triple quoted string\nmay span multiple lines.\n"""\n')),(0,l.kt)("p",null,"Please note that there is almost no difference in the use of KCL single-quoted and double-quoted strings. The only thing that can be simplified is that we don\u2019t need to escape double quotes in single quoted strings, and we don\u2019t need to escape single quotes in double quoted strings."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"'This is my book named \"foo\"'  # Don\u2019t need to escape double quotes in single quoted strings.\n\"This is my book named 'foo'\"  # Don\u2019t need to escape single quotes in double quoted strings.\n")),(0,l.kt)("p",null,"We can concatenate strings using the ",(0,l.kt)("inlineCode",{parentName:"p"},"+")," operator:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"x = 'The + operator ' + 'works, as well.'\n")),(0,l.kt)("p",null,"We can cast an int or float to a string using the built-in function ",(0,l.kt)("inlineCode",{parentName:"p"},"str"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'x = str(3.5) # "3.5"\n')),(0,l.kt)("p",null,"A lot of handy built-in functions and members of a string could be used:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'x = "length"\nassert len(x) == 6 # True\nassert x.capitalize() == "Length"\nassert x.count("gt") == 1\nassert x.endswith("th") == True\nassert x.find("gth") == 3\nassert "{} {}".format("hello", "world") == \'hello world\'\nassert x.index("gth") == 3\nassert x.isalnum() == True\nassert x.isalpha() == True\nassert "123456".isdigit() == True\nassert x.islower() == True\nassert "       ".isspace() == True\nassert "This Is Title Example".istitle() == True\nassert x.isupper() == False\nassert "|".join(["a", "b", "c"]) == "a|b|c"\nassert "LENGTH".lower() == "length"\nassert \'   spacious   \'.lstrip() == \'spacious   \'\nassert x.replace("th", "ht") == "lenght"\nassert "lengthlength".rfind("le") == 6\nassert "lengthlength".rindex("le") == 6\nassert "length length".rsplit() == ["length", "length"]\nassert "length   ".rstrip() == "length"\nassert "length length".split() == ["length", "length"]\nassert \'ab c\\n\\nde fg\\rkl\\r\\n\'.splitlines() == [\'ab c\', \'\', \'de fg\', \'kl\']\nassert "length".startswith(\'len\') == True\nassert "***length***".strip(\'*\') == "length"\nassert "length length".title() == "Length Length"\nassert x.upper() == "LENGTH"\n')),(0,l.kt)("p",null,"There are 2 different ways to format a string: to use the ",(0,l.kt)("inlineCode",{parentName:"p"},'"{}".format()')," built-in function, or to specify the variable between the curly braces and use a ",(0,l.kt)("inlineCode",{parentName:"p"},"$")," mark to tell KCL to extract its value. This is called ",(0,l.kt)("strong",{parentName:"p"},"string interpolation")," in KCL. In following example, both ",(0,l.kt)("inlineCode",{parentName:"p"},"a")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"b")," will be assigned to string ",(0,l.kt)("inlineCode",{parentName:"p"},'"hello world"'),"."),(0,l.kt)("p",null,"Besides, the variable to serialized can be extracted in special data format, such as YAML or JSON.  In this case, a ",(0,l.kt)("inlineCode",{parentName:"p"},"#yaml")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"#json")," can be included within the curly braces."),(0,l.kt)("p",null,"Specifically, when the dollar sign ",(0,l.kt)("inlineCode",{parentName:"p"},"$")," itself is needed in a ",(0,l.kt)("strong",{parentName:"p"},"string interpolation"),", it needs to be escaped and use ",(0,l.kt)("inlineCode",{parentName:"p"},"$$")," instead. Or in another way, ",(0,l.kt)("inlineCode",{parentName:"p"},"+")," can be used to concat the dollar sign with the ",(0,l.kt)("strong",{parentName:"p"},"string interpolation")," to avoid that escape. In following example, both ",(0,l.kt)("inlineCode",{parentName:"p"},"c")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"c2")," will be assigned to string ",(0,l.kt)("inlineCode",{parentName:"p"},"$hello world$")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'world = "world"\na = "hello {}".format(world)       # "hello world"\nb = "hello ${world}"               # "hello world"\nc = "$$hello ${world}$$"           # "$hello world$"\nc2 = "$" + "hello ${world}" + "$"  # "$hello world$"\n\nmyDict = {\n    "key1" = "value1"\n    "key2" = "value2"\n}\n\nd = "here is myDict in json: ${myDict: #json}"\n# d: \'here is myDict in json: {"key1": "value1", "key2": "value2"}\'\n\ne = "here is myDict in yaml:\\n${myDict: #yaml}"\n# e: |\n#  here is myDict in yaml:\n#  key1: value1\n#  key2: value2\n')),(0,l.kt)("p",null,"Besides, we can see some symbols in the example code output ",(0,l.kt)("strong",{parentName:"p"},"YAML string")," above such as ",(0,l.kt)("inlineCode",{parentName:"p"},"|"),", ",(0,l.kt)("inlineCode",{parentName:"p"},">"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"+"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"-"),"."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"|")," denotes the ",(0,l.kt)("strong",{parentName:"li"},"block literal style")," that indicates how newlines inside the block should behave."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},">")," denotes the ",(0,l.kt)("strong",{parentName:"li"},"block folded style")," in the block scalar that the newlines will be replaced by spaces."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"+")," and ",(0,l.kt)("inlineCode",{parentName:"li"},"-")," are the ",(0,l.kt)("strong",{parentName:"li"},"block chomping indicators")," that control what should happen with newlines at the end of the string. The default value ",(0,l.kt)("strong",{parentName:"li"},"clip")," puts a single newline at the end of the string. To remove all newlines, ",(0,l.kt)("strong",{parentName:"li"},"strip")," them by putting a ",(0,l.kt)("inlineCode",{parentName:"li"},"-")," after the style indicators ",(0,l.kt)("inlineCode",{parentName:"li"},"|")," or ",(0,l.kt)("inlineCode",{parentName:"li"},">"),". Both clip and strip ignore how many newlines are actually at the end of the block; to ",(0,l.kt)("strong",{parentName:"li"},"keep")," them all put a ",(0,l.kt)("inlineCode",{parentName:"li"},"+")," after the style indicator.")),(0,l.kt)("p",null,"For example, a ",(0,l.kt)("strong",{parentName:"p"},"strip block literal style")," yaml string is"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},"example: |-\n  Several lines of text,\n  with some \"quotes\" of various 'types',\n  and also a blank line:\n\n  plus another line at the end.\n\n\n")),(0,l.kt)("p",null,"The result is"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-plain"},"Several lines of text,\nwith some \"quotes\" of various 'types',\nand also a blank line:\n\nplus another line at the end.\n")),(0,l.kt)("p",null,"See ",(0,l.kt)("a",{parentName:"p",href:"https://yaml-multiline.info/"},"Yaml Multiline String")," and ",(0,l.kt)("a",{parentName:"p",href:"https://yaml.org/spec/1.2.1/"},"YAML Specification v1.2")," for more information."),(0,l.kt)("h5",{id:"raw-string"},"Raw String"),(0,l.kt)("p",null,"KCL raw string is created by prefixing a string literal with ",(0,l.kt)("inlineCode",{parentName:"p"},"'r'")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"'R'"),". KCL raw string treats backslash (",(0,l.kt)("inlineCode",{parentName:"p"},"\\"),") and string interpolation (",(0,l.kt)("inlineCode",{parentName:"p"},"${}"),") as a literal character. This is useful when we want to have a string that contains backslash, string interpolation and don\u2019t want them to be treated as an escape character."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"For backslash (",(0,l.kt)("inlineCode",{parentName:"li"},"\\"),"), the KCL code and output YAML are as follows:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'s = "Hi\\nHello"\nraw_s = r"Hi\\nHello"  # This is a KCL raw string with the `r` prefix. \n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},"s: |-\n  Hi\n  Hello\nraw_s: Hi\\nHello\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"For string interpolation (",(0,l.kt)("inlineCode",{parentName:"li"},"${}"),"), the KCL code and output YAML are as follows:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'worldString = "world"\ns = "Hello ${worldString}"\nraw_s = r"Hello ${worldString}"  # This is a KCL raw string with the `r` prefix. \n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},"worldString: world\ns: Hello world\nraw_s: Hello ${worldString}\n")),(0,l.kt)("p",null,"In addition, the most common scenario for raw strings is to be used with regular expressions:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'import regex\n\nkey = "key"\nresult = regex.match(key, r"[A-Za-z0-9_.-]*")  # True\n')),(0,l.kt)("h4",{id:"boolean"},"Boolean"),(0,l.kt)("p",null,"Boolean values are the two constant objects ",(0,l.kt)("inlineCode",{parentName:"p"},"False")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"True"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"a = True\nb = False\n")),(0,l.kt)("h4",{id:"list"},"List"),(0,l.kt)("p",null,"The list is a sequence, typically used to store collections of homogeneous items. Here\u2019s a simple KCL list:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"list = [1, 2, 3]\nassert len(list) == 3  # True\nassert list[0] == 1  # True\n")),(0,l.kt)("p",null,"We can declare a list with list comprehension:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"list = [ _x for _x in range(20) if _x % 2 == 0]\nassert list == [0, 2, 4, 6, 8, 10, 12, 14, 16, 18] # True\n")),(0,l.kt)("p",null,"We can perform nested list comprehension:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"matrix = [[1, 2], [3,4], [5,6], [7,8]]\ntranspose = [[row[_i] for row in matrix] for _i in range(2)]\nassert transpose == [[1, 3, 5, 7], [2, 4, 6, 8]] # True\n")),(0,l.kt)("p",null,"Besides, we can use two variables in the list comprehension, the first variable denotes the list index and the second variable denotes the list item."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"data = [1000, 2000, 3000]\n# Single variable loop\ndataLoop1 = [i * 2 for i in data]  # [2000, 4000, 6000]\ndataLoop2 = [i for i in data if i == 2000]  # [2000]\ndataLoop3 = [i if i > 2 else i + 1 for i in data]  # [1000, 2000, 3000]\n# Double variable loop\ndataLoop4 = [i + v for i, v in data]  # [1000, 2001, 3002]\ndataLoop5 = [v for i, v in data if v == 2000]  # [2000]\n# Use `_` to ignore loop variables\ndataLoop6 = [v if v > 2000 else v + i for i, v in data]  # [1000, 2001, 3000]\ndataLoop7 = [i for i, _ in data]  # [0, 1, 2]\ndataLoop8 = [v for _, v in data if v == 2000]  # [2000]\n")),(0,l.kt)("p",null,"We can merge list like this:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"_list0 = [1, 2, 3]\n_list1 = [4, 5, 6]\njoined_list = _list0 + _list1  # [1, 2, 3, 4, 5, 6]\n")),(0,l.kt)("p",null,"We can also use the list unpacking operator ",(0,l.kt)("inlineCode",{parentName:"p"},"*")," to merge multiple lists:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"_list0 = [1, 2, 3]\n_list1 = [4, 5, 6]\nunion_list = [*_list0, *_list1]  # [1, 2, 3, 4, 5, 6]\n")),(0,l.kt)("p",null,"We can use ",(0,l.kt)("inlineCode",{parentName:"p"},"if expressions")," to dynamically add elements to the list element, elements that meet the conditions are added to the list, and elements that do not meet the conditions are ignored."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"a = 1  # 1\ndata = [\n    1\n    if a == 1: 2\n    if a > 0: 3\n    if a < 0: 4\n]  # [1, 2, 3]\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"a = 1  # 1\ndata1 = [\n    1\n    if a == 1:\n        2\n    elif a == 2:\n        3\n    else:\n        3\n]  # [1, 2]\ndata2 = [\n    1\n    if a == 1: 2\n    elif a == 2: 2\n    else: 3\n]  # [1, 2]\n")),(0,l.kt)("p",null,"Please note that in the above ",(0,l.kt)("inlineCode",{parentName:"p"},"if expressions"),", nested use is not supported."),(0,l.kt)("p",null,"We can union two lists like this:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"_list0 = [1, 2, 3]\n_list1 = [4, 5, 6]\nunion_list = _list0 | _list1  # [4, 5, 6]\n")),(0,l.kt)("p",null,"We can use the expression ",(0,l.kt)("inlineCode",{parentName:"p"},"for k in list_var")," to traverse a list."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"data = [1, 2, 3]\ndataAnother = [val * 2 for val in data]  # [2, 4, 6]\n")),(0,l.kt)("h4",{id:"dict"},"Dict"),(0,l.kt)("p",null,"Dict is a mapping object that maps hashable values to arbitrary objects. Dict is ordered. The order of the keys follows the order of their declaration."),(0,l.kt)("p",null,"Here are a couple of simple KCL dict, created using dict literals:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"a = {\"one\" = 1, \"two\" = 2, \"three\" = 3}\nb = {'one' = 1, 'two' = 2, 'three' = 3}\nassert a == b # True\nassert len(a) == 3 # True\n")),(0,l.kt)("p",null,"We can ignore the comma ",(0,l.kt)("inlineCode",{parentName:"p"},",")," at the end of the line for writing dict key-value pairs in multiple lines:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'data = {\n    "key1" = "value1"  # Ignore the comma \',\' at the end of line\n    "key2" = "value2"\n}  # {"key1": "value1", "key2": "value2"}\n')),(0,l.kt)("p",null,"We can ignore the key quotation marks when we writing simple literals on the key."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'data = {\n    key1 = "value1"  # Ignore key quotation \'"\' \n    key2 = "value2"\n}  # {"key1": "value1", "key2": "value2"}\n')),(0,l.kt)("p",null,"In addition, the ",(0,l.kt)("strong",{parentName:"p"},"config selector expressions")," can be used to init a dict instance with nested keys."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'person = {\n    base.count = 2\n    base.value = "value"\n    labels.key = "value"\n}  # {"base": {"count": 2, "value": "value"}, "labels": {"key": "value"}}\n')),(0,l.kt)("p",null,"The output YAML is"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},"person:\n  base:\n    count: 2\n    value: value\n  labels:\n    key: value\n")),(0,l.kt)("p",null,"In KCL, different fields in dict can be referenced, such as the following example."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'config = {\n    name = "me"\n    metadata.name = name  # Reference `name` with the value `"me"` in `config` directly.\n}\n')),(0,l.kt)("p",null,"The output YAML is"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},"config:\n  name: me\n  metadata:\n    name: me\n")),(0,l.kt)("p",null,"We can declare a dict with dict comprehension:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'x = {str(i): 2 * i for i in range(3)}\nassert x == {"0" = 0, "1" = 2, "2" = 4}\n')),(0,l.kt)("p",null,"Besides, we can use two variables in the dict comprehension, the first variable denotes the dict key and the second variable denotes the dict value of the key."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'data = {key1 = "value1", key2 = "value2"}\n# Single variable loop\ndataKeys1 = {k: k for k in data}  # {"key1": "key1", "key2": "key2"}\ndataValues1 = {k: data[k] for k in data}  # {"key1": "value1", "key2": "value2"}\n# Double variable loop\ndataKeys2 = {k: k for k, v in data}  # {"key1": "key1", "key2": "key2"}\ndataValues2 = {v: v for k, v in data}  # {"value1": "value1", "value2": "value2"}\ndataFilter = {k: v for k, v in data if k == "key1" and v == "value1"}  # {"key1": "value1"}\n# Use `_` to ignore loop variables\ndataKeys3 = {k: k for k, _ in data}  # {"key1": "key1", "key2": "key2"}\ndataValues3 = {v: v for _, v in data}  # {"value1": "value1", "value2": "value2"}\n')),(0,l.kt)("p",null,"We can ",(0,l.kt)("strong",{parentName:"p"},"merge")," dict using the dict unpacking operator ",(0,l.kt)("inlineCode",{parentName:"p"},"**")," like this:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'_part1 = {\n    a = "b"\n}\n\n_part2 = {\n    c = "d"\n}\n\na_dict = {**_part1, **_part2}  # {"a: "b", "c": "d"}\n')),(0,l.kt)("p",null,"In addition, the same effect can be achieved by using the union operator ",(0,l.kt)("inlineCode",{parentName:"p"},"|"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'_part1 = {\n    a = "b"\n}\n\n_part2 = {\n    c = "d"\n}\n\na_dict = _part1 | _part2  # {"a: "b", "c": "d"}\n')),(0,l.kt)("p",null,"We can use ",(0,l.kt)("inlineCode",{parentName:"p"},"if expressions")," to dynamically add elements to the dict element, elements that meet the conditions are added to the dict, and elements that do not meet the conditions are ignored."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'a = 1  # 1\ndata = {\n    key1 = "value1"\n    if a == 1: key2 = "value2"\n    if a > 0: key3 = "value3"\n    if a < 0: key4 = "value4"\n}  # {"key1": "value1", "key2": "value2", "key3": "value3"}\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'a = 1  # 1\ndata1 = {\n    key1 = "value1"\n    if a == 1:\n        key2 = "value2"\n    elif a > 0:\n        key3 = "value3"\n    else:\n        key4 = "value4"\n}  # {"key1": "value1", "key2": "value2"}\ndata2 = {\n    key1 = "value1"\n    if a == 1: key2 = "value2"\n    elif a > 0: key3 = "value3"\n    else: key4 = "value4"\n}  # {"key1": "value1", "key2": "value2"}\n')),(0,l.kt)("p",null,"We can use the expression ",(0,l.kt)("inlineCode",{parentName:"p"},"for k in dict_var")," to traverse a dict, and we can use the ",(0,l.kt)("inlineCode",{parentName:"p"},"in")," operator to determine whether a dict contains a certain key"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'data = {key1 = "value1", key2 = "value2"}\ndataAnother = {k: data[k] + "suffix" for k in data}  # {"key1": "value1suffix", "key2": "value2suffix"}\ncontainsKey1 = "key1" in data  # True\ncontainsKey2 = "key" in data  # False\n')),(0,l.kt)("h4",{id:"none"},"None"),(0,l.kt)("p",null,"In KCL, ",(0,l.kt)("inlineCode",{parentName:"p"},"None")," can indicate that the value of the object is empty, which is similar to ",(0,l.kt)("inlineCode",{parentName:"p"},"nil")," in Go or ",(0,l.kt)("inlineCode",{parentName:"p"},"null")," in Java, and corresponds to ",(0,l.kt)("inlineCode",{parentName:"p"},"null")," in YAML."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"a = None\nb = [1, 2, None]\nc = {key1 = value1, key2 = None}\n")),(0,l.kt)("p",null,"The output is as follows:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},"a: null\nb:\n- 1\n- 2\n- null\nc:\n  key1: value1\n  key2: null\n")),(0,l.kt)("p",null,"Please note that ",(0,l.kt)("inlineCode",{parentName:"p"},"None")," cannot participate in the four arithmetic operations, but it can participate logical operators and comparison operators to perform calculations."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"a = 1 + None  # error\nb = int(None)  # error\nc = not None  # True\nd = None == None  # True\ne = None or 1  # 1\nf = str(None)  # None\n")),(0,l.kt)("h4",{id:"undefined"},"Undefined"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"Undefined")," is similar to ",(0,l.kt)("inlineCode",{parentName:"p"},"None"),", but its semantics is that a variable is not assigned any value and will not be output to YAML"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'a = Undefined\nb = [1, 2, Undefined]\nc = {key1 = "value1", key2 = Undefined}\n')),(0,l.kt)("p",null,"The output is as follows:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},"b:\n- 1\n- 2\nc:\n  key1: value1\n")),(0,l.kt)("p",null,"Please note that ",(0,l.kt)("inlineCode",{parentName:"p"},"Undefined")," cannot participate in the four arithmetic operations, but it can participate logical operators and comparison operators to perform calculations."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"a = 1 + Undefined  # error\nb = int(Undefined)  # error\nc = not Undefined  # True\nd = Undefined == Undefined  # True\ne = Undefined or 1  # 1\nf = str(Undefined)  # Undefined\n")),(0,l.kt)("h3",{id:"operators"},"Operators"),(0,l.kt)("p",null,"The following character sequences represent operators:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-txt"},"+       -       *       **      /       //      %\n<<      >>      &       |       ^       <       >\n~       <=      >=      ==      !=      @       \\\n")),(0,l.kt)("h4",{id:"arithmetic-operators"},"Arithmetic Operators"),(0,l.kt)("p",null,"KCL supports the common arithmetic operators:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"assert 2 + 3 == 5\nassert 2 - 3 == -1\nassert 2 * 3 == 6\nassert 5 / 2 == 2.5\nassert 5 // 2 == 2\nassert 5 % 2 == 1\n")),(0,l.kt)("h4",{id:"equality-and-relational-operators"},"Equality and Relational Operators"),(0,l.kt)("p",null,"KCL supports the meanings of equality and relational operators:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"assert 2 == 2\nassert 2 != 3\nassert 3 > 2\nassert 2 < 3\nassert 3 >= 3\nassert 2 <= 3\n")),(0,l.kt)("h4",{id:"logical-operators"},"Logical Operators"),(0,l.kt)("p",null,"We can invert or combine boolean expressions using the logical operators e.g., ",(0,l.kt)("inlineCode",{parentName:"p"},"and")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"or"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"if not done and (col == 0 or col == 3):\n  # ...Do something...\n\n")),(0,l.kt)("h4",{id:"bitwise-and-shift-operators"},"Bitwise and Shift Operators"),(0,l.kt)("p",null,"Here are examples of using bitwise and shift operators:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"value = 0x22\nbitmask = 0x0f\n\nassert (value & bitmask) == 0x02\nassert (value & ~bitmask) == 0x20\nassert (value | bitmask) == 0x2f\nassert (value ^ bitmask) == 0x2d\nassert (value << 4) == 0x220\nassert (value >> 4) == 0x02\n")),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"|")," operator likewise computes bitwise, unions basic types and unions collection and schema data, such as ",(0,l.kt)("strong",{parentName:"p"},"list"),", ",(0,l.kt)("strong",{parentName:"p"},"dict")," and ",(0,l.kt)("strong",{parentName:"p"},"schema"),"."),(0,l.kt)("p",null,"Computing bitwise examples:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"0x12345678 | 0xFF  # 0x123456FF\n")),(0,l.kt)("p",null,"Unioning basic types examples:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"schema x:\n    a: int | str  # attribute a could be a int or string\n")),(0,l.kt)("h4",{id:"assignment-operators"},"Assignment Operators"),(0,l.kt)("p",null,"The following tokens serve as delimiters in the grammar:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"    (       )       [       ]       {       }\n    ,       :       .       ;       =       ->\n    +=      -=      *=      /=      //=     %=\n    &=      ^=      >>=     <<=     **=\n")),(0,l.kt)("p",null,"The following examples use assignment and argument assignment operators:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"_a = 2\n_a *= 3\n_a += 1\nassert _a == 7\n")),(0,l.kt)("h4",{id:"identity-operators"},"Identity Operators"),(0,l.kt)("p",null,"The following keywords serve as identity operators in the grammar:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"is, is not\n")),(0,l.kt)("p",null,"The identity operators check whether the right hand side and the left hand side are the very same object. They are usually used to check if some variable is ",(0,l.kt)("inlineCode",{parentName:"p"},"None/Undefined/True/False"),". Here are some examples:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'empty_String = ""\nempty_String is not None # True\n')),(0,l.kt)("h4",{id:"membership-operators"},"Membership Operators"),(0,l.kt)("p",null,"The following keywords serve as membership operators in the grammar:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"in, not in\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"The ",(0,l.kt)("inlineCode",{parentName:"li"},"in")," operator reports whether its first operand is a member of its second operand, which must be a list, dict, schema, or string."),(0,l.kt)("li",{parentName:"ul"},"The ",(0,l.kt)("inlineCode",{parentName:"li"},"not in")," operator is its negation. Both return a Boolean.")),(0,l.kt)("p",null,"The meaning of membership varies by the type of the second operand: the members of a list are its elements; the members of a dict are its keys; the members of a string are all its substrings."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'1 in [1, 2, 3]                  # True\n\nd = {one = 1, two = 2}\n"one" in d                      # True\n"three" in d                    # False\n1 in d                          # False\n[] in d                         # False\n\n"nasty" in "dynasty"            # True\n"a" in "banana"                 # True\n"f" not in "way"                # True\n\nd = Data {one = 1, two = 2}     # Data is a schema with attributes one and two\n"one" in d                      # True\n"three" in d                    # False\n')),(0,l.kt)("h4",{id:"comprehension"},"Comprehension"),(0,l.kt)("p",null,"A comprehension constructs a new list or dictionary value by looping over one or more iterables and evaluating a body expression that produces successive elements of the result."),(0,l.kt)("p",null,"We can declare list and dict by comprehension as:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"listVar = [_x for _x in range(20) if _x % 2 == 0] # list comprehension\ndictVar = {str(_i): 2 * _i for _i in range(3)} # dict comprehension\n")),(0,l.kt)("h4",{id:"other-operators"},"Other Operators"),(0,l.kt)("p",null,"We can:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Represents a function call with ",(0,l.kt)("strong",{parentName:"li"},"()"),", like ",(0,l.kt)("inlineCode",{parentName:"li"},'"{} {}".format("hello", world)')),(0,l.kt)("li",{parentName:"ul"},"Refers to the value at the specified index in the list with ",(0,l.kt)("strong",{parentName:"li"},"[]")),(0,l.kt)("li",{parentName:"ul"},"Define a type hint with ",(0,l.kt)("strong",{parentName:"li"},":")),(0,l.kt)("li",{parentName:"ul"},"Refers to a member field with ",(0,l.kt)("strong",{parentName:"li"},".")),(0,l.kt)("li",{parentName:"ul"},"Use the line continuation symbol ",(0,l.kt)("inlineCode",{parentName:"li"},"\\")," to write long expressions")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'longString = "Too long expression " + \\\n             "Too long expression " + \\\n             "Too long expression "\n')),(0,l.kt)("h3",{id:"expressions"},"Expressions"),(0,l.kt)("h4",{id:"conditional-expressions"},"Conditional Expressions"),(0,l.kt)("p",null,"A conditional expression has the form ",(0,l.kt)("inlineCode",{parentName:"p"},"a if cond else b"),". It first evaluates the condition ",(0,l.kt)("inlineCode",{parentName:"p"},"cond"),". If it's true, it evaluates ",(0,l.kt)("inlineCode",{parentName:"p"},"a")," and yields its value; otherwise, it yields the value of ",(0,l.kt)("inlineCode",{parentName:"p"},"b"),"."),(0,l.kt)("p",null,"Examples:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"x = True if enabled else False  # If enabled is True, x is True, otherwise x is False\n")),(0,l.kt)("h4",{id:"index-expressions"},"Index Expressions"),(0,l.kt)("p",null,"An index expression ",(0,l.kt)("inlineCode",{parentName:"p"},"a[i]")," yields the ",(0,l.kt)("inlineCode",{parentName:"p"},"i")," th element of an indexable type such as a string or list. The index ",(0,l.kt)("inlineCode",{parentName:"p"},"i")," must be an ",(0,l.kt)("inlineCode",{parentName:"p"},"int")," value in the range ",(0,l.kt)("inlineCode",{parentName:"p"},"-n")," \u2264 ",(0,l.kt)("inlineCode",{parentName:"p"},"i")," < ",(0,l.kt)("inlineCode",{parentName:"p"},"n"),", where ",(0,l.kt)("inlineCode",{parentName:"p"},"n")," is ",(0,l.kt)("inlineCode",{parentName:"p"},"len(a)"),"; any other index results in an error."),(0,l.kt)("p",null,"A valid negative index ",(0,l.kt)("inlineCode",{parentName:"p"},"i")," behaves like the non-negative index ",(0,l.kt)("inlineCode",{parentName:"p"},"n+i"),", allowing for convenient indexing relative to the end of the sequence."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'val = "abc"\nlist = ["zero", "one", "two"]\nstr_0 = val[0]         # "a"\nstr_1 = val[1]         # "b"\nstr_n1 = val[-1]       # "c"\n\nlist_0 = list[0]       # "zero"\nlist_1 = list[1]       # "one"\nlist_n1 = list[-1]     # "two"\n')),(0,l.kt)("p",null,"An index expression ",(0,l.kt)("inlineCode",{parentName:"p"},"d[key]")," may also be applied to a dictionary ",(0,l.kt)("inlineCode",{parentName:"p"},"d"),", to obtain the value associated with the specified key. It returns ",(0,l.kt)("inlineCode",{parentName:"p"},"Undefined")," if the dictionary contains no such key."),(0,l.kt)("p",null,"An index expression appearing on the left side of an assignment causes the specified list or dictionary element to be updated:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'d = {key1 = "value1", key2 = "value2"}\nkey1value = d["key1"]  # value1\nkey2value = d["key2"]  # value2\n')),(0,l.kt)("p",null,"It is a dynamic error to attempt to update an element of an immutable type, such as a list or string, or a frozen value of a mutable type."),(0,l.kt)("h4",{id:"slice-expressions"},"Slice Expressions"),(0,l.kt)("p",null,"A slice expression ",(0,l.kt)("inlineCode",{parentName:"p"},"a[start:stop:step]")," yields a new value containing a sub-sequence of ",(0,l.kt)("inlineCode",{parentName:"p"},"a"),", which must be a string, or list."),(0,l.kt)("p",null,"Each of the ",(0,l.kt)("inlineCode",{parentName:"p"},"start"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"stop"),", and ",(0,l.kt)("inlineCode",{parentName:"p"},"step")," operands is optional; if present, each must be an integer. The ",(0,l.kt)("inlineCode",{parentName:"p"},"step")," value defaults to 1. If the step is not specified, the colon preceding it may be omitted too. It is an error to specify a step of zero."),(0,l.kt)("p",null,"Conceptually, these operands specify a sequence of values ",(0,l.kt)("inlineCode",{parentName:"p"},"i")," starting at start and successively adding 'step' until ",(0,l.kt)("inlineCode",{parentName:"p"},"i")," reaches or passes ",(0,l.kt)("inlineCode",{parentName:"p"},"stop"),". The result consists of the concatenation of values of ",(0,l.kt)("inlineCode",{parentName:"p"},"a[i]")," for which ",(0,l.kt)("inlineCode",{parentName:"p"},"i")," is valid."),(0,l.kt)("p",null,"The effective start and stop indices are computed from the three operands as follows. Let ",(0,l.kt)("inlineCode",{parentName:"p"},"n")," be the length of the sequence."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'val = "abc"\nlen = len(val)\na = val[1:len]         # "bc"  (remove first element)\nb = val[0:-1]          # "ab"  (remove last element)\nc = val[1:-1]          # "b"   (remove first and last element)\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'"abc"[1:]               # "bc"  (remove first element)\n"abc"[:-1]              # "ab"  (remove last element)\n"abc"[1:-1]             # "b"   (remove first and last element)\n"banana"[1::2]          # "aaa" (select alternate elements starting at index 1)\n"banana"[4::-2]         # "nnb" (select alternate elements in reverse, starting at index 4)\n')),(0,l.kt)("p",null,"It's not allowed to define a slice expression as a left value in KCL. Cause list and string are immutable, re-slicing can directly operate to operand to ensure better performance."),(0,l.kt)("h4",{id:"function-invocations"},"Function Invocations"),(0,l.kt)("p",null,"KCL allows calling built-in functions and functions from built-in and system modules."),(0,l.kt)("p",null,"To call a function, the basic way is shown as the following code excerpt:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"import math\n\na = math.pow(2, 3)  # 2 powers 3 is 8.\nb = len([1, 2, 3])  # the length of [1, 2, 3] is 3\n")),(0,l.kt)("p",null,"As you can see, arguments are separated with ",(0,l.kt)("inlineCode",{parentName:"p"},","),", and KCL also supports positional arguments and key-value arguments."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'print("hello world", end="")\n')),(0,l.kt)("p",null,"Note that:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Some functions have parameters with default values."),(0,l.kt)("li",{parentName:"ul"},"Some functions accept variadic arguments.")),(0,l.kt)("p",null,"When an argument is not supplied for a parameter without a default value, an error will be reported."),(0,l.kt)("h4",{id:"selector-expressions"},"Selector Expressions"),(0,l.kt)("p",null,"A selector expression selects the attribute or method of the value. KCL provides a wealth of ways to identify or filter attributes."),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"x.y")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"dict: it denotes the value of the key ",(0,l.kt)("inlineCode",{parentName:"li"},"y")," in the dict ",(0,l.kt)("inlineCode",{parentName:"li"},"x")),(0,l.kt)("li",{parentName:"ul"},"schema: it denotes the attribute value of a schema ",(0,l.kt)("inlineCode",{parentName:"li"},"x")," identified by ",(0,l.kt)("inlineCode",{parentName:"li"},"y")),(0,l.kt)("li",{parentName:"ul"},"package: it denotes the identifier of a package ",(0,l.kt)("inlineCode",{parentName:"li"},"x")," identified by ",(0,l.kt)("inlineCode",{parentName:"li"},"y"))),(0,l.kt)("p",null,"Examples:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'schema Person:\n    name: str\n    age: int\n\nperson = Person {\n    name = "Alice"\n    age = 18\n}\nname = person.name  # "Alice"\nage = person.age  # 18\n\nmyDict = {\n    key = "value"\n}\nresult = myDict.key # "value"\n')),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"x?.y")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"x")," can be a schema instance or a dict. This is extremely helpful when the value of ",(0,l.kt)("inlineCode",{parentName:"p"},"x")," might be ",(0,l.kt)("inlineCode",{parentName:"p"},"None")," or when the key ",(0,l.kt)("inlineCode",{parentName:"p"},"y")," might not exist in ",(0,l.kt)("inlineCode",{parentName:"p"},"x"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'# Example of dict:\ndata = {key = "value"}\na = data?.key     # "value"\nb = data?.name    # Undefined\n\n# example of schema instance:\nschema Company:\n    name: str\n    address: str\n\nschema Person:\n    name: str\n    job?: Company\n        \nalice = Person {\n    name = "alice"\n}\n\nif alice?.job?.name == "Group":\n    print("work in Group")\n')),(0,l.kt)("h4",{id:"quantifier-expressions"},"Quantifier Expressions"),(0,l.kt)("p",null,"Quantifier expressions act on collection: list or dict, generally used to obtain a certain result after processing the collection, mainly in the following four forms:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"all"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Used to detect that all elements in the collection satisfy the given logical expression, and return a boolean value as the result."),(0,l.kt)("li",{parentName:"ul"},"Only when all elements in the collection satisfy the expression true, the ",(0,l.kt)("inlineCode",{parentName:"li"},"all")," expression is true, otherwise it is false."),(0,l.kt)("li",{parentName:"ul"},"If the original collection is empty, return true."),(0,l.kt)("li",{parentName:"ul"},"Supports short-circuiting of logical expressions during expression execution."))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"any"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Used to detect that at least one element in the collection satisfies the given logical expression, and returns a boolean value as the result."),(0,l.kt)("li",{parentName:"ul"},"When at least one element in the collection satisfies the expression true, the ",(0,l.kt)("inlineCode",{parentName:"li"},"any")," expression is true, otherwise it is false."),(0,l.kt)("li",{parentName:"ul"},"If the original collection is empty, return false."),(0,l.kt)("li",{parentName:"ul"},"Supports short-circuiting of logical expressions during expression execution."))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"map"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Generate a new ",(0,l.kt)("strong",{parentName:"li"},"list")," by mapping the elements in the original collection."),(0,l.kt)("li",{parentName:"ul"},"The length of the new list is exactly the same as the original collection."))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"filter"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"By logically judging and filtering the elements in the original collection, and returning the filtered sub-collection."),(0,l.kt)("li",{parentName:"ul"},"Only when the element judges the expression to be true, it is added to the sub-collection."),(0,l.kt)("li",{parentName:"ul"},"The type (list, dict and schema) of the new collection is exactly the same as the original collection, and the length range is ",(0,l.kt)("inlineCode",{parentName:"li"},"[0, len(original-collection)]"),".")))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"all")," and ",(0,l.kt)("strong",{parentName:"p"},"any")," expression sample codes:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'schema Config:\n    volumes: [{str:}]\n    services: [{str:}]\n\n    check:\n        all service in services {\n            service.clusterIP == "NONE" if service.type == "ClusterIP"\n        }, "invalid cluster ip"\n\n        any volume in volumes {\n            volume.mountPath in ["/home/admin", "/home/myapp"]\n        }\n')),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"map")," and ",(0,l.kt)("strong",{parentName:"p"},"filter")," expression sample codes:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'a = map e in [{name = "1", value = 1}, {name = "2", value = 2}] {\n    {name = e.name, value = int(e.value) ** 2}\n}  # [{"name": "1", value: 1}, {"name": "2", "value": 4}]\n\nb = map k, v in {a = "foo", b = "bar"} { v }  # ["foo", "bar"]\n\nc = filter e in [{name = "1", value = 1}, {name = "2", value = 2}] {\n    int(e.value) > 1\n}  # [{"name": "2", "value": 2}]\n\nd = filter _, v in {a = "foo", b = "bar"} {\n    v == "foo"\n}  # {"a": "foo"}\n')),(0,l.kt)("p",null,"Please pay attention to distinguish the difference between any expression and any type. When ",(0,l.kt)("inlineCode",{parentName:"p"},"any")," is used in type annotations, it means that the value of the variable is arbitrary, while the any expression means that one of the elements in a set satisfies the condition."),(0,l.kt)("h3",{id:"control-flow-statements"},"Control Flow Statements"),(0,l.kt)("h4",{id:"if-and-else"},"If and Else"),(0,l.kt)("p",null,"KCL supports ",(0,l.kt)("inlineCode",{parentName:"p"},"if")," statements with optional ",(0,l.kt)("inlineCode",{parentName:"p"},"elif")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"else")," statements, as the next sample shows."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'a = 10\nif a == 0:\n    print("a is zero")\nelif a < 100:\n    print("a < 100")\n    print("maybe a is negative")\nelse:\n    print("a >= 100")\n')),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"elif")," example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'_result = 0\nif condition == "one":\n    _result = 1\nelif condition == "two":\n    _result = 2\nelif condition == "three":\n    _result = 3\nelse:\n    _result = 4\n')),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"if-elif-else")," statements can be nested. For example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'a = 10\nif a == 0:\n    print("a is zero")\nelif a < 100:\n    print("a < 100")\n    if a < 0:\n        print("a is negative")\n    print("No matter a is negative or positive, this message is printed")\nelse:\n    print("a >= 100")\n')),(0,l.kt)("p",null,"In addition, for simple ",(0,l.kt)("inlineCode",{parentName:"p"},"if")," statements as follows:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'if success:\n    _result = "success"\nelse:\n    _result = "failed"\n')),(0,l.kt)("p",null,"We can have it in one line using the ",(0,l.kt)("inlineCode",{parentName:"p"},"<expr> if <condition> else <expr>")," pattern:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'_result = "success" if success else "failed"\n')),(0,l.kt)("p",null,"An ",(0,l.kt)("inlineCode",{parentName:"p"},"if")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"elif")," statement evaluates a given expression. When the expression is evaluated to ",(0,l.kt)("inlineCode",{parentName:"p"},"True"),", a list of statements following ",(0,l.kt)("inlineCode",{parentName:"p"},":")," are executed and when the expression is evaluated to ",(0,l.kt)("inlineCode",{parentName:"p"},"False")," and statements will not be executed."),(0,l.kt)("p",null,"Please note that the false name constant ",(0,l.kt)("inlineCode",{parentName:"p"},"False"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"None"),", the zero number ",(0,l.kt)("inlineCode",{parentName:"p"},"0"),", the empty list ",(0,l.kt)("inlineCode",{parentName:"p"},"[]"),", the empty dict ",(0,l.kt)("inlineCode",{parentName:"p"},"{}")," and the empty string ",(0,l.kt)("inlineCode",{parentName:"p"},'""')," are all seen as ",(0,l.kt)("inlineCode",{parentName:"p"},"False")," expressions."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'_emptyStr = ""\n_emptyList = []\n_emptyDict = {}\nisEmptyStr = False if _emptyStr else True\nisEmptyList = False if _emptyList else True\nisEmptyDict = False if _emptyDict else True\n')),(0,l.kt)("p",null,"The output is"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},"isEmptyStr: true\nisEmptyList: true\nisEmptyDict: true\n")),(0,l.kt)("h3",{id:"assert"},"Assert"),(0,l.kt)("p",null,"When errors happen, developers should be able to detect the error and abort execution. Thus, KCL introduce the ",(0,l.kt)("inlineCode",{parentName:"p"},"assert")," syntax. The following is an example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'a = 1\nb = 3\n# a != b evaluates to True, therefore no error should happen.\nassert a != b\n# a == b is False, in the reported error message, the message "SOS" should be printed.\nassert a == b, "SOS"\n')),(0,l.kt)("p",null,"In addition, we can declare a condition for the assert statement and make an assertion when the condition is met. The usual way of writing is"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"a = None\nif a:\n    assert a > 2:\n")),(0,l.kt)("p",null,"In KCL, it can also be simplified to the following form using the ",(0,l.kt)("strong",{parentName:"p"},"if")," expression to compose more complex conditional assert logic:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"a = None\nassert a > 2 if a\n")),(0,l.kt)("h3",{id:"function"},"Function"),(0,l.kt)("p",null,"KCL supports using the lambda keyword to define a function."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"func = lambda x: int, y: int -> int {\n    x + y\n}\na = func(1, 1)  # 2\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"The value of the last expression is used as the return value of the function, and the empty function body returns ",(0,l.kt)("inlineCode",{parentName:"li"},"None"),"."),(0,l.kt)("li",{parentName:"ul"},"The return value type annotation can be omitted, and the return value type is the type of the last expression value."),(0,l.kt)("li",{parentName:"ul"},"There is no order-independent feature in the function body, all expressions are executed in order.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"_func = lambda x: int, y: int -> int {\n    x + y\n}  # Define a function using the lambda expression\n_func = lambda x: int, y: int -> int {\n    x - y\n}  # Ok\n_func = lambda x: int, y: int -> str {\n    str(x + y)\n}  # Error (int, int) -> str can't be assigned to (int, int) -> int\n")),(0,l.kt)("p",null,"The function type variables cannot participate in any calculations and can only be used in assignment statements and call statements."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"func = lambda x: int, y: int -> int {\n    x + y\n}\nx = func + 1  # Error: unsupported operand type(s) for +: 'function' and 'int(1)'\n")),(0,l.kt)("p",null,"The lambda function supports the capture of external variables, which can be passed as parameters of other functions."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"a = 1\nfunc = lambda x: int {\n    x + a\n}\nfuncOther = lambda f, para: int {\n    f(para)\n}\nr0 = funcOther(func, 1)  # 2\nr1 = funcOther(lambda x: int {\n    x + a\n}, 1)  # 2\n")),(0,l.kt)("p",null,"The output is"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},"a: 1\nr: 2\n")),(0,l.kt)("p",null,"Further, we can define an anonymous function through lambda expression and call it."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"result = (lambda x, y {\n    z = 2 * x\n    z + y\n})(1, 1)  # 3\n")),(0,l.kt)("p",null,"We can also use anonymous functions in the for loop."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"result = [(lambda x, y {\n    x + y\n})(x, y) for x in [1, 2] for y in [1, 2]]  # [2, 3, 3, 4]\n")),(0,l.kt)("p",null,"Note that the functions defined in the KCL are pure functions:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"The return result of a function depends only on its arguments."),(0,l.kt)("li",{parentName:"ul"},"There are no side effects in the function execution process.")),(0,l.kt)("p",null,"Therefore, KCL functions cannot modify external variables, but can only reference external variables. For example, the following code will cause an error:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"globalVar = 1\nfunc = lambda {\n    x = globalVar  # Ok\n    globalVar = 1  # Error\n}\n")),(0,l.kt)("h3",{id:"type-system"},"Type System"),(0,l.kt)("h4",{id:"type-annotation"},"Type Annotation"),(0,l.kt)("p",null,"Type annotations can be used on top level variables, schema attributes and arguments."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"An attribute can be of a basic type, such as a string (",(0,l.kt)("inlineCode",{parentName:"li"},"str"),"), a floating-point number (",(0,l.kt)("inlineCode",{parentName:"li"},"float"),"), a fixed-point number (",(0,l.kt)("inlineCode",{parentName:"li"},"int"),") or a boolean (",(0,l.kt)("inlineCode",{parentName:"li"},"bool"),")."),(0,l.kt)("li",{parentName:"ul"},"An attribute can be a literal type, such as a string literal (",(0,l.kt)("inlineCode",{parentName:"li"},'"TCP"')," and ",(0,l.kt)("inlineCode",{parentName:"li"},'"UDP"'),"), a number literal (",(0,l.kt)("inlineCode",{parentName:"li"},'"1"')," and ",(0,l.kt)("inlineCode",{parentName:"li"},'"1.2"'),"), a boolean literal (",(0,l.kt)("inlineCode",{parentName:"li"},"True")," and ",(0,l.kt)("inlineCode",{parentName:"li"},"False"),")"),(0,l.kt)("li",{parentName:"ul"},"An attribute can also be a list or an ordinary dict:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"A list with unspecified type of elements is ",(0,l.kt)("inlineCode",{parentName:"li"},"[]"),"."),(0,l.kt)("li",{parentName:"ul"},"A list with elements of type ",(0,l.kt)("inlineCode",{parentName:"li"},"t")," is ",(0,l.kt)("inlineCode",{parentName:"li"},"[t]"),". Here ",(0,l.kt)("inlineCode",{parentName:"li"},"t")," is another type."),(0,l.kt)("li",{parentName:"ul"},"A dict with keys of type ",(0,l.kt)("inlineCode",{parentName:"li"},"kt")," and values of type ",(0,l.kt)("inlineCode",{parentName:"li"},"vt")," is ",(0,l.kt)("inlineCode",{parentName:"li"},"{kt:vt}"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"kt"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"vt")," or both of them can be missing, like a list with unspecified type of elements."))),(0,l.kt)("li",{parentName:"ul"},"An attribute can be a ",(0,l.kt)("strong",{parentName:"li"},"union type")," defined by ",(0,l.kt)("inlineCode",{parentName:"li"},"|"),", such as ",(0,l.kt)("inlineCode",{parentName:"li"},"a | b"),", which means the type of the member could be a or b.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"A union type can include any types of ",(0,l.kt)("inlineCode",{parentName:"li"},"int"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"str"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"float"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"bool"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"list"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"dict"),", literal and schema type, and supports type nesting e.g. ",(0,l.kt)("inlineCode",{parentName:"li"},"{str:str|int}"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"[[int|str]|str|float]")," and ",(0,l.kt)("inlineCode",{parentName:"li"},"2 | 4 | 6"),", etc."))),(0,l.kt)("li",{parentName:"ul"},"An attribute can also be of a type generated from other schema. In such a case, the name of the other schema (including the package path prefix) is used as the type name."),(0,l.kt)("li",{parentName:"ul"},"An attribute can annotated an any type e.g., ",(0,l.kt)("inlineCode",{parentName:"li"},"any"),".")),(0,l.kt)("p",null,"Examples:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Basic type")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'"""Top level variable type annotation"""\na: int = 1  # Declare a variable `a` that has the type `int` and the value `1`\nb: str = "s"  # Declare a variable `b` that has the type `str` and the value `"s"`\nc: float = 1.0  # Declare a variable `c` that has the type `float` and the value `1.0`\nd: bool = True  # Declare a variable `d` that has the type `bool` and the value `True`\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"List/Dict/Schema Type")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'schema Person:\n    name: str = "Alice"\n    age: int = 10\n\na: [int] = [1, 2, 3]  # Declare a variable `a` that has the list type `[int]` and the value `[1, 2, 3]`\nb: {str:str} = {k1 = "v1", k2 = "v2"}  # Declare a variable `b` that has the dict type `{str:str}` and the value `{k1 = "v1", k2 = "v2"}`\nc: Person = Person {}  # Declare a variable `c` that has the schema type `Person` and the value `Person {}`\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Union Type")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"# Basic union types\nschema x[argc: int]:  # Schema argument type annotation\n    p: int | str  # Schema attribute type annotation\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'# Literal union types\nschema LiteralType:\n    # String literal union types, x_01 can be one of "TCP" and "UDP"\n    x_01: "TCP" | "UDP"\n    # Number literal union types, x_02 can be one of 2, 4, and 6\n    x_02: 2 | 4 | 6\n    # Unit union types, x_03 can be one of 1Gi, 2Gi and 4Gi\n    x_03: 1Gi | 2Gi | 4Gi\n\nx = LiteralType {\n    x_01 = "TCP"\n    x_02 = 2\n    x_03 = 1Gi\n}\n')),(0,l.kt)("p",null,"The compiler throws an error when the value of a property does not conform to the union type definition:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'# Literal union types\nschema LiteralType:\n    # String literal union types, x_01 can be one of "TCP" and "UDP"\n    x_01: "TCP" | "UDP"\n\nx = LiteralType {\n    x_01 = "HTTP"  # Error: the type got is inconsistent with the type expected, expect str(TCP)|str(UDP), got str(HTTP)\n}\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Any Type")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'# Any type\nschema Config:\n    literalConf: any = 1\n    dictConf: {str:any} = {key = "value"}\n    listConf: [any] = [1, "2", True]\n\nconfig = Config {}\n')),(0,l.kt)("p",null,"In KCL, changing the type of a variable is not allowed. If the type is not satisfied when reassigning the value, the type error will be raised."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'_a = 1  # The type of `_a` is `int`\n_a = "s"  # Error: expect int, got str(s)\n')),(0,l.kt)("p",null,"The type of a variable can be assigned to its upper bound type, but cannot be assigned to its specialized type."),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"None")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"Undefined")," can be assigned to any type:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"All types can be assigned to ",(0,l.kt)("inlineCode",{parentName:"li"},"any")," type, ",(0,l.kt)("inlineCode",{parentName:"li"},"None")," and ",(0,l.kt)("inlineCode",{parentName:"li"},"Undefined")," can be assigned to ",(0,l.kt)("inlineCode",{parentName:"li"},"any")," type.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'a: int = None\nb: str = Undefined\nc: any = 1\nd: any = "s"\ne: any = None\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"The ",(0,l.kt)("inlineCode",{parentName:"li"},"int")," type can be assigned to the ",(0,l.kt)("inlineCode",{parentName:"li"},"float")," type, and the ",(0,l.kt)("inlineCode",{parentName:"li"},"float")," type cannot be assigned to the ",(0,l.kt)("inlineCode",{parentName:"li"},"int")," type.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"a: float = 1\nb: int = 1.0  # Error: expect int, got float(1.0)\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"The ",(0,l.kt)("inlineCode",{parentName:"li"},"int")," type can be assigned to the ",(0,l.kt)("inlineCode",{parentName:"li"},"int|str")," type, and the ",(0,l.kt)("inlineCode",{parentName:"li"},"int|str")," type cannot be assigned to the ",(0,l.kt)("inlineCode",{parentName:"li"},"int")," type.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'a: int | str = 1\nb: int = 1 if a else "s"  # Error: expect int, got int(1)|str(s)\n')),(0,l.kt)("p",null,"Note that although the any type is provided in the KCl, it is still a static type, and the types of all variables are immutable during compilation."),(0,l.kt)("h4",{id:"type-inference"},"Type Inference"),(0,l.kt)("p",null,"If a variable or constant declaration in the top level or in the schema is not annotated explicitly with a type, the declaration's type is inferred from the initial value."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Integer literals are inferred to type ",(0,l.kt)("inlineCode",{parentName:"li"},"int"),".")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"a = 1  # The variable `a` has the type `int`\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Float literals are inferred to type ",(0,l.kt)("inlineCode",{parentName:"li"},"float"),".")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"a = 1.0  # The variable `a` has the type `float`\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"String literals are inferred to type ",(0,l.kt)("inlineCode",{parentName:"li"},"str"),".")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'a = "s"  # The variable `a` has the type `str`\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Boolean literals are inferred to type ",(0,l.kt)("inlineCode",{parentName:"li"},"bool"))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"a = True  # The variable `a` has the type `bool`\nb = False  # The variable `b` has the type `bool`\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"None")," and ",(0,l.kt)("inlineCode",{parentName:"li"},"Undefined")," are inferred to type ",(0,l.kt)("inlineCode",{parentName:"li"},"any"))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"a = None  # The variable `a` has the type `any`\nb = Undefined  # The variable `b` has the type `any`\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"List literals are inferred based on the elements of the literal, and to be variable-size.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'a = [1, 2, 3]  # The variable `a` has the type `[int]`\nb = [1, 2, True]  # The variable `b` has the list union type `[int|bool]`\nc = ["s", 1]  # The variable `c` has the list union type `[int|str]`\n')),(0,l.kt)("p",null,"Please note that a empty list will be inferred to ",(0,l.kt)("inlineCode",{parentName:"p"},"[any]")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"a = []  # The variable `a` has the type `[any]`\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Dict literals are inferred based on the keys and values of the literal, and to be variable-size.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'a = {key = "value"}  # The variable `a` has the type `{str:str}`\nb = {key = 1}  # The variable `b` has the type `{str:int}`\nc = {key1 = 1, key2 = "s"}  # The variable `c` has the type `{str:int|str}`\n')),(0,l.kt)("p",null,"Please note that a empty dict will be inferred to ",(0,l.kt)("inlineCode",{parentName:"p"},"{any:any}")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"a = {}  # The variable `a` has the type `{any:any}`\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"The type of the if conditional expression carrying the runtime value will be statically inferred as a union type of all possible results.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'a: bool = True  # The variable `a` has the type `bool`\nb = 1 if a else "s"  # The variable `b` has the type `int|str`\n')),(0,l.kt)("p",null,"When a variable is deduced to a certain type, its type cannot be changed"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'_a = 1\n_a = "s"  # Error: expect int, got str(1)\n')),(0,l.kt)("h4",{id:"type-alias"},"Type Alias"),(0,l.kt)("p",null,"We can use the ",(0,l.kt)("inlineCode",{parentName:"p"},"type")," keyword to declare a type alias for all types in KCL to simplify the writing and use of complex types."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"type Int = int\ntype String = str\ntype StringOrInt = String | Int\ntype IntList = [int]\ntype StringAnyDict = {str:}\n")),(0,l.kt)("p",null,"We can import a type through import and define an alias for it."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-py"},"import pkg\n\ntype Data = pkg.Data\n")),(0,l.kt)("p",null,"In addition, we can use type aliases and union types to achieve similar enumeration functions."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'# A type alias of string literal union types\ntype Color = "Red" | "Yellow" | "Blue"\n\nschema Config:\n    color: Color = "Red"  # The type of color is `"Red" | "Yellow" | "Blue"`, and it has an alias `Color`, whose default value is `"Red"`\n\nconfig = Config {\n    color = "Blue"\n}\n')),(0,l.kt)("p",null,"The output YAML is"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},"config:\n  color: Blue\n")),(0,l.kt)("p",null,"Please note that the type alias name cannot be one of ",(0,l.kt)("inlineCode",{parentName:"p"},"any"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"int"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"float"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"bool")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"str")," because of ambiguity."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'type any = int | str  # Error\ntype int = str  # Error\ntype float = int  # Error\ntype bool = True  # Error\ntype str = "A" | "B" | "C"  # Error\n')),(0,l.kt)("h4",{id:"type-guards"},"Type Guards"),(0,l.kt)("p",null,"KCL supports the ",(0,l.kt)("inlineCode",{parentName:"p"},"typeof")," function which can give very basic information about the type of values we have at runtime. In KCL, checking against the value returned by ",(0,l.kt)("inlineCode",{parentName:"p"},"typeof")," is a type guard. KCL expects this to return a certain set of strings:"),(0,l.kt)("p",null,"Example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'import sub as pkg\n\n_a = 1\n\nt1 = typeof(_a)\nt2 = typeof("abc")\n\nschema Person:\n    name?: any\n\n_x1 = Person {}\nt3 = typeof(_x1)\n\n_x2 = pkg.Person {}\nt4 = typeof(_x2)\nt5 = typeof(_x2, full_name=True)\n\nt6 = typeof(_x1, full_name=True)\n\n# Output\n# t1: int\n# t2: str\n# t3: Person\n# t4: Person\n# t5: sub.Person\n# t6: __main__.Person\n')),(0,l.kt)("p",null,"In addition, we can use the ",(0,l.kt)("inlineCode",{parentName:"p"},"as")," keyword in conjunction with type guards to complete defensive type conversion programming."),(0,l.kt)("p",null,"Only types with partial order can be downcast converted, the use of the as keyword is as follows:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Basic types of partial order relations, e.g., ",(0,l.kt)("inlineCode",{parentName:"li"},"float -> int")),(0,l.kt)("li",{parentName:"ul"},"Partial order relation of union type, e.g., ",(0,l.kt)("inlineCode",{parentName:"li"},"int | str -> str")," and ",(0,l.kt)("inlineCode",{parentName:"li"},"[int | str] -> [str]")),(0,l.kt)("li",{parentName:"ul"},"Contains the partial order relation of the upper bound of the type, e.g., ",(0,l.kt)("inlineCode",{parentName:"li"},"any -> int")),(0,l.kt)("li",{parentName:"ul"},"Partial order relationship of structure type, e.g., ",(0,l.kt)("inlineCode",{parentName:"li"},"base-schema -> sub-schema"))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'schema Data1:\n    id?: int\n\nschema Data2:\n    name?: str\n\ndata: Data1 | Data2 = Data1 {}\n\nif typeof(a) == "Data1":\n    data1 = data as Data1  # The type of `data1` is `Data1`\nelif typeof(a) == "Data2":\n    data2 = data as Data2  # The type of `data2` is `Data2`\n')),(0,l.kt)("p",null,"When a runtime error occurs in the ",(0,l.kt)("inlineCode",{parentName:"p"},"as")," type conversion, a runtime error is thrown."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'a: any = "s"\nb: int = a as int  # Error: The `str` type cannot be converted to the `int` type\n')),(0,l.kt)("p",null,"If we don\u2019t want to throw a runtime error, we can use the type guard for defensive coding with ",(0,l.kt)("inlineCode",{parentName:"p"},"if")," expressions."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'a: any = "s"\nb = a as int if typeof(a) == "int" else None  # The type of b is `int`\n')),(0,l.kt)("p",null,"Note that the ",(0,l.kt)("inlineCode",{parentName:"p"},"as")," conversion of literal type and union type is not supported, because they are not a certain runtime object, only int, float and other objects at runtime, there is no int literal, float literal object, and no union object."),(0,l.kt)("h3",{id:"schema"},"Schema"),(0,l.kt)("h4",{id:"overview"},"Overview"),(0,l.kt)("p",null,"A schema is a language element to define a complex configuration.\nWe can define typed attributes, initialization assignment, and verification rules. In addition, KCL supports schema single inheritance, mixin and protocol to realize the reuse of complex configuration."),(0,l.kt)("h4",{id:"basic"},"Basic"),(0,l.kt)("h5",{id:"attribute"},"Attribute"),(0,l.kt)("p",null,"The followings are some basic examples:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"# A person has a first name, a last name and an age.\nschema Person:\n    firstName: str\n    lastName: str\n    # The default value of age is 0\n    age: int = 0\n")),(0,l.kt)("p",null,"In KCL, we can use type annotations to define some attributes in the schema, each attribute can be set with an optional default value (such as the ",(0,l.kt)("inlineCode",{parentName:"p"},"age")," attribute in the above code, its default value is ",(0,l.kt)("inlineCode",{parentName:"p"},"0"),"), attributes that are not set default values have an initial value of ",(0,l.kt)("inlineCode",{parentName:"p"},"Undefined"),", which are not output in YAML."),(0,l.kt)("p",null,"Note, the immutability of attributes in the schema follows the same rules as the immutability of global variables, only mutable attributes in the schema can be modified in the schema."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'schema Person:\n    age: int = 1  # Immutable attribute\n    _name: str = "Alice"  # Mutable attribute\n\n    age = 10  # Error\n    _name = "Bob"  # Ok\n')),(0,l.kt)("h6",{id:"optional-attribute"},"Optional Attribute"),(0,l.kt)("p",null,"Each attribute ",(0,l.kt)("strong",{parentName:"p"},"must")," be assigned with a not ",(0,l.kt)("inlineCode",{parentName:"p"},"None"),"/",(0,l.kt)("inlineCode",{parentName:"p"},"Undefined")," value as a schema instance unless it is modified by a question mark as an optional attribute."),(0,l.kt)("p",null,"Examples:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"schema Employee:\n    bankCard: int  # bankCard is a required attribute, and it can NOT be None or Undefined\n    nationality?: str  # nationality is an optional attribute, and it can be None or Undefined\n\nemployee = Employee {\n    bankCard = None  # Error, attribute 'bankCard' of Employee is required and can't be None or Undefined\n    nationality = None  # Ok\n}\n")),(0,l.kt)("h5",{id:"irrelevant-order-calculation"},"Irrelevant Order Calculation"),(0,l.kt)("p",null,"The irrelevant order calculation in the schema indicates the reference relationship between the internal attributes of the schema. For example, when we declare an expression of the form ",(0,l.kt)("inlineCode",{parentName:"p"},"a = b + 1"),", the calculation of the value of ",(0,l.kt)("inlineCode",{parentName:"p"},"a")," depends on the calculation of the value of ",(0,l.kt)("inlineCode",{parentName:"p"},"b"),". When the compiler calculate the value of ",(0,l.kt)("inlineCode",{parentName:"p"},"a")," and the value of ",(0,l.kt)("inlineCode",{parentName:"p"},"a")," depends on the value of ",(0,l.kt)("inlineCode",{parentName:"p"},"b"),", the compiler will choose to first calculate the value of ",(0,l.kt)("inlineCode",{parentName:"p"},"b"),", and then calculate the value of a according to the expression ",(0,l.kt)("inlineCode",{parentName:"p"},"a = b + 1"),", which is slightly different from the calculation method of traditional procedural language the difference."),(0,l.kt)("p",null,"Since the calculation of values in the schema is based on dependencies, just like a directed acyclic graph traverses each node in the graph according to the order of topological sorting, the order of declaration of attributes in the schema is not so important, so the feature is called the irrelevant order calculation."),(0,l.kt)("p",null,"Please note that there can be no circular references between different schema attribute values."),(0,l.kt)("p",null,"We can see this feature through the following examples."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"schema Fib:\n    n1: int = n - 1  # Refers to the attribute `n` declared after `n1`\n    n2: int = n1 - 1\n    n: int\n    value: int = 1 if n <= 2 else Fib {n = n1}.value + Fib {n = n2}.value\n\nfib8 = Fib {n = 8}.value\n")),(0,l.kt)("p",null,"The output is"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},"fib8: 21\n")),(0,l.kt)("p",null,"We can see that in the schema, we only need to simply specify the dependency between attributes, and the compiler will automatically calculate the value based on the dependency, which can help us save a lot of boilerplate code and reduce configuration difficulty of writing."),(0,l.kt)("h5",{id:"schema-context"},"Schema Context"),(0,l.kt)("p",null,"We can define the context of the schema to manage the attributes of the schema, and we can write schema parameters, temporary variables and expressions directly in the schema:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"schema Person[_name: str]:  # define a schema argument\n    name: str = _name     # define a schema attribute\n    age: int = 10         # define a schema attribute with default value\n    hands: [int] = [i for i in [1, 2, 3]] # define a for statement\n")),(0,l.kt)("h5",{id:"validation"},"Validation"),(0,l.kt)("p",null,"In addition to using ",(0,l.kt)("strong",{parentName:"p"},"static typing")," (the type annotation) and ",(0,l.kt)("strong",{parentName:"p"},"immutability")," in KCL schema mentioned earlier to ensure code stability, a bunch of validation rules are supported in a simple ",(0,l.kt)("strong",{parentName:"p"},"check")," block (KCL supports almost all authentication capabilities of ",(0,l.kt)("a",{parentName:"p",href:"https://www.openapis.org/"},"OpenAPI"),"):"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'import regex\n\nschema Sample:\n    foo: str\n    bar: int\n    fooList: [str]\n\n    check:\n        bar > 0  # minimum, also support the exclusive case\n        bar < 100  # maximum, also support the exclusive case\n        len(fooList) > 0  # min length, also support exclusive case\n        len(fooList) < 100  # max length, also support exclusive case\n        regex.match(foo, "^The.*Foo$")  # regex match\n        isunique(fooList)  # unique\n        bar in range(100)  # range\n        bar in [2, 4, 6, 8]  # enum\n        multiplyof(bar, 2)  # multipleOf\n')),(0,l.kt)("p",null,"With the schema, all instances will be validated at compile time"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'# Ok\ngoodSample = Sample {\n    foo = "The Foo"\n    bar = 2\n    fooList = ["foo0", "foo1"]\n}\n\n# Error: validation failure: Check failed on check conditions: bar < 100.\nbadSample = Sample {\n    foo = "The Foo"\n    bar = 123\n    fooList = ["foo0", "foo1"]\n}\n')),(0,l.kt)("p",null,"In addition, we can use ",(0,l.kt)("strong",{parentName:"p"},"and"),", ",(0,l.kt)("strong",{parentName:"p"},"or"),", ",(0,l.kt)("strong",{parentName:"p"},"if")," to compose more complex conditional check logic:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'schema Sample:\n    bar: int\n    foo: str\n    doCheck: bool\n\n    check:\n        regex.match(foo, "^The.*Foo$") and bar in [2, 4, 6, 8] if doCheck\n')),(0,l.kt)("p",null,"In order to ensure that all check rules can play their corresponding roles well, we can test the rationality and correctness of different data combinations by writing KCL test cases, and run all test cases through the kcl test tool."),(0,l.kt)("h5",{id:"documents"},"Documents"),(0,l.kt)("p",null,"Usually after we write the schema model, we will write documentation comments for the schema, which can be completed by using a three-quoted string as follows:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'schema Server:\n    """Server is the common user interface for long-running\n    services adopting the best practice of Kubernetes.\n\n    Attributes\n    ----------\n    workloadType : str, default is Deployment\n        Use this attribute to specify which kind of long-running service you want.\n        Valid values: Deployment, CafeDeployment.\n        See also: k8s/core/v1/workload_metadata.k.\n    name : str, default is None\n        A Server-level attribute.\n        The name of the long-running service.\n        See also: k8s/core/v1/metadata.k.\n    labels : {str:str}, optional, default is None\n        A Server-level attribute.\n        The labels of the long-running service.\n        See also: k8s/core/v1/metadata.k.\n\n    Examples\n    ----------------------\n    myCustomApp = AppConfiguration {\n        name = "componentName"\n    }\n    """\n    workloadType: str = "Deployment"\n    name: str\n    labels?: {str:str}\n')),(0,l.kt)("h5",{id:"config"},"Config"),(0,l.kt)("p",null,"Suppose we have the following schema definition:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"schema Person:\n    firstName: str\n    lastName: str\n")),(0,l.kt)("p",null,"A config could be defined with a JSON-like expression:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'person = Person {\n    firstName = "firstName"\n    lastName = "lastName"\n}\n')),(0,l.kt)("p",null,"At the same time, the schema adheres to strict attribute definitions,\nand configuring undefined attributes will trigger a compilation error."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"person = Person {\n    firstName = \"firstName\"\n    lastName = \"lastName\"\n    fullName = \"fullName\"  # Error: Cannot add member 'fullName' to schema 'Person', 'fullName' is not defined in schema 'Person'\n}\n")),(0,l.kt)("p",null,"We can use ",(0,l.kt)("inlineCode",{parentName:"p"},"if expressions")," to dynamically add elements to the schema config, elements that meet the conditions are added to the schema config, and elements that do not meet the conditions are ignored. Besides, the ",(0,l.kt)("strong",{parentName:"p"},"config selector expressions")," can be used to init a schema instance."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'schema Base:\n    count: int\n    value: str\n\nschema Person:\n    base: Base\n    labels: {str:str}\n    name?: str\n\nenv = "prod"\n\nperson1 = Person {\n    base.count = 2  # Config selector expression\n    base.value = "value"  # A schema variable in schema can use selector expressions\n    labels.key = "value"  # A dict variable in schema can use selector expressions\n}\n\nperson2 = Person {\n    base = {\n        count = 1\n        value = "value"\n    }\n    labels.key = "value"\n    if env == "prod":\n        labels.env = env\n    else:\n        labels.env = "other"\n}\n')),(0,l.kt)("p",null,"The output YAML is"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},"person1:\n  base:\n    count: 2\n    value: value\n  labels:\n    key: value\nperson2:\n  base:\n    count: 1\n    value: value\n  labels:\n    key: value\n    env: prod\n")),(0,l.kt)("p",null,"When we instantiate a schema without config parameters, we can generate schema instances in the following three forms:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"schema Data:\n    id: int = 1\n\ndata1 = Data {}\ndata2 = Data() {}\ndata3 = Data()\n")),(0,l.kt)("p",null,"In addition to using a schema type to instantiate a schema, we can also use a schema instance to get a new instance using the config expression."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"schema Config:\n    id: int\n    values: [int]\n\nconfigOrigin = Config {\n    id = 1\n    values = [0, 1]\n}\nconfigNew = configOrigin {\n    id = 2\n    values += [2, 3]\n}\n")),(0,l.kt)("p",null,"The output is"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},"configOrigin:\n  id: 1\n  values:\n  - 0\n  - 1\nconfigNew:\n  id: 2\n  values:\n  - 0\n  - 1\n  - 2\n  - 3\n")),(0,l.kt)("p",null,"In addition, schema attribute default values can be modified by schema config."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'schema Person:\n    age: int = 1\n    name: str = "Alice"\n\n    age = 2  # Error, can\'t change the default value of the attribute `age` in the schema context\n\nperson = Person {\n    age = 3  # Ok, can change the default value of the attribute `age` in the schema config\n}\n')),(0,l.kt)("h4",{id:"advanced"},"Advanced"),(0,l.kt)("h5",{id:"protocol--mixin"},"Protocol & Mixin"),(0,l.kt)("p",null,"In addition to schema, an additional type definition method ",(0,l.kt)("inlineCode",{parentName:"p"},"protocol")," is provided in KCL, and its properties are as follows:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"In a protocol, only attributes and their types can be defined, complex logic and check expressions cannot be written, and mixins cannot be used."),(0,l.kt)("li",{parentName:"ul"},"A protocol can only constrain properties that do not start with ",(0,l.kt)("inlineCode",{parentName:"li"},"_"),"."),(0,l.kt)("li",{parentName:"ul"},"A protocol can only inherit or refer to other protocols, but cannot inherit or refer to other schemas.")),(0,l.kt)("p",null,"Besides, we can declare a complex assembly schema with optional ",(0,l.kt)("strong",{parentName:"p"},"mixin")," support and use ",(0,l.kt)("strong",{parentName:"p"},"protocol")," to add an optional host type to the dynamically inserted ",(0,l.kt)("strong",{parentName:"p"},"mixin"),".:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"schema Person:\n    mixin [FullNameMixin]\n\n    firstName: str  # Required\n    lastName: str  # Required\n    fullName?: str  # Optional\n")),(0,l.kt)("p",null,"A fullName mixin which generates a fullName as a simple sample:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'protocol PersonProtocol:\n    firstName: str\n    lastName: str\n    fullName?: str\n\nmixin FullNameMixin for PersonProtocol:\n    fullName = "{} {}".format(firstName, lastName)\n')),(0,l.kt)("p",null,"Then we can get the schema instance by:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'person = Person {\n    firstName = "John"\n    lastName = "Doe"\n}\n')),(0,l.kt)("p",null,"The output is"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},"person:\n  firstName: John\n  lastName: Doe\n  fullName: John Doe\n")),(0,l.kt)("p",null,"Please note that the host type ",(0,l.kt)("strong",{parentName:"p"},"protocol")," can only be used for ",(0,l.kt)("strong",{parentName:"p"},"mixin")," definitions (the suffix name is ",(0,l.kt)("inlineCode",{parentName:"p"},"Mixin"),"), otherwise an error will be reported."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"protocol DataProtocol:\n    data: str\n\nschema Data for DataProtocol:  # Error: only schema mixin can inherit from protocol\n    x: str = data\n")),(0,l.kt)("h5",{id:"index-signature"},"Index Signature"),(0,l.kt)("p",null,"Index signatures can be defined in the KCL schema, and it means that the key-value constraints of the index signature can be used to construct a dict with the schema type, or additional checks can be added to the schema attributes to enhance the KCL type and semantic checks."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Use the form ",(0,l.kt)("inlineCode",{parentName:"li"},"[{attr_alias}: {key_type}]: {value_type}")," to define an index signature in the schema, and ",(0,l.kt)("inlineCode",{parentName:"li"},"{attr_alias}")," can be omitted.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'schema Map:\n    """\n    Map is a schema with a key of str type and a value of str type\n    """\n    [str]: str  # `{attr_alias}` can be omitted.\n\ndata = Map {\n    key1 = "value1"\n    key2 = "value2"\n}\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Mandatory all attributes of the schema key and value types")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"schema Person:\n    name: str\n    age: int  # error, conflicts with the index signature definition `[str]: str`\n    [str]: str  # The values of all attributes of the schema can only be strings\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Mandatory all attribute key and value types are defined in the schema, which is equivalent to restricting all attribute types except the additional attributes.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"schema Person:\n    name: str\n    age: int\n    [...str]: str  # Except for the `name` and `age` attributes, the key type of all other attributes of the schema must be `str`, and the value type must also be `str`.\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Define the index signature attribute alias and use it with the check block.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'schema Data:\n    [dataName: str]: str\n    check:\n        dataName in ["Alice", "Bob", "John"]\n\ndata = Data {\n    Alice = "10"\n    Bob = "12"\n    Jonn = "8"  # Error: Jonn not in ["Alice", "Bob", "John"]\n}\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'import regex\n\nschema DataMap:\n    [attr: str]: str\n    check:\n        regex.match(attr, r\'^[-._a-zA-Z0-9]+$\')\n\ndata = DataMap {\n    key1 = "value1"\n    "foo.bar" = "value2"  # check error\n}\n')),(0,l.kt)("h5",{id:"inheritance"},"Inheritance"),(0,l.kt)("p",null,"Like some other object-oriented languages, KCL provides fundamental but limited object-oriented support, such as ",(0,l.kt)("strong",{parentName:"p"},"attribute reuse"),", ",(0,l.kt)("strong",{parentName:"p"},"private and public variables"),", and ",(0,l.kt)("strong",{parentName:"p"},"single inheritance"),". Besides, KCL does NOT support multiple inheritances for the schema."),(0,l.kt)("p",null,"The following is an example of schema inheritance:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'# A person has a first name, a last name and an age.\nschema Person:\n    firstName: str\n    lastName: str\n    # The default value of age is 0\n    age: int = 0\n\n# An employee **is** a person, and has some additional information.\nschema Employee(Person):\n    bankCard: int\n    nationality?: str\n\nemployee = Employee {\n    firstName = "Bob"\n    lastName = "Green"\n    age = 18\n    bankCard = 123456\n}\n')),(0,l.kt)("p",null,"The output is"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},"employee:\n  firstName: Bob\n  lastName: Green\n  age: 18\n  bankCard: 123456\n  nationality: null\n")),(0,l.kt)("p",null,"Please note that KCL only allows ",(0,l.kt)("strong",{parentName:"p"},"single inheritance")," on schemas."),(0,l.kt)("p",null,"In addition, when the schema has an inheritance relationship, the properties of optional attributes are as follows:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"If the attribute is optional in the base schema, it could be optional or required in the sub-schema."),(0,l.kt)("li",{parentName:"ul"},"If the attribute is required in the base schema, it must be required in the sub-schema.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"schema Person:\n    bankCard?: int\n    nationality: str\n\nschema Employee(Person):\n    bankCard: int  # Valid, both `bankCard: int` and `bankCard?: int` are allowed\n    nationality?: str  # Error, only `nationality: str` is allowed\n")),(0,l.kt)("h5",{id:"schema-function"},"Schema Function"),(0,l.kt)("p",null,"Schema map very nicely onto functions; it can have any number of input and output parameters. For example, the Fibonacci function can be written as follows using the recursive schema config:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"schema Fib[n: int]:\n    n1 = n - 1\n    n2 = n - 2\n    if n == 0:\n        value = 0\n    elif n == 1:\n        value = 1\n    else:\n        value = Fib(n1).value + Fib(n2).value\n    \nfib8 = Fib(8).value  # 21\n")),(0,l.kt)("h5",{id:"decorators"},"Decorators"),(0,l.kt)("p",null,"Just like Python, KCL supports the use of decorators on the schema. KCL Decorators dynamically alter the functionality of a schema without having to directly use sub schema or change the source code of the schema being decorated. And like a function call, the decorator supports passing in additional parameters."),(0,l.kt)("p",null,"Built-in decorators of schema"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"@deprecated"),"\nMark whether a schema or schema attribute is deprecated. The ",(0,l.kt)("inlineCode",{parentName:"li"},"@deprecated")," decorator supports three parameters:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"version")," - string type, indicating the version information. The default value is empty."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"reason")," - string type, indicating the deprecated reason. The default value is empty."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"strict")," - bool type, indicating whether to report an error or warning. The default value is true. If ",(0,l.kt)("inlineCode",{parentName:"li"},"strict")," is ",(0,l.kt)("inlineCode",{parentName:"li"},"True")," and the error is thrown, the program will be interrupted. If ",(0,l.kt)("inlineCode",{parentName:"li"},"strict")," is ",(0,l.kt)("inlineCode",{parentName:"li"},"False"),", a warning will be output and the program will not be interrupted.")))),(0,l.kt)("p",null,"Examples:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'@deprecated\nschema ObsoleteSchema:\n    attr: str\n\nschema Person:\n    name: str = "John"\n    attrs: ObsoleteSchema = {\n        attr = "value"\n    }\n\nperson = Person {}  # Error: ObsoleteSchema was deprecated\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'schema Person:\n    firstName: str = "John"\n    lastName: str\n    @deprecated(version="1.16", reason="use firstName and lastName instead", strict=True)\n    name: str\n\nJohnDoe = Person {  # Error: name was deprecated since version 1.16, use firstName and lastName instead\n    name = "deprecated"\n}\n')),(0,l.kt)("p",null,"Note that the current version of KCL does not yet support user-defined decorators."),(0,l.kt)("h5",{id:"members"},"Members"),(0,l.kt)("p",null,"Built-in functions and members of schema"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"instances()\nReturn the list of existing instances of a schema.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'schema Person:\n    name: str\n    age: int\n\nalice = Person {\n    name = "Alice"\n    age = 18\n}\n\nbob = Person {\n    name = "Bob"\n    age = 10\n}\n\naliceAndBob = Person.instances()  # Person is a schema type, instances() is its member method\n')),(0,l.kt)("p",null,"The output is"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},"alice:\n  name: Alice\n  age: 18\nbob:\n  name: Bob\n  age: 10\naliceAndBob:\n- name: Alice\n  age: 18\n- name: Bob\n  age: 10\n")),(0,l.kt)("h3",{id:"config-operations"},"Config Operations"),(0,l.kt)("h4",{id:"config-unification"},"Config Unification"),(0,l.kt)("h5",{id:"-operators"},"| Operators"),(0,l.kt)("p",null,"In KCL, we can use the union operator ",(0,l.kt)("inlineCode",{parentName:"p"},"|")," to achieve the merging of configurations, the types supported by the union operator are as follows:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-txt"},"SchemaInstance | SchemaInstance\nSchemaInstance | Dict\nDict | Dict\nList | List\n")),(0,l.kt)("p",null,"Unioning collection and schema data:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Unioning List. Overwrite the list expression on the right side of the operator ",(0,l.kt)("inlineCode",{parentName:"li"},"|")," to the list variable on the left side of the operator one by one according to the ",(0,l.kt)("strong",{parentName:"li"},"index"),".")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"_a = [1, 2, 3]\n_b = [4, 5, 6, 7]\nx = _a | _b  # [4, 5, 6, 7]  1 -> 4; 2 -> 5; 3 -> 6; Undefined -> 7\n")),(0,l.kt)("p",null,"Unioning to the specific index or all elements is still under discussion."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Unioning Dict. Union the dict expression on the right side of the operator ",(0,l.kt)("inlineCode",{parentName:"li"},"|")," one by one to the dict variable on the left side of the operator according to the ",(0,l.kt)("strong",{parentName:"li"},"key"))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'_a = {key1 = "value1"}\n_b = {key1 = "overwrite", key2 = "value2"}\nx = _a | _b  # {"key1": "overwrite", "key2": "value2"}\n')),(0,l.kt)("p",null,"The union of collection and schema is a new one whose attributes are unioning b to a, preserving the order of the attributes of the operands, left before right."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Unioning Schema. The union operation for schema is similar to dict.")),(0,l.kt)("p",null,"Schema union could be done as:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'schema Person:\n    firstName?: str\n    lastName?: str\n\n_a = Person {\n    firstName = "John"\n}\n_b = {lastName = "Doe"}\n_c = _a | _b  # {"firstName": "John", "lastName": "Doe"}\n_d = _a | None  #  {"firstName": "John"}\n_e = _a | Undefined  #  {"firstName": "John"}\n_f = None | _a  #  {"firstName": "John"}\n_g = Undefined | _a  #  {"firstName": "John"}\n')),(0,l.kt)("p",null,"Please note that when one of the left and right operands of the union operator is None, the other operand is returned immediately."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'data1 = {key = "value"} | None  # {"key": "value"}\ndata2 = None | [1, 2, 3]  # [1, 2, 3]\ndata3 = None | None  # None\n')),(0,l.kt)("p",null,"The output is"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},"data1:\n  key: value\ndata2:\n- 1\n- 2\n- 3\ndata3: null\n")),(0,l.kt)("h5",{id:"-operators-1"},": Operators"),(0,l.kt)("p",null,"Pattern: ",(0,l.kt)("inlineCode",{parentName:"p"},"identifier : E")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"identifier : T E")),(0,l.kt)("p",null,"The value of the expression ",(0,l.kt)("inlineCode",{parentName:"p"},"E")," with optional type annotation ",(0,l.kt)("inlineCode",{parentName:"p"},"T")," will be unioned into the element value."),(0,l.kt)("p",null,"Examples:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'data = {\n    labels: {key1: "value1"}\n    # union {key2: "value2"} into the attribute labels.\n    labels: {key2: "value2"}\n}\n')),(0,l.kt)("p",null,"Output:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},"data:\n  labels:\n    key1: value1\n    key2: value2\n")),(0,l.kt)("p",null,"In addition to using attribute operators on the schema config attributes, variables inside and outside the schema can use attribute operators to perform different operations on the configuration."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Using ",(0,l.kt)("inlineCode",{parentName:"li"},":")," outside the schema")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"schema Data:\n    d1?: int\n    d2?: int\n\nschema Config:\n    data: Data\n\n# This is one configuration that will be merged.\nconfig: Config {\n    data.d1 = 1\n}\n# This is another configuration that will be merged.\nconfig: Config {\n    data.d2 = 2\n}\n")),(0,l.kt)("p",null,"Its equivalent configuration code can be expressed as"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"schema Data:\n    d1?: int\n    d2?: int\n\nschema Config:\n    data: Data\n\nconfig: Config {\n    data.d1 = 1\n    data.d2 = 1\n}\n")),(0,l.kt)("p",null,"The output is"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},"config:\n  data:\n    d1: 1\n    d2: 1\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Using ",(0,l.kt)("inlineCode",{parentName:"li"},":")," inside the schema")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"schema Data:\n    d1?: int\n    d2?: int\n    \nschema Config:\n    # This is one configuration that will be merged.\n    data: Data {\n        d1 = 1\n    }\n    # This is another configuration that will be merged.\n    data: Data {\n        d2 = 1\n    }\n\nconfig: Config {}\n")),(0,l.kt)("h4",{id:"config-override"},"Config Override"),(0,l.kt)("h5",{id:"-operators-2"},"= Operators"),(0,l.kt)("p",null,"Pattern: ",(0,l.kt)("inlineCode",{parentName:"p"},"identifier = E")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"identifier : T = E")),(0,l.kt)("p",null,"The value of the expression ",(0,l.kt)("inlineCode",{parentName:"p"},"E")," with optional type annotation ",(0,l.kt)("inlineCode",{parentName:"p"},"T")," will override the attribute value."),(0,l.kt)("p",null,"Examples:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'schema Data:\n    labels: {str:} = {key1 = "value1"}\n\ndata = Data {\n    # override {key2: "value2"} into the attribute labels of the schema Data.\n    labels = {key2 = "value2"}\n}\n')),(0,l.kt)("p",null,"Output:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},"data:\n  labels:\n    key2: value2\n")),(0,l.kt)("p",null,"Note:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},'Especially, we can "delete" its content by overriding the attribute to ',(0,l.kt)("inlineCode",{parentName:"li"},"Undefined"),", such as ",(0,l.kt)("inlineCode",{parentName:"li"},"{ a = Undefined }"),".")),(0,l.kt)("h4",{id:"insert"},"Insert"),(0,l.kt)("h5",{id:"-operators-3"},"+= Operators"),(0,l.kt)("p",null,"Pattern: ",(0,l.kt)("inlineCode",{parentName:"p"},"identifier += E")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"identifier : T += E")),(0,l.kt)("p",null,"Insert only works for list type ",(0,l.kt)("inlineCode",{parentName:"p"},"identifier"),"."),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"E")," will be inserted just after the specified index of the list ",(0,l.kt)("inlineCode",{parentName:"p"},"identifier"),", and the following attributes after the index will be automatically shifted."),(0,l.kt)("p",null,"Examples:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"schema Data:\n    labels: {str:} = {key1 = [0]}\n\ndata = Data {\n    # insert [1] into the attribute labels.key1 of the schema Data.\n    labels: {key1 += [1]}\n}\n")),(0,l.kt)("p",null,"Output:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},"data:\n  labels:\n    key1:\n    - 0\n    - 1\n")),(0,l.kt)("p",null,"If no index is specified, the last index will be used."),(0,l.kt)("h4",{id:"notice"},"Notice"),(0,l.kt)("p",null,"Please note that the calculations of the ",(0,l.kt)("inlineCode",{parentName:"p"},"=")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"+=")," attribute operators of the same attribute are sequential, and the latter ones have a higher priority."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"x = {\n    a = 1  # 1\n} | {\n    a = 2  # 1 -> 2\n} | {\n    a = 3  # 2 -> 3\n}  # The final value of attribute `a` is 3\n")),(0,l.kt)("p",null,"Please note that the ",(0,l.kt)("inlineCode",{parentName:"p"},":")," attribute operator represents an idempotent merge operation, and an error will be thrown when the values that need to be merged conflict."),(0,l.kt)("p",null,"Therefore, when we need a configuration to override or add and delete operations, it is best to use the ",(0,l.kt)("inlineCode",{parentName:"p"},"=")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"+=")," operators"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"data0 = {id: 1} | {id: 2}  # Error\uff1aconflicting values between {'id': 2} and {'id': 1}\ndata1 = {id: 1} | {id = 2}  # Ok, the value of `data` is {\"id\": 2}\n")),(0,l.kt)("p",null,"The check rules for ",(0,l.kt)("inlineCode",{parentName:"p"},":")," operator for KCL value conflicts are as follows:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"For ",(0,l.kt)("inlineCode",{parentName:"li"},"None")," and ",(0,l.kt)("inlineCode",{parentName:"li"},"Undefined")," variables, they do not conflict with any value.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"data0 = None | {id: 1}  # Ok\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"For ",(0,l.kt)("inlineCode",{parentName:"li"},"int"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"float"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"str")," and ",(0,l.kt)("inlineCode",{parentName:"li"},"bool")," types, when their values are different, they are considered as conflicts.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'data0 = 1 | 1  # Ok\ndata1 = 1 | "s"  # Error\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"For list type",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"When their lengths are not equal, they are regarded as conflicts."),(0,l.kt)("li",{parentName:"ul"},"When their lengths are equal, as long as there is a conflict in the value of a child element, it is regarded as a conflict.")))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"data0 = [1] | [1]  # Ok\ndata1 = [1, 2] | [1]  # Error\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"For dict/schema type",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"When the values of the same key conflict, they are regarded as conflicts")))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"data0 = {id: 1} | {id: 1}  # Ok\ndata1 = {id: 1} | {id: 2}  # Error\ndata1 = {id: 1} | {idAnother: 1}  # Ok\n")),(0,l.kt)("h3",{id:"rule"},"Rule"),(0,l.kt)("p",null,"In addition to using the check keyword for verification and writing in the schema, KCL also supports the use of the ",(0,l.kt)("inlineCode",{parentName:"p"},"rule")," keyword to define a set of rules for policy verification"),(0,l.kt)("p",null,"The KCL rule is the same as the schema/mixin/protocol and it is defined by indentation. We need write a rule per line and we can write if filter conditions and verification failure information for each rule. Different conditions are connected with logic ",(0,l.kt)("inlineCode",{parentName:"p"},"and")," (similar to the way of writing in check block)."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'rule SomeRule:\n    age > 0, "rule check failure message"\n')),(0,l.kt)("p",null,"We can call a KCL rule like instantiating a schema:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'age = 1\nname = "Alice"\n\nrule SomeRule:\n    age > 0, "rule check failure message"\n    name == "Alice"\n\nrule1 = SomeRule()  # Rule call \nrule2 = SomeRule {}  # Rule call\n')),(0,l.kt)("p",null,"We can use protocol to implement type checking of rule structure:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'# Schema definition\nprotocol Service:\n    clusterIp: str\n    $type: str\n\n# Schema definition\nprotocol Volume:\n    mountPath: [str]\n\n# Protocol\nprotocol SomeProtocol:\n    id: int\n    env: {str: any}\n    services: [Service]\n    volumes: [Volume]\n\nrule SomeChecker for SomeProtocol:\n    id > 0, "id must >0"\n\n    all service in services {\n        service.clusterIP == "NONE" if service.type == "ClusterIP"\n    }\n\n    any volume in volumes {\n        volume.mountPath in ["/home/admin", "/home/myapp"]\n    }\n\n# Call rule to check with config parameter\nSomeChecker {\n    id = 1\n    env = {\n        MY_ENV = "MY_ENV_VALUE"\n    }\n    services = [\n        {\n            type = "ClusterIP"\n            clusterIP = "NONE"\n        }\n    ]\n    volumes = [\n        {\n            mountPath = "/home/admin"\n        }\n        {\n            mountPath = "/home/myapp"\n        }\n    ]\n}\n')),(0,l.kt)("p",null,"Please note that the combination of ",(0,l.kt)("inlineCode",{parentName:"p"},"protocol")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"rule")," can separate attributes from their constraint definitions. We can define different rules and protocols in different packages and combine them as needed. This is different from check expressions in schema, which can only be combined with schema attributes."),(0,l.kt)("p",null,"Besides, the following two ways can be used to achieve the multiplexing of different Rules:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Inline Call")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'weather = "sunny"\nday = "wednesday"\n\nrule IsSunny:\n    weather == "sunny"\n\nrule IsWednesday:\n    day == "wednesday"\n\nrule Main:\n    IsSunny()  # Rule inline call\n    IsWednesday()  # Rule inline call\n\nMain()  # Rule call\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Inherit")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'weather = "sunny"\nday = "wednesday"\n\nrule IsSunny:\n    weather == "sunny"\n\nrule IsWednesday:\n    day == "wednesday"\n\nrule Main(IsSunny, IsWednesday):\n    id == 1\n\nMain()\n')),(0,l.kt)("p",null,"We can obtain external data or input from the ",(0,l.kt)("inlineCode",{parentName:"p"},"option")," function and the CLI parameter ",(0,l.kt)("inlineCode",{parentName:"p"},"-D")," for verification:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"A simple example")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'schema Day:\n    day: str\n    homework: str\n\ndays: [Day] = option("days")\n\nrule Main:\n    filter d in days {\n        d.day not in ["saturday", "sunday"] and d.homework\n    }\n\nMain()\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"A complex example")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'data = option("data")\ninput = option("input")\n\nrule Allow:\n    UserIsAdmin()\n    any grant in UserIsGranted() {\n        input.action == grant.action and input.type == grant.type\n    }\n\nrule UserIsAdmin:\n    any user in data.user_roles[input.user] {\n        user == "admin"\n    }\n\nrule UserIsGranted:\n    [\n        grant\n        for role in data.user_roles[input.user]\n        for grant in data.role_grants[role]\n    ]\n\nallow = Allow() or False\n')),(0,l.kt)("p",null,"Further, the above KCL rule code can be compiled into a target such as WASM and used at runtime."),(0,l.kt)("h3",{id:"module"},"Module"),(0,l.kt)("p",null,"KCL config files are organized as ",(0,l.kt)("strong",{parentName:"p"},"modules"),". A single KCL file is considered as a module, and a directory is considered as a package, which is a special module."),(0,l.kt)("p",null,"The modules in the same package are visible and cross-package references need to be visible through import."),(0,l.kt)("p",null,"Code structure:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},". \n\u2514\u2500\u2500 root\n    \u251c\u2500\u2500 model\n    \u2502   \u251c\u2500\u2500 model1.k\n    |   \u251c\u2500\u2500 model2.k\n    \u2502   \u2514\u2500\u2500 main.k\n    \u251c\u2500\u2500 service\n    \u2502   \u2514\u2500\u2500 service1.k\n    \u2514\u2500\u2500 mixin\n        \u2514\u2500\u2500 mixin1.k\n")),(0,l.kt)("p",null,"model1.k:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"# schema CatalogItem in model1.k\n\nschema CatalogItem:\n    id: int\n    image: CatalogItemImage  # CatalogItemImage is defined in the module of the same package e.g., model2.k in package model\n    title: str\n")),(0,l.kt)("p",null,"service1.k:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"import ..model as model  # cross-package references\n\nschema ImageService:\n    image: model.CatalogItemImage  # CatalogItemImage is imported from another package e.g., model2.k in package model\n    name: str\n")),(0,l.kt)("h4",{id:"relative-path-import"},"Relative Path Import"),(0,l.kt)("p",null,"We can use the operator ",(0,l.kt)("inlineCode",{parentName:"p"},".")," to realize the relative path import of KCL entry files."),(0,l.kt)("p",null,"main.k:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"import .model1  # Current directory module\nimport ..service  # Parent directory\nimport ...root  # Parent of parent directory\n\ns = service.ImageService {}\nm = root.Schema {}\n")),(0,l.kt)("h4",{id:"absolute-path-import"},"Absolute Path Import"),(0,l.kt)("p",null,"The semantics of ",(0,l.kt)("inlineCode",{parentName:"p"},"import a.b.c.d")," is"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"If ",(0,l.kt)("inlineCode",{parentName:"li"},"kcl.mod")," not exist, regard the current directory as the package root and search the path ",(0,l.kt)("inlineCode",{parentName:"li"},"a/b/c/d")," from the current directory."),(0,l.kt)("li",{parentName:"ol"},"If the current directory search fails, search from the root path ",(0,l.kt)("inlineCode",{parentName:"li"},"ROOT_PATH/a/b/c/d"),", else raise an import error.")),(0,l.kt)("p",null,"The definition of the root path ",(0,l.kt)("inlineCode",{parentName:"p"},"ROOT_PATH")," is the directory corresponding to the ",(0,l.kt)("inlineCode",{parentName:"p"},"kcl.mod")," file from the current directory."),(0,l.kt)("p",null,"Code structure:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},". \n\u2514\u2500\u2500 root\n    \u251c\u2500\u2500 kcl.mod\n    \u251c\u2500\u2500 model\n    \u2502   \u251c\u2500\u2500 model1.k\n    |   \u251c\u2500\u2500 model2.k\n    \u2502   \u2514\u2500\u2500 main.k\n    \u251c\u2500\u2500 service\n    \u2502   \u2514\u2500\u2500 service1.k\n    \u2514\u2500\u2500 mixin\n        \u2514\u2500\u2500 mixin1.k\n")),(0,l.kt)("p",null,"main.k:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"import service  # `root package` and `kcl.mod` are in the same directory\nimport mixin  # `root package` and `kcl.mod` are in the same directory\n\nmyModel = model.CatalogItem {}\n")),(0,l.kt)("p",null,"Note that for the KCL entry file ",(0,l.kt)("inlineCode",{parentName:"p"},"main.k"),", it cannot be imported into the folder where it is located, otherwise a recursive import error will occur:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"import model  # Error: recursively loading\n")),(0,l.kt)("h3",{id:"top-level-argument"},"Top-Level Argument"),(0,l.kt)("p",null,"Assume some field need to be passed in dynamically like user input, we can define a top-level argument in a module:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'bankCard = option("bankCard")  # Get bankCard through the option function.\n')),(0,l.kt)("p",null,"Then we can use the module as below:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"kcl employee.k -D bankCard=123\n")),(0,l.kt)("p",null,"Currently, supported types of top-level argument are number, string, bool, list and dict."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"kcl main.k -D list_key='[1,2,3]' -D dict_key='{\"key\":\"value\"}' \n")),(0,l.kt)("p",null,"We need to pay attention to the escape of quotation marks ",(0,l.kt)("inlineCode",{parentName:"p"},'"')," and other symbols in the command line"),(0,l.kt)("h4",{id:"arguments-with-setting-files"},"Arguments with Setting Files"),(0,l.kt)("p",null,"In addition, it also supports inputting a YAML file as top-level arguments."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},"kcl_options:\n  - key: key_number\n    value: 1\n  - key: key_dict\n    value:\n      innerDictKey:  innerDictValue\n  - key: key_list\n    value:\n      - 1\n      - 2\n      - 3\n  - key: bankCard\n    value: 123\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"kcl -Y setting.yaml employee.k\n")),(0,l.kt)("p",null,"In addition, the setting file also supports configuring command-line compilation parameters as follows:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},"kcl_cli_configs:\n  files:\n    - file1.k\n    - file2.k\n  disable_none: true\n  strict_range_check: true\n  debug: 1\n  verbose: 1\n  sort_keys: true\n  output: ./stdout.golden\n  overrides:\n    - app.image=new_image\n  path_selector:\n    - config\n  package_maps:\n    k8s: /Users/.kcl/kpm/k8s_1.24\nkcl_options:\n  - key: image\n    value: docker.io/kcllang/kcl:latest\n")),(0,l.kt)("p",null,"KCL CLI -Y parameters also support multi-file configuration, and support separate writing and merging of compilation parameters and option top level arguments parameter configuration."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"kcl -Y compile_setting.yaml option_setting.yaml\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"compile_setting.yaml"))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},"kcl_cli_configs:\n  files:\n    - file1.k\n    - file2.k\n  disable_none: true\n  strict_range_check: true\n  debug: 1\n  verbose: 1\n  output: ./stdout.golden\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"option_setting.yaml"))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},"kcl_options:\n  - key: image\n    value: docker.io/kcllang/kcl:latest\n")),(0,l.kt)("p",null,"We can use the following command line to get the meaning of each configuration parameter or see KCL Quick Start"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"kcl --help\n")),(0,l.kt)("h4",{id:"option-functions"},"Option Functions"),(0,l.kt)("p",null,"We can use the ",(0,l.kt)("inlineCode",{parentName:"p"},"option")," function in the KCL code to get the top-level arguments."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'value = option(key="key", type=\'str\', default="default_value", required=True, help="Set key value")\n')),(0,l.kt)("p",null,"Parameters"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"key"),": The argument key."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"type"),": The argument type to be converted."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"default"),": The argument default value when the key-value argument is not provided"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"required"),": Report an error when the key-value argument is not provided and required is True."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"help"),": The help message.")),(0,l.kt)("h3",{id:"multi-file-compilation"},"Multi-file Compilation"),(0,l.kt)("p",null,"In addition to the above KCL single file execution, we can compile multiple KCL entry files at the same time using the following command:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"kcl main_1.k main_2.k ... main_n.k\n")),(0,l.kt)("p",null,"main_1.k"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"a = 1\nb = 2\n")),(0,l.kt)("p",null,"main_2.k"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"c = 3\nd = 4\n")),(0,l.kt)("p",null,"The output is:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},"a: 1\nb: 2\nc: 3\nd: 4\n")),(0,l.kt)("p",null,"Taking advantage of the ",(0,l.kt)("strong",{parentName:"p"},"multi-file combination"),", we can assemble multiple KCL files without the need to use import management files. Let us see an example of combining ",(0,l.kt)("strong",{parentName:"p"},"multi-file compilation")," and ",(0,l.kt)("strong",{parentName:"p"},"schema instance"),"."),(0,l.kt)("p",null,"model.k"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'schema Model:\n    name: str\n    labels?: {str:}\n    annotations?: {str:}\n    replicas: int\n\n_model1 = Model {\n    name = "model1"\n    labels.key1 = "value1"\n    labels.key2 = "value2"\n    annotations.key = "value"\n    replicas = 2\n}\n\n_model2 = Model {\n    name = "model2"\n    replicas = 3\n}\n')),(0,l.kt)("p",null,"backend.k"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'import yaml\n\nschema Backend:\n    apiVersion: str = "v1"\n    kind: str = "Deployment"\n    metadata: {str:}\n    spec: {str:} = {\n        minReadySeconds = 0\n        paused = False\n        progressDeadlineSeconds = 600\n        replicas = 1\n        revisionHistoryLimit = 10\n        selector = {}  \n    }\n\n_backends = [Backend {\n    metadata.name = model.name\n    metadata.labels = model.labels\n    metadata.annotations = model.annotations\n    spec.selector.matchLabels: model.labels\n    spec.replicas = model.replicas\n} for model in Model.instances()]  # Schema Model is defined in model.k\nprint("---\\n".join([yaml.encode(_b, ignore_private=True) for _b in _backends]))\n')),(0,l.kt)("p",null,"The command is"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"kcl model.k backend.k\n")),(0,l.kt)("p",null,"The output is"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: v1\nkind: Deployment\nmetadata:\n  name: model1\n  labels:\n    key1: value1\n    key2: value2\n  annotations:\n    key: value\nspec:\n  minReadySeconds: 0\n  paused: false\n  progressDeadlineSeconds: 600\n  replicas: 2\n  revisionHistoryLimit: 10\n  selector:\n    matchLabels:\n      key1: value1\n      key2: value2\n---\napiVersion: v1\nkind: Deployment\nmetadata:\n  name: model2\nspec:\n  minReadySeconds: 0\n  paused: false\n  progressDeadlineSeconds: 600\n  replicas: 3\n  revisionHistoryLimit: 10\n  selector: {}\n")),(0,l.kt)("h3",{id:"kcl-cli-path-selector"},"KCL CLI Path Selector"),(0,l.kt)("p",null,"We can use KCL CLI ",(0,l.kt)("inlineCode",{parentName:"p"},"-S|--path-selector")," parameter to select one or more values out of a KCL model."),(0,l.kt)("p",null,"The path selector looks like this:"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"var.name")),(0,l.kt)("h4",{id:"examples"},"Examples"),(0,l.kt)("p",null,"Code structure:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},".\n\u251c\u2500\u2500 kcl.mod\n\u2514\u2500\u2500 main.k\n    \u2514\u2500\u2500 pkg\n        \u2514\u2500\u2500 model.k\n")),(0,l.kt)("p",null,"pkg/model.k:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'schema Person:\n    name: str\n    age: int\n\nvar = Person {\n    name = "Alice"\n    age = 18\n}\n')),(0,l.kt)("p",null,"main.k"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'import pkg\n\nvar = pkg.Person {\n    name = "Bob"\n    age = 10\n}\n')),(0,l.kt)("p",null,"The command is"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"kcl main.k -S var\n")),(0,l.kt)("p",null,"The output is"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},"name: Alice\nage: 18\n")),(0,l.kt)("h3",{id:"kcl-cli-variable-override"},"KCL CLI Variable Override"),(0,l.kt)("p",null,"In addition to ",(0,l.kt)("strong",{parentName:"p"},"Variable Selector"),", KCL also allows us to directly modify the values in the configuration model through the KCL CLI ",(0,l.kt)("inlineCode",{parentName:"p"},"-O|--overrides")," parameter."),(0,l.kt)("p",null,"The use of ",(0,l.kt)("strong",{parentName:"p"},"Variable Override")," is similar to ",(0,l.kt)("a",{parentName:"p",href:"#variable-selector"},(0,l.kt)("strong",{parentName:"a"},"Variable Selector")),", and the parameter contains three parts e.g., ",(0,l.kt)("inlineCode",{parentName:"p"},"pkg"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"identifier"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"attribute")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"override_value"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"kcl main.k -O override_spec\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"override_spec")," represents a unified representation of the configuration model fields and values that need to be modified")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-txt"},'override_spec: [[pkgpath] ":"] identifier ("=" value | "-")\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"pkgpath"),": Indicates the path of the package whose identifier needs to be modified, usually in the form of ",(0,l.kt)("inlineCode",{parentName:"li"},"a.b.c"),". For the main package, ",(0,l.kt)("inlineCode",{parentName:"li"},"pkgpath")," is expressed as ",(0,l.kt)("inlineCode",{parentName:"li"},"__main__"),", which can be omitted. If omitted, it means the main package."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"identifier"),": Indicates the identifier that needs to modify the configuration, usually in the form of ",(0,l.kt)("inlineCode",{parentName:"li"},"a.b.c"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"value"),": Indicates the value of the configuration that needs to be modified, which can be any legal KCL expression, such as number/string literal value, list/dict/schema expression, etc."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"="),": means to modify the value of identifier.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"When the identifier exists, modify the value of the existing identifier to value."),(0,l.kt)("li",{parentName:"ul"},"When identifier does not exist, add the identifier attribute and set its value to value."))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"-"),": means to delete the identifier attribute.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"When the identifier exists, delete it directly."),(0,l.kt)("li",{parentName:"ul"},"When the identifier does not exist, no modification is made to the configuration.")))),(0,l.kt)("p",null,"Note: When ",(0,l.kt)("inlineCode",{parentName:"p"},"identifier")," appears multiple times, modify/delete all ",(0,l.kt)("inlineCode",{parentName:"p"},"identifier")," values"),(0,l.kt)("h4",{id:"examples-1"},"Examples"),(0,l.kt)("h5",{id:"override-update-sample"},"Override Update Sample"),(0,l.kt)("p",null,"KCL code:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'schema Person:\n    name: str\n    age: int\n\nperson = Person {\n    name = "Alice"\n    age = 18\n}\n')),(0,l.kt)("p",null,"The command is"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},'kcl main.k -O :person.name=\\"Bob\\" -O :person.age=10\n')),(0,l.kt)("p",null,"The output is"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},"person:\n  name: Bob\n  age: 10\n")),(0,l.kt)("p",null,"Besides, when we use KCL CLI ",(0,l.kt)("inlineCode",{parentName:"p"},"-d")," argument, the KCL file will be modified to the following content at the same time"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},'kcl main.k -O :person.name=\\"Bob\\" -O :person.age=10 -d\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'schema Person:\n    name: str\n    age: int\n\nperson = Person {\n    name = "Bob"\n    age = 10\n}\n')),(0,l.kt)("p",null,"Another more complicated example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'schema Person:\n    name: str\n    age: int\n    ids?: [int]\n\nperson = Person {\n    name = "Alice"\n    age = 10\n}\n')),(0,l.kt)("p",null,"The command is"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"kcl main.k -O :person.ids=\\[1,2\\]\n")),(0,l.kt)("p",null,"The output is"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},"person:\n  name: Alice\n  age: 10\n  ids:\n  - 1\n  - 2\n")),(0,l.kt)("h5",{id:"override-delete-sample"},"Override Delete Sample"),(0,l.kt)("p",null,"KCL code:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'schema Config:\n    x?: int = 1\n    y?: str = "s"\n    \nconfig = Config {\n    x = 2\n}\n')),(0,l.kt)("p",null,"The command is"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"kcl main.k -O config.x-\n")),(0,l.kt)("p",null,"The output is"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},"config:\n  x: 1\n  y: s\n")),(0,l.kt)("h3",{id:"summary"},"Summary"),(0,l.kt)("p",null,"This page summarized the commonly used features in the KCL language. As a new language, KCL will gradually increase the functional features according to the requirements of the configuration scenario."),(0,l.kt)("p",null,"For more information, please try further resources:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"KCL codelabs"),(0,l.kt)("li",{parentName:"ul"},"KCL language specification"),(0,l.kt)("li",{parentName:"ul"},"KCL OpenAPI specification")))}m.isMDXComponent=!0}}]);