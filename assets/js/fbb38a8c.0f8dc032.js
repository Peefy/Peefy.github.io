"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[53055],{3905:(e,t,n)=>{n.d(t,{Zo:()=>h,kt:()=>m});var i=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,i,o=function(e,t){if(null==e)return{};var n,i,o={},a=Object.keys(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=i.createContext({}),c=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},h=function(e){var t=c(e.components);return i.createElement(l.Provider,{value:t},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},u=i.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,h=r(e,["components","mdxType","originalType","parentName"]),d=c(n),u=o,m=d["".concat(l,".").concat(u)]||d[u]||p[u]||a;return n?i.createElement(m,s(s({ref:t},h),{},{components:n})):i.createElement(m,s({ref:t},h))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,s=new Array(a);s[0]=u;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r[d]="string"==typeof e?e:o,s[1]=r;for(var c=2;c<a;c++)s[c]=n[c];return i.createElement.apply(null,s)}return i.createElement.apply(null,n)}u.displayName="MDXCreateElement"},7662:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>a,metadata:()=>r,toc:()=>c});var i=n(87462),o=(n(67294),n(3905));const a={},s="Rewrite KCL LSP in Rust",r={permalink:"/blog/2023/07/10/kcl-LSP",editUrl:"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-07-10-kcl-LSP/index.md",source:"@site/blog/2023-07-10-kcl-LSP/index.md",title:"Rewrite KCL LSP in Rust",description:"The KCL v0.4.6 version has significant updates in language, toolchain, community integration and IDE extension support. In this blog, we'll be discussing the features of the KCL IDE extension and introducing the LSP, as well as talking about the design and implementation of the KCL LSP server and our plans and expectations for the future.",date:"2023-07-10T00:00:00.000Z",formattedDate:"July 10, 2023",tags:[],readingTime:7.545,hasTruncateMarker:!1,authors:[],frontMatter:{},prevItem:{title:"KCL v0.5.0 Release Blog",permalink:"/blog/2022-kcl-0.5.0-release-blog"},nextItem:{title:"KCL Introduction on WAIC 2023 Meeting",permalink:"/blog/2023-07-08-kcl-waic-meeting"}},l={authorsImageUrls:[]},c=[{value:"New Features",id:"new-features",level:2},{value:"What is LSP?",id:"what-is-lsp",level:2},{value:"Why rewrite it in Rust\uff1f",id:"why-rewrite-it-in-rust",level:2},{value:"Design of KCL LSP",id:"design-of-kcl-lsp",level:2},{value:"Problems",id:"problems",level:2},{value:"1. Why do we need a virtual file system?",id:"1-why-do-we-need-a-virtual-file-system",level:3},{value:"2. How to deal with incomplete code?",id:"2-how-to-deal-with-incomplete-code",level:3},{value:"Summary",id:"summary",level:2}],h={toc:c},d="wrapper";function p(e){let{components:t,...a}=e;return(0,o.kt)(d,(0,i.Z)({},h,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"The KCL v0.4.6 version has significant updates in language, toolchain, community integration and IDE extension support. In this blog, we'll be discussing the features of the KCL IDE extension and introducing the LSP, as well as talking about the design and implementation of the KCL LSP server and our plans and expectations for the future."),(0,o.kt)("h2",{id:"new-features"},"New Features"),(0,o.kt)("p",null,"In this update, we have released a new KCL VSCode extension and rewritten the LSP server in Rust. We have provided common code assistance features in the IDE, such as highlight, goto definition, completion, outline, hover, diagnostics, and more."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Syntax Highlight:"),(0,o.kt)("img",{alt:"Highlight",src:n(79102).Z,width:"1312",height:"782"})),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Goto Definition:")," Goto definition of schema, variable, schema attribute, and import pkg.\n",(0,o.kt)("img",{alt:"Goto Definition",src:n(30130).Z,width:"1312",height:"780"})),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Completion:")," Keywords completions and dot(",(0,o.kt)("inlineCode",{parentName:"li"},"."),") completion.\n",(0,o.kt)("img",{alt:"Completion",src:n(23696).Z,width:"1312",height:"780"})),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Outline:")," Main definition(schema def) and variables in KCL file.\n",(0,o.kt)("img",{alt:"Outline",src:n(87560).Z,width:"1312",height:"780"})),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Hover:")," Identifier information (type and schema documentation).\n",(0,o.kt)("img",{alt:"Hover",src:n(57945).Z,width:"1312",height:"780"})),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Diagnostics:")," Warnings and errors in KCL file.\n",(0,o.kt)("img",{alt:"Diagnostics",src:n(64189).Z,width:"1312",height:"780"}))),(0,o.kt)("p",null,"Welcome to ",(0,o.kt)("a",{parentName:"p",href:"https://kcl-lang.io/docs/tools/Ide/vs-code/"},"KCL VSCode extension")," to learn more. \ud83d\udc4f\ud83d\udc4f\ud83d\udc4f"),(0,o.kt)("h2",{id:"what-is-lsp"},"What is LSP?"),(0,o.kt)("p",null,"In this update, we have implemented the above features based on LSP. LSP stands for Language Server Protocol, which is a protocol for programming language tools that was introduced by Microsoft in 2016. It is easy to understand LSP with a picture on the VSCode website."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"LSP",src:n(96887).Z,width:"1162",height:"538"})),(0,o.kt)("p",null,"By LSP, IDE can communicate with the language server which runs on the backend through the JSON-RPC protocol. The language server can provide capabilities such as code analysis, completion, syntax highlighting, and goto definition. Based on LSP, developers can migrate between different editors and IDEs, reducing the development of language tools from M (number of languages) * N (number of editors/IDEs) to M + N."),(0,o.kt)("h2",{id:"why-rewrite-it-in-rust"},"Why rewrite it in Rust\uff1f"),(0,o.kt)("p",null,"The KCL compiler and other tools were originally implemented in Python, and we rewrote its compiler in Rust for performance reasons. After that, we gradually rewrote other tools of KCL, such as testing and formatting tools. In this update, we also rewrote the LSP in consideration of performance issues."),(0,o.kt)("p",null,"In the past, when the Python version LSP server was processing some complex scenarios (over 200 files), for a request of goto definition, the server-side took more than about 6 seconds from receiving the request to calculating the result and responding.  It is almost unavailable. Since the implementation of the server side is mainly based on the lexical analysis and semantic analysis of the front-end and middle-end of the compiler. After we rewrite it in Rust, the performance of this part has been improved by 20 and 40 times, and the remarkable result is that the response time of the server has been greatly improved. Boost, for the same scenario, the response time is reduced to around 100 milliseconds. For some simple scenarios, the response time is only a few milliseconds, which makes the user feel indifferent."),(0,o.kt)("h2",{id:"design-of-kcl-lsp"},"Design of KCL LSP"),(0,o.kt)("p",null,"The KCL LSP is designed as follows\uff1a\n",(0,o.kt)("img",{alt:"KCL-LSP",src:n(41258).Z,width:"627",height:"421"})),(0,o.kt)("p",null,"The main process can be divided into several stages:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Initiate a connection and set the LSP capability. In IDE, when opening a specific file (e.g., *.k  for KCL), the IDE will run the local kcl_language_server binary. This binary is distributed with KCL and installed in KCL's bin directory. After the Server starts, it will start a standard IO Connection and wait for the initialization request sent by the IDE Client. After receiving the initialization request, the server will define the information and capabilities of the server and return it to the client to complete the initial connection of the LSP."),(0,o.kt)("li",{parentName:"ol"},"After the connection is established, the server will start a polling function to continuously receive LSP messages from the client, such as ",(0,o.kt)("inlineCode",{parentName:"li"},"Notification")," (open/close/change/delete files, etc.) and ",(0,o.kt)("inlineCode",{parentName:"li"},"Request")," (goto definition, hover, etc.), as well as messages from the server itself the Task. And uniformly encapsulated into an event (Event) and handed over to the next step for processing."),(0,o.kt)("li",{parentName:"ol"},"For different events, follow the steps below:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-Rust"},"/// Handles an event from one of the many sources that the language server subscribes to.\nfn handle_event(&mut self, event: Event) -> anyhow::Result<()> {\n    // 1. Process the incoming event\n    match event {\n        Event::Task(task) => self.handle_task(task)?,\n        Event::Lsp(msg) => match msg {\n            lsp_server::Message::Request(req) => self.on_request(req, start_time)?,\n            lsp_server::Message::Notification(not) => self.on_notification(not)?,\n            _ => {}\n        },\n    };\n\n    // 2. Process changes\n    let state_changed: bool = self.process_vfs_changes();\n\n    // 3. Handle Diagnostics\n    if state_changed{\n        let mut snapshot = self.snapshot();\n        let task_sender = self.task_sender.clone();\n        // Spawn the diagnostics in the threadpool\n        self.thread_pool.execute(move || {\n            handle_diagnostics(snapshot, task_sender)\uff1f;\n        });\n    }\n\n    Ok(())\n}\n")),(0,o.kt)("p",null,"3.1 Task distribution: According to the task type, the Task is distributed to different sub-functions. In the sub-function, it will be further distributed to the final processing function based on the type of request or notification, such as processing file changes, processing goto definition requests, etc. These functions will analyze the semantic model (AST, symbol table, error information, etc.) compiled based on the front-end of the compiler, calculate and generate the Response (such as the target position of the goto definition request)."),(0,o.kt)("p",null,"3.2 Change processing: When the user modifies the code or changes the file, the corresponding Notification will be sent. In the previous step of processing, the changes are saved in the virtual file system (VFS). The server side will recompile according to the new source code and save the new semantic model for processing the next request."),(0,o.kt)("p",null,"3.3 Diagnostics: the diagnostics here do not refer to LSP server, but to the grammatical and semantic errors and warnings when compiling KCL code. The IDE/editor does not have a request to get these errors, but the LSP server actively sends Diagnostics. Therefore, after the change, the error information is updated on the client side synchronously"),(0,o.kt)("h2",{id:"problems"},"Problems"),(0,o.kt)("h3",{id:"1-why-do-we-need-a-virtual-file-system"},"1. Why do we need a virtual file system?"),(0,o.kt)("p",null,'In the original design, the use of a virtual file system was not considered. Each time we fetch the source code from the file system, compile and analyze it. For some "static" tasks, such as goto definition, you can save the code to the file system after changing, and then find some variables definitions. Cooperating with the automatic save of VS Code, there is no obvious gap in user experience. However, for tasks such as completion, the input of ',(0,o.kt)("inlineCode",{parentName:"p"},".")," on the IDE/editor will trigger a file change notification and a request for completion, but the code has not been saved in the file system. Therefore, the semantic model cannot be analyzed correctly. Therefore, we realized the virtual file system with the creation of Rust Analyzer's vfs and changed the compilation entry from the file path to the source code. After the client enters the code, the file change notification will first update the virtual file system, recompile the file, and then process the completion request."),(0,o.kt)("h3",{id:"2-how-to-deal-with-incomplete-code"},"2. How to deal with incomplete code?"),(0,o.kt)("p",null,'Another big problem we encountered was how to deal with incomplete code. Likewise, for "static" tasks, e.g., goto definition, the code can be assumed to be complete and correct. But for the request of completion, such as the following code, I hope to complete the function of the string after entering ',(0,o.kt)("inlineCode",{parentName:"p"},"."),".For the compilation process, the second line is an incomplete code that cannot be compiled into a normal AST tree."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'s: str = "hello kcl"\nlen = s.\n')),(0,o.kt)("p",null,"To this end, we have implemented a variety of syntactic and semantic error recovery in KCL compilation, ensuring that the compilation process can always produce a complete AST and symbol table. In this example, we added an empty AST node as a placeholder, so that the second line can generate a complete AST. When processing the completion request, it will complete the function name, schema attr or the schema name defined in pkg according to the type of ",(0,o.kt)("inlineCode",{parentName:"p"},"s")," and other semantic information."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Rust Analyzer architecture:"),(0,o.kt)("p",{parentName:"blockquote"},"Architecture Invariant: parsing never fails, the parser produces (T, Vec","<","Error",">",") rather than Result","<","T, Error",">",".")),(0,o.kt)("h2",{id:"summary"},"Summary"),(0,o.kt)("p",null,"KCL's IDE extension has already implemented capabilities such as highlighting, goto definition, completion, outline, hovering, and diagnostics. These features improve the development efficiency of KCL users. However, as an IDE extension, its functionality is not complete enough. In the future, we will continue to improve its capabilities. Future work has the following aspects:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"More capabilities: Provide more capabilities, such as code refactoring, error quick fix, code fmt, etc., to further improve capabilities and improve development efficiency"),(0,o.kt)("li",{parentName:"ul"},"More IDE Integration: At present, although KCL provides LSP, it only integrates with VS Code. In the future, KCL users will be provided with more choices based on the capabilities of LSP."),(0,o.kt)("li",{parentName:"ul"},"Integration of AI: At present, ChatGPT is popular all over the Internet. We are also exploring the combination of AI\xd7KCL to provide a more intelligent R&D experience.")),(0,o.kt)("p",null,"In summary, we will continue to improve and optimize KCL's IDE extension to make it more powerful and practical. Bring more convenient and efficient development experience to KCL users.\nIf you have more ideas or needs, welcome to issue or discuss them in the KCL Github repo, and welcome to join our community for communication \ud83d\ude4c \ud83d\ude4c \ud83d\ude4c"))}p.isMDXComponent=!0},41258:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/kcl-LSP-5466adee5a10481b8f41cb615977a034.png"},96887:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/lsp-4d40c09909e7dc972f884e4eefea5a92.png"},23696:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/Completion-584771cd4bed237e74d3da3decaa9757.gif"},64189:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/Diagnostics-716fc3b938a94e4db2cbafaad4f4174d.gif"},30130:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/GotoDef-0875243eacd6b76e49b7a5b95cb9ce55.gif"},79102:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/Highlight-7e1f5208ba57f3ebe9926efba8e270a2.png"},57945:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/Hover-339697d17ca0d4f167b1b1a904c9f1aa.gif"},87560:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/Outline-c443b2ee1e35746795e7b09c11f3f4da.gif"}}]);