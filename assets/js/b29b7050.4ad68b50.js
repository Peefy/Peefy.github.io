"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[1280],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>g});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=c(n),m=o,g=u["".concat(s,".").concat(m)]||u[m]||d[m]||i;return n?a.createElement(g,r(r({ref:t},p),{},{components:n})):a.createElement(g,r({ref:t},p))}));function g(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[u]="string"==typeof e?e:o,r[1]=l;for(var c=2;c<i;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},86388:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>d,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var a=n(87462),o=(n(67294),n(3905));const i={slug:"2023-07-31-kcl-github-argocd-gitops",title:"Implementing GitOps using Github, Argo CD, and KCL to Simplify DevOps",authors:{name:"KCL Team",title:"KCL Team"},tags:["KCL","Github","ArgoCD","GitOps"]},r=void 0,l={permalink:"/blog/2023-07-31-kcl-github-argocd-gitops",editUrl:"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-07-31-kcl-github-argocd-gitops/index.md",source:"@site/blog/2023-07-31-kcl-github-argocd-gitops/index.md",title:"Implementing GitOps using Github, Argo CD, and KCL to Simplify DevOps",description:"Introduction",date:"2023-07-31T00:00:00.000Z",formattedDate:"July 31, 2023",tags:[{label:"KCL",permalink:"/blog/tags/kcl"},{label:"Github",permalink:"/blog/tags/github"},{label:"ArgoCD",permalink:"/blog/tags/argo-cd"},{label:"GitOps",permalink:"/blog/tags/git-ops"}],readingTime:8.16,hasTruncateMarker:!1,authors:[{name:"KCL Team",title:"KCL Team"}],frontMatter:{slug:"2023-07-31-kcl-github-argocd-gitops",title:"Implementing GitOps using Github, Argo CD, and KCL to Simplify DevOps",authors:{name:"KCL Team",title:"KCL Team"},tags:["KCL","Github","ArgoCD","GitOps"]},prevItem:{title:"KCL Biweekly Newsletter (2023 07.26 - 08.09) | KCL v0.5.1 and v0.5.2 is out!",permalink:"/blog/2023-08-09-biweekly-newsletter"},nextItem:{title:"KCL Introduction Slides",permalink:"/blog/2023-07-18-kcl-intro-slides"}},s={authorsImageUrls:[void 0]},c=[{value:"Introduction",id:"introduction",level:2},{value:"What is GitOps",id:"what-is-gitops",level:3},{value:"GitOps with KCL",id:"gitops-with-kcl",level:3},{value:"Workflow",id:"workflow",level:2},{value:"Steps",id:"steps",level:2},{value:"0. Prerequisite",id:"0-prerequisite",level:3},{value:"1. Setup Kubernetes Cluster",id:"1-setup-kubernetes-cluster",level:3},{value:"2. Setup ArgoCD",id:"2-setup-argocd",level:3},{value:"Setup ArgoCD Controllers",id:"setup-argocd-controllers",level:4},{value:"Setup ArgoCD CLI",id:"setup-argocd-cli",level:4},{value:"3. Get the Application Code",id:"3-get-the-application-code",level:3},{value:"4. Commit the Application Code",id:"4-commit-the-application-code",level:3},{value:"5. Configuration Automatic Update",id:"5-configuration-automatic-update",level:3},{value:"Conclusion",id:"conclusion",level:2}],p={toc:c},u="wrapper";function d(e){let{components:t,...i}=e;return(0,o.kt)(u,(0,a.Z)({},p,i,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"introduction"},"Introduction"),(0,o.kt)("p",null,"In modern software development, GitOps, as a single truth automation method for managing infrastructure and applications, plays a key role in improving efficiency and reducing Human error, and is now widely popular in cloud-native and other fields. However, there are not many practical examples related to GitOps. This blog will use KCL, Github and ArgoCD as examples to introduce GitOps in detail, hoping to help everyone practice their own GitOps automation process and simplify DevOps."),(0,o.kt)("h3",{id:"what-is-gitops"},"What is GitOps"),(0,o.kt)("p",null,"GitOps is a modern way to do continuous delivery. Its core idea is to have a Git repository which contains environmental and application configurations. An automated process is also needed for sync the config to cluster."),(0,o.kt)("p",null,"By changing the files in repository, developers can apply the applications automatically. The benefits of applying GitOps include:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Increased productivity. Continuous delivery can speed up the time of deployment."),(0,o.kt)("li",{parentName:"ul"},"Lower the barrier for developer to deploy. By pushing code instead of container configuration, developers can easily deploy Kubernetes without knowing its internal implementation."),(0,o.kt)("li",{parentName:"ul"},"Trace the change records. Managing the cluster with Git makes every change traceable, enhancing the audit trail."),(0,o.kt)("li",{parentName:"ul"},"Recover the cluster with Git's rollback and branch.")),(0,o.kt)("h3",{id:"gitops-with-kcl"},"GitOps with KCL"),(0,o.kt)("p",null,"Benefits of Using KCL and ArgoCD Together:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"KCL can help us ",(0,o.kt)("strong",{parentName:"li"},"simplify complex Kubernetes deployment configuration files"),", reduce the error rate of manually writing YAML files, control configuration constraint checking during compilation, and perceive errors immediately upon writing; At the same time, KCL can be used to eliminate redundant configuration templates, enhance the scalability of multi-environment and multi-tenant configurations, and improve the readability and maintainability of configurations."),(0,o.kt)("li",{parentName:"ul"},"ArgoCD can ",(0,o.kt)("strong",{parentName:"li"},"automate")," the deployment of Kubernetes applications, achieve continuous deployment, and provide comprehensive monitoring and control functions."),(0,o.kt)("li",{parentName:"ul"},"By combining KCL and ArgoCD, deployment efficiency can be improved, errors reduced, and management and monitoring of Kubernetes applications strengthened."),(0,o.kt)("li",{parentName:"ul"},"The combination of KCL and ArgoCD can also help us achieve ",(0,o.kt)("strong",{parentName:"li"},"Infrastructure as Code (IaC)"),", simplify application deployment and management, and better implement DevOps principles.")),(0,o.kt)("p",null,"With GitOps, developer and operation teams can manage application deployment and configuration by modifying KCL code and generating YAML files. The GitOps toolchain will automatically synchronize the changes to the Kubernetes cluster, enabling continuous deployment and ensuring consistency. If there are issues, the GitOps toolchain can be used to quickly rollback."),(0,o.kt)("h2",{id:"workflow"},"Workflow"),(0,o.kt)("p",null,"We hope to implement the end-to-end application development process by using containers, Continuous Integration (CI) for generation, and GitOps for Continuous Deployment (CD). In this scheme, we use a ",(0,o.kt)("strong",{parentName:"p"},"Flask application")," and ",(0,o.kt)("strong",{parentName:"p"},"Github Actions")," as examples."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Note: You can use any containerized application and different CI systems such as ",(0,o.kt)("strong",{parentName:"p"},"Gitlab CI"),", ",(0,o.kt)("strong",{parentName:"p"},"Jenkins CI"),", etc. in this solution.")),(0,o.kt)("p",null,"We divide the Python Flask application code and configuration code into two repos, ",(0,o.kt)("em",{parentName:"p"},"to achieve the separation of concerns of different roles, such as developers and operation and maintenance teams")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"App code repo: ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/kcl-lang/flask-demo"},"https://github.com/kcl-lang/flask-demo")),(0,o.kt)("li",{parentName:"ul"},"Config manifest repo: ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/kcl-lang/flask-demo-kcl-manifests"},"https://github.com/kcl-lang/flask-demo-kcl-manifests"))),(0,o.kt)("p",null,"The overall workflow is as follows:"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"workflow",src:n(42983).Z,width:"1048",height:"624"})),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Pull application code from Github."),(0,o.kt)("li",{parentName:"ol"},"Develop and submit application code to the GitHub repository."),(0,o.kt)("li",{parentName:"ol"},"Trigger GitHub Actions to compile the application code, generate container images, and push the container images to the Docker Hub container registry."),(0,o.kt)("li",{parentName:"ol"},"Trigger GitHub Actions to synchronously update the Kubernetes manifest files defined by KCL based on the version of the container image in the ",(0,o.kt)("inlineCode",{parentName:"li"},"docker.io")," container registry."),(0,o.kt)("li",{parentName:"ol"},"ArgoCD obtains Kubernetes manifest changes and updates deployment to Kubernetes cluster.")),(0,o.kt)("h2",{id:"steps"},"Steps"),(0,o.kt)("h3",{id:"0-prerequisite"},"0. Prerequisite"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Familiar with the basic commands of Unix/Linux"),(0,o.kt)("li",{parentName:"ul"},"Familiar with Git and Github Action"),(0,o.kt)("li",{parentName:"ul"},"Understand the basics of Kubernetes"),(0,o.kt)("li",{parentName:"ul"},"Understand tools such as ArgoCD"),(0,o.kt)("li",{parentName:"ul"},"Understand the basic knowledge of KCL")),(0,o.kt)("h3",{id:"1-setup-kubernetes-cluster"},"1. Setup Kubernetes Cluster"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Install ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/k3d-io/k3d"},"K3d")," to create a default cluster.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"k3d cluster create mycluster\n")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Note: You can use other methods in this solution to create your own Kubernetes cluster, such as ",(0,o.kt)("inlineCode",{parentName:"p"},"kind"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"minikube"),", etc.")),(0,o.kt)("h3",{id:"2-setup-argocd"},"2. Setup ArgoCD"),(0,o.kt)("h4",{id:"setup-argocd-controllers"},"Setup ArgoCD Controllers"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Install ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/argoproj/argo-cd/releases/"},"ArgoCD"),".")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl create namespace argocd\nkubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Enable ArgoCD KCL Plugin")),(0,o.kt)("p",null,"Write the patch YAML configuration file and update the ArgoCD configuration:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"git clone https://github.com/kcl-lang/kcl-lang.io.git/ && cd ./kcl-lang.io/examples/gitops\nkubectl apply -f ./install/kcl-cmp.yaml\n")),(0,o.kt)("p",null,"After completing the first step, ArgoCD will recognize the KCL plugin, but the KCL plugin has not been loaded into the ArgoCD image. To implement configuration drift detection, we have to tune the Deployment of argocd-repo-server."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},'kubectl -n argocd patch deploy/argocd-repo-server -p "$(cat ./install/patch-argocd-repo-server.yaml)"\n')),(0,o.kt)("p",null,"Wait for the init container to complete execution (Running)."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl get pod -n argocd -l app.kubernetes.io/name=argocd-repo-server\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"To access the ArgoCD web UI")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl port-forward svc/argocd-server -n argocd 8080:443\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Open a browser and go to: ",(0,o.kt)("inlineCode",{parentName:"p"},"https://localhost:8080"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},'The username is "admin" and password get be obtained from the following command:'))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},'kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d\n')),(0,o.kt)("h4",{id:"setup-argocd-cli"},"Setup ArgoCD CLI"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Install ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/argoproj/argo-cd/releases"},"ArgoCD CLI"))),(0,o.kt)("p",null,'Use "admin" and password to login to ArgoCD'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"argocd login localhost:8080\n")),(0,o.kt)("p",null,"Create ArgoCD Application"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"argocd app create flaskdemo \\\n--repo https://github.com/kcl-lang/flask-demo-kcl-manifests \\\n--path . \\\n--dest-namespace default \\\n--dest-server https://kubernetes.default.svc \\\n--config-management-plugin kcl-v1.0\n")),(0,o.kt)("p",null,"After successfully creating, you can see the following output:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"application 'flaskdemo' created\n")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"If you are using a private repository, you need to configure the private repository access with private key credentials before executing the create command.Please refer ",(0,o.kt)("a",{parentName:"p",href:"https://argo-cd.readthedocs.io/en/stable/user-guide/private-repositories/#ssh-private-key-credential"},"Private Repositories")," for more details.")),(0,o.kt)("p",null,"Through the ArgoCD UI, you can see that the created applications have not been synchronized yet. Here, you can manually synchronize or set automatic synchronization."),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(82783).Z,width:"2128",height:"1008"})),(0,o.kt)("p",null,"For more information on synchronization strategies, see ",(0,o.kt)("a",{parentName:"p",href:"https://argo-cd.readthedocs.io/en/stable/user-guide/sync-options/"},"Sync Options")),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(26084).Z,width:"3328",height:"1132"})),(0,o.kt)("h3",{id:"3-get-the-application-code"},"3. Get the Application Code"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"git clone https://github.com/kcl-lang/flask-demo.git/\ncd flask-demo\n")),(0,o.kt)("p",null,"This is a web application written in Python. We can use the ",(0,o.kt)("inlineCode",{parentName:"p"},"Dockerfile")," in the application directory to generate a container image of this application, and also use Github CI to automatically build a image named ",(0,o.kt)("inlineCode",{parentName:"p"},"flask_demo"),", the CI configuration is as follows"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},'# This is a basic workflow to help you get started with Actions\n\nname: CI\n\n# Controls when the workflow will run\non:\n  # Triggers the workflow on push or pull request events but only for the main branch\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\n  # Allows you to run this workflow manually from the Actions tab\n  workflow_dispatch:\n\n# A workflow run is made up of one or more jobs that can run sequentially or in parallel\njobs:\n  # This workflow contains a single job called "build"\n  build:\n    # The type of runner that the job will run on\n    runs-on: ubuntu-latest\n\n    # Steps represent a sequence of tasks that will be executed as part of the job\n    steps:\n      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it\n      - uses: actions/checkout@v2\n      \n      - name: Docker Login\n        uses: docker/login-action@v1.10.0\n        with:\n          username: ${{ secrets.DOCKER_USERNAME }}\n          password: ${{ secrets.DOCKER_PASSWORD }}\n          logout: true\n\n      # Runs a set of commands using the runners shell\n      - name: build image\n        run: |\n          make image\n          docker tag flask_demo:latest ${{ secrets.DOCKER_USERNAME }}/flask_demo:${{ github.sha }}\n          docker push ${{ secrets.DOCKER_USERNAME }}/flask_demo:${{ github.sha }}\n\n      # Trigger KCL manifest\n      - name: Trigger CI\n        uses: InformaticsMatters/trigger-ci-action@1.0.1\n        with:\n          ci-owner: kcl-lang\n          ci-repository: flask-demo-kcl-manifests\n          ci-ref: refs/heads/main\n          ci-user: kcl-bot\n          ci-user-token: ${{ secrets.DEPLOY_ACCESS_TOKEN }}\n          ci-name: CI\n          ci-inputs: >-\n            image=${{ secrets.DOCKER_USERNAME }}/flask_demo\n            sha-tag=${{ github.sha }}\n')),(0,o.kt)("p",null,"We need the workflow in the source code repository to automatically trigger the workflow in the deployment manifest repository. At this point, we need to create a ",(0,o.kt)("inlineCode",{parentName:"p"},"secrets.DEPLOY_ACCESS_TOKEN")," with Github CI operation permissions and ",(0,o.kt)("strong",{parentName:"p"},"Docker Hub")," image push account information ",(0,o.kt)("inlineCode",{parentName:"p"},"secrets.DOCKER_USERNAME")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"secrets.DOCKER_PASSWORD"),"  can be configured in the ",(0,o.kt)("inlineCode",{parentName:"p"},"Secrets and variables")," settings of the Github, as shown in the following figure"),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(72621).Z,width:"2204",height:"632"})),(0,o.kt)("h3",{id:"4-commit-the-application-code"},"4. Commit the Application Code"),(0,o.kt)("p",null,"After submitting in the ",(0,o.kt)("inlineCode",{parentName:"p"},"flask-demo")," repository, Github will automatically build a container image and push it to the Docker hub. It will also then trigger the Action of the ",(0,o.kt)("inlineCode",{parentName:"p"},"flask-demo-kcl-manifest")," repository and modify the image value in the deployment manifest repository through ",(0,o.kt)("a",{parentName:"p",href:"/docs/user_docs/guides/automation"},"KCL Automation API"),". Now let's create a submission in the ",(0,o.kt)("inlineCode",{parentName:"p"},"flask-demo")," repository, and we can see that the code submission triggers the Github CI process for the application repository."),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(87432).Z,width:"2252",height:"1038"})),(0,o.kt)("h3",{id:"5-configuration-automatic-update"},"5. Configuration Automatic Update"),(0,o.kt)("p",null,"After the Github CI process in the application repository is completed, an automatic update configuration CI will be triggered in the repository where the KCL configuration is stored and submitted to the main branch of the ",(0,o.kt)("inlineCode",{parentName:"p"},"flask-demo-kcl-manifests")," repository. The commit information is as follows"),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(34491).Z,width:"2240",height:"1090"})),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"We can obtain the deployment manifest source code for compilation and validation")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"git clone https://github.com/kcl-lang/flask-demo-kcl-manifests.git/\ncd flask-demo-kcl-manifests\ngit checkout main && git pull && kcl\n")),(0,o.kt)("p",null,"The output YAML is"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},'apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: flask_demo\n  labels:\n    app: flask_demo\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: flask_demo\n  template:\n    metadata:\n      labels:\n        app: flask_demo\n    spec:\n      containers:\n        - name: flask_demo\n          image: "kcllang/flask_demo:6428cff4309afc8c1c40ad180bb9cfd82546be3e"\n          ports:\n            - protocol: TCP\n              containerPort: 5000\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: flask_demo\n  labels:\n    app: flask_demo\nspec:\n  type: NodePort\n  selector:\n    app: flask_demo\n  ports:\n    - port: 5000\n      protocol: TCP\n      targetPort: 5000\n')),(0,o.kt)("p",null,"From the above configuration, it can be seen that the image of the resource is indeed automatically updated to the newly constructed image value. In addition, we can also use the ",(0,o.kt)("strong",{parentName:"p"},"Argo CD KCL plugin")," to automatically synchronize data from the Git repository and deploy the application to the Kubernetes cluster."),(0,o.kt)("h2",{id:"conclusion"},"Conclusion"),(0,o.kt)("p",null,"Through the blog, we can use Github, ArgoCD, and KCL to create GitOps automated pipelines, which can efficiently and stably build containerized applications, while automatically updating the latest Dbroker image labels and keeping Git configuration consistent with cluster configuration. In addition, the combination of KCL and ArgoCD can help us better realize Infrastructure as Code (IaC), improve deployment efficiency, achieve the separation of concerns of different roles, and simplify the configuration management of applications."))}d.isMDXComponent=!0},42983:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/workflow-e95f2993e77762a23be96013944a68d7.jpg"},87432:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/app-ci-722f8f31885ae67c956df7921faf15bd.png"},72621:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/github-secrets-c08dcb44c0fabc46137aefefaf3f9c97.png"},34491:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/image-auto-update-c98f7e713ab04391266ae88c99e85492.png"},26084:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/argocd-kcl-app-dashboard-2bce178f2be48ed46cee799d02e44b36.jpg"},82783:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/argocd-kcl-app-6375cd6479ce5c6c2af2786fd331afe0.jpg"}}]);